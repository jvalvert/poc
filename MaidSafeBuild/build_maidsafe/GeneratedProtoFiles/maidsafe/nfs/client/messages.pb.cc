// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/nfs/client/messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "maidsafe/nfs/client/messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace nfs_client {
namespace protobuf {

void protobuf_ShutdownFile_maidsafe_2fnfs_2fclient_2fmessages_2eproto() {
  delete ReturnCode::default_instance_;
  delete AvailableSizeAndReturnCode::default_instance_;
  delete DataNameAndReturnCode::default_instance_;
  delete DataNameAndSizeAndReturnCode::default_instance_;
  delete DataNamesAndReturnCode::default_instance_;
  delete DataNameVersionAndReturnCode::default_instance_;
  delete DataNameOldNewVersionAndReturnCode::default_instance_;
  delete DataAndReturnCode::default_instance_;
  delete DataNameAndContentOrReturnCode::default_instance_;
  delete StructuredDataNameAndContentOrReturnCode::default_instance_;
  delete DataNameAndSizeAndSpaceAndReturnCode::default_instance_;
  delete TipOfTreeAndReturnCode::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ReturnCode::default_instance_ = new ReturnCode();
  AvailableSizeAndReturnCode::default_instance_ = new AvailableSizeAndReturnCode();
  DataNameAndReturnCode::default_instance_ = new DataNameAndReturnCode();
  DataNameAndSizeAndReturnCode::default_instance_ = new DataNameAndSizeAndReturnCode();
  DataNamesAndReturnCode::default_instance_ = new DataNamesAndReturnCode();
  DataNameVersionAndReturnCode::default_instance_ = new DataNameVersionAndReturnCode();
  DataNameOldNewVersionAndReturnCode::default_instance_ = new DataNameOldNewVersionAndReturnCode();
  DataAndReturnCode::default_instance_ = new DataAndReturnCode();
  DataNameAndContentOrReturnCode::default_instance_ = new DataNameAndContentOrReturnCode();
  StructuredDataNameAndContentOrReturnCode::default_instance_ = new StructuredDataNameAndContentOrReturnCode();
  DataNameAndSizeAndSpaceAndReturnCode::default_instance_ = new DataNameAndSizeAndSpaceAndReturnCode();
  TipOfTreeAndReturnCode::default_instance_ = new TipOfTreeAndReturnCode();
  ReturnCode::default_instance_->InitAsDefaultInstance();
  AvailableSizeAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataNameAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataNameAndSizeAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataNamesAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataNameVersionAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataNameOldNewVersionAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataAndReturnCode::default_instance_->InitAsDefaultInstance();
  DataNameAndContentOrReturnCode::default_instance_->InitAsDefaultInstance();
  StructuredDataNameAndContentOrReturnCode::default_instance_->InitAsDefaultInstance();
  DataNameAndSizeAndSpaceAndReturnCode::default_instance_->InitAsDefaultInstance();
  TipOfTreeAndReturnCode::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_maidsafe_2fnfs_2fclient_2fmessages_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto_once_);
void protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto_once_,
                 &protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_maidsafe_2fnfs_2fclient_2fmessages_2eproto {
  StaticDescriptorInitializer_maidsafe_2fnfs_2fclient_2fmessages_2eproto() {
    protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
  }
} static_descriptor_initializer_maidsafe_2fnfs_2fclient_2fmessages_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int ReturnCode::kErrorValueFieldNumber;
const int ReturnCode::kErrorCategoryNameFieldNumber;
#endif  // !_MSC_VER

ReturnCode::ReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ReturnCode::InitAsDefaultInstance() {
}

ReturnCode::ReturnCode(const ReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ReturnCode::SharedCtor() {
  _cached_size_ = 0;
  error_value_ = 0;
  error_category_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReturnCode::~ReturnCode() {
  SharedDtor();
}

void ReturnCode::SharedDtor() {
  if (error_category_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete error_category_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReturnCode& ReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

ReturnCode* ReturnCode::default_instance_ = NULL;

ReturnCode* ReturnCode::New() const {
  return new ReturnCode;
}

void ReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_value_ = 0;
    if (has_error_category_name()) {
      if (error_category_name_ != &::google::protobuf::internal::GetEmptyString()) {
        error_category_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 error_value = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_value_)));
          set_has_error_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_error_category_name;
        break;
      }

      // required bytes error_category_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error_category_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_error_category_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 error_value = 1;
  if (has_error_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->error_value(), output);
  }

  // required bytes error_category_name = 2;
  if (has_error_category_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->error_category_name(), output);
  }

}

int ReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 error_value = 1;
    if (has_error_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->error_value());
    }

    // required bytes error_category_name = 2;
    if (has_error_category_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->error_category_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReturnCode*>(&from));
}

void ReturnCode::MergeFrom(const ReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_value()) {
      set_error_value(from.error_value());
    }
    if (from.has_error_category_name()) {
      set_error_category_name(from.error_category_name());
    }
  }
}

void ReturnCode::CopyFrom(const ReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ReturnCode::Swap(ReturnCode* other) {
  if (other != this) {
    std::swap(error_value_, other->error_value_);
    std::swap(error_category_name_, other->error_category_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.ReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int AvailableSizeAndReturnCode::kSerialisedAvailableSizeFieldNumber;
const int AvailableSizeAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

AvailableSizeAndReturnCode::AvailableSizeAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AvailableSizeAndReturnCode::InitAsDefaultInstance() {
}

AvailableSizeAndReturnCode::AvailableSizeAndReturnCode(const AvailableSizeAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AvailableSizeAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_available_size_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AvailableSizeAndReturnCode::~AvailableSizeAndReturnCode() {
  SharedDtor();
}

void AvailableSizeAndReturnCode::SharedDtor() {
  if (serialised_available_size_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_available_size_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AvailableSizeAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AvailableSizeAndReturnCode& AvailableSizeAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

AvailableSizeAndReturnCode* AvailableSizeAndReturnCode::default_instance_ = NULL;

AvailableSizeAndReturnCode* AvailableSizeAndReturnCode::New() const {
  return new AvailableSizeAndReturnCode;
}

void AvailableSizeAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_available_size()) {
      if (serialised_available_size_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_available_size_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AvailableSizeAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_available_size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_available_size()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AvailableSizeAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_available_size = 1;
  if (has_serialised_available_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_available_size(), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int AvailableSizeAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_available_size = 1;
    if (has_serialised_available_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_available_size());
    }

    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AvailableSizeAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AvailableSizeAndReturnCode*>(&from));
}

void AvailableSizeAndReturnCode::MergeFrom(const AvailableSizeAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_available_size()) {
      set_serialised_available_size(from.serialised_available_size());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void AvailableSizeAndReturnCode::CopyFrom(const AvailableSizeAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableSizeAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AvailableSizeAndReturnCode::Swap(AvailableSizeAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_available_size_, other->serialised_available_size_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AvailableSizeAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.AvailableSizeAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndReturnCode::kSerialisedNameFieldNumber;
const int DataNameAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNameAndReturnCode::DataNameAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndReturnCode::InitAsDefaultInstance() {
}

DataNameAndReturnCode::DataNameAndReturnCode(const DataNameAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndReturnCode::~DataNameAndReturnCode() {
  SharedDtor();
}

void DataNameAndReturnCode::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndReturnCode& DataNameAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndReturnCode* DataNameAndReturnCode::default_instance_ = NULL;

DataNameAndReturnCode* DataNameAndReturnCode::New() const {
  return new DataNameAndReturnCode;
}

void DataNameAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int DataNameAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndReturnCode*>(&from));
}

void DataNameAndReturnCode::MergeFrom(const DataNameAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNameAndReturnCode::CopyFrom(const DataNameAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameAndReturnCode::Swap(DataNameAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNameAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndSizeAndReturnCode::kSerialisedNameFieldNumber;
const int DataNameAndSizeAndReturnCode::kSizeFieldNumber;
const int DataNameAndSizeAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNameAndSizeAndReturnCode::DataNameAndSizeAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndSizeAndReturnCode::InitAsDefaultInstance() {
}

DataNameAndSizeAndReturnCode::DataNameAndSizeAndReturnCode(const DataNameAndSizeAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndSizeAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  size_ = GOOGLE_ULONGLONG(0);
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndSizeAndReturnCode::~DataNameAndSizeAndReturnCode() {
  SharedDtor();
}

void DataNameAndSizeAndReturnCode::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndSizeAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndSizeAndReturnCode& DataNameAndSizeAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndSizeAndReturnCode* DataNameAndSizeAndReturnCode::default_instance_ = NULL;

DataNameAndSizeAndReturnCode* DataNameAndSizeAndReturnCode::New() const {
  return new DataNameAndSizeAndReturnCode;
}

void DataNameAndSizeAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    size_ = GOOGLE_ULONGLONG(0);
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndSizeAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }

      // required uint64 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndSizeAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required uint64 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->size(), output);
  }

  // required bytes serialised_return_code = 3;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->serialised_return_code(), output);
  }

}

int DataNameAndSizeAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required uint64 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

    // required bytes serialised_return_code = 3;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndSizeAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndSizeAndReturnCode*>(&from));
}

void DataNameAndSizeAndReturnCode::MergeFrom(const DataNameAndSizeAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNameAndSizeAndReturnCode::CopyFrom(const DataNameAndSizeAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndSizeAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void DataNameAndSizeAndReturnCode::Swap(DataNameAndSizeAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(size_, other->size_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndSizeAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNameAndSizeAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNamesAndReturnCode::kSerialisedNameFieldNumber;
const int DataNamesAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNamesAndReturnCode::DataNamesAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNamesAndReturnCode::InitAsDefaultInstance() {
}

DataNamesAndReturnCode::DataNamesAndReturnCode(const DataNamesAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNamesAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNamesAndReturnCode::~DataNamesAndReturnCode() {
  SharedDtor();
}

void DataNamesAndReturnCode::SharedDtor() {
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNamesAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNamesAndReturnCode& DataNamesAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNamesAndReturnCode* DataNamesAndReturnCode::default_instance_ = NULL;

DataNamesAndReturnCode* DataNamesAndReturnCode::New() const {
  return new DataNamesAndReturnCode;
}

void DataNamesAndReturnCode::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  serialised_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNamesAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_serialised_name;
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNamesAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes serialised_name = 1;
  for (int i = 0; i < this->serialised_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(i), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int DataNamesAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  // repeated bytes serialised_name = 1;
  total_size += 1 * this->serialised_name_size();
  for (int i = 0; i < this->serialised_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->serialised_name(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNamesAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNamesAndReturnCode*>(&from));
}

void DataNamesAndReturnCode::MergeFrom(const DataNamesAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  serialised_name_.MergeFrom(from.serialised_name_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNamesAndReturnCode::CopyFrom(const DataNamesAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNamesAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void DataNamesAndReturnCode::Swap(DataNamesAndReturnCode* other) {
  if (other != this) {
    serialised_name_.Swap(&other->serialised_name_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNamesAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNamesAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameVersionAndReturnCode::kSerialisedDataNameAndVersionFieldNumber;
const int DataNameVersionAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNameVersionAndReturnCode::DataNameVersionAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameVersionAndReturnCode::InitAsDefaultInstance() {
}

DataNameVersionAndReturnCode::DataNameVersionAndReturnCode(const DataNameVersionAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameVersionAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_data_name_and_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameVersionAndReturnCode::~DataNameVersionAndReturnCode() {
  SharedDtor();
}

void DataNameVersionAndReturnCode::SharedDtor() {
  if (serialised_data_name_and_version_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_and_version_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameVersionAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameVersionAndReturnCode& DataNameVersionAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameVersionAndReturnCode* DataNameVersionAndReturnCode::default_instance_ = NULL;

DataNameVersionAndReturnCode* DataNameVersionAndReturnCode::New() const {
  return new DataNameVersionAndReturnCode;
}

void DataNameVersionAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_data_name_and_version()) {
      if (serialised_data_name_and_version_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_and_version_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameVersionAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_data_name_and_version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name_and_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameVersionAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_data_name_and_version = 1;
  if (has_serialised_data_name_and_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_data_name_and_version(), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int DataNameVersionAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_data_name_and_version = 1;
    if (has_serialised_data_name_and_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name_and_version());
    }

    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameVersionAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameVersionAndReturnCode*>(&from));
}

void DataNameVersionAndReturnCode::MergeFrom(const DataNameVersionAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_data_name_and_version()) {
      set_serialised_data_name_and_version(from.serialised_data_name_and_version());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNameVersionAndReturnCode::CopyFrom(const DataNameVersionAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameVersionAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameVersionAndReturnCode::Swap(DataNameVersionAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_data_name_and_version_, other->serialised_data_name_and_version_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameVersionAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNameVersionAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameOldNewVersionAndReturnCode::kSerialisedDataNameOldNewVersionFieldNumber;
const int DataNameOldNewVersionAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNameOldNewVersionAndReturnCode::DataNameOldNewVersionAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameOldNewVersionAndReturnCode::InitAsDefaultInstance() {
}

DataNameOldNewVersionAndReturnCode::DataNameOldNewVersionAndReturnCode(const DataNameOldNewVersionAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameOldNewVersionAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_data_name_old_new_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameOldNewVersionAndReturnCode::~DataNameOldNewVersionAndReturnCode() {
  SharedDtor();
}

void DataNameOldNewVersionAndReturnCode::SharedDtor() {
  if (serialised_data_name_old_new_version_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_old_new_version_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameOldNewVersionAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameOldNewVersionAndReturnCode& DataNameOldNewVersionAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameOldNewVersionAndReturnCode* DataNameOldNewVersionAndReturnCode::default_instance_ = NULL;

DataNameOldNewVersionAndReturnCode* DataNameOldNewVersionAndReturnCode::New() const {
  return new DataNameOldNewVersionAndReturnCode;
}

void DataNameOldNewVersionAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_data_name_old_new_version()) {
      if (serialised_data_name_old_new_version_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_old_new_version_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameOldNewVersionAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_data_name_old_new_version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name_old_new_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameOldNewVersionAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_data_name_old_new_version = 1;
  if (has_serialised_data_name_old_new_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_data_name_old_new_version(), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int DataNameOldNewVersionAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_data_name_old_new_version = 1;
    if (has_serialised_data_name_old_new_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name_old_new_version());
    }

    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameOldNewVersionAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameOldNewVersionAndReturnCode*>(&from));
}

void DataNameOldNewVersionAndReturnCode::MergeFrom(const DataNameOldNewVersionAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_data_name_old_new_version()) {
      set_serialised_data_name_old_new_version(from.serialised_data_name_old_new_version());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNameOldNewVersionAndReturnCode::CopyFrom(const DataNameOldNewVersionAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameOldNewVersionAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameOldNewVersionAndReturnCode::Swap(DataNameOldNewVersionAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_data_name_old_new_version_, other->serialised_data_name_old_new_version_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameOldNewVersionAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNameOldNewVersionAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataAndReturnCode::kSerialisedDataNameAndContentFieldNumber;
const int DataAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataAndReturnCode::DataAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataAndReturnCode::InitAsDefaultInstance() {
}

DataAndReturnCode::DataAndReturnCode(const DataAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_data_name_and_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataAndReturnCode::~DataAndReturnCode() {
  SharedDtor();
}

void DataAndReturnCode::SharedDtor() {
  if (serialised_data_name_and_content_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_and_content_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataAndReturnCode& DataAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataAndReturnCode* DataAndReturnCode::default_instance_ = NULL;

DataAndReturnCode* DataAndReturnCode::New() const {
  return new DataAndReturnCode;
}

void DataAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_data_name_and_content()) {
      if (serialised_data_name_and_content_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_and_content_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_data_name_and_content = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name_and_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_data_name_and_content = 1;
  if (has_serialised_data_name_and_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_data_name_and_content(), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int DataAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_data_name_and_content = 1;
    if (has_serialised_data_name_and_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name_and_content());
    }

    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataAndReturnCode*>(&from));
}

void DataAndReturnCode::MergeFrom(const DataAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_data_name_and_content()) {
      set_serialised_data_name_and_content(from.serialised_data_name_and_content());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataAndReturnCode::CopyFrom(const DataAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataAndReturnCode::Swap(DataAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_data_name_and_content_, other->serialised_data_name_and_content_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndContentOrReturnCode::kSerialisedNameFieldNumber;
const int DataNameAndContentOrReturnCode::kContentFieldNumber;
const int DataNameAndContentOrReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNameAndContentOrReturnCode::DataNameAndContentOrReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndContentOrReturnCode::InitAsDefaultInstance() {
}

DataNameAndContentOrReturnCode::DataNameAndContentOrReturnCode(const DataNameAndContentOrReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndContentOrReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndContentOrReturnCode::~DataNameAndContentOrReturnCode() {
  SharedDtor();
}

void DataNameAndContentOrReturnCode::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    delete content_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndContentOrReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndContentOrReturnCode& DataNameAndContentOrReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndContentOrReturnCode* DataNameAndContentOrReturnCode::default_instance_ = NULL;

DataNameAndContentOrReturnCode* DataNameAndContentOrReturnCode::New() const {
  return new DataNameAndContentOrReturnCode;
}

void DataNameAndContentOrReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyString()) {
        content_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndContentOrReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_content;
        break;
      }

      // optional bytes content = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_serialised_return_code;
        break;
      }

      // optional bytes serialised_return_code = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndContentOrReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // optional bytes content = 2;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->content(), output);
  }

  // optional bytes serialised_return_code = 3;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->serialised_return_code(), output);
  }

}

int DataNameAndContentOrReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // optional bytes content = 2;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->content());
    }

    // optional bytes serialised_return_code = 3;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndContentOrReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndContentOrReturnCode*>(&from));
}

void DataNameAndContentOrReturnCode::MergeFrom(const DataNameAndContentOrReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNameAndContentOrReturnCode::CopyFrom(const DataNameAndContentOrReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndContentOrReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DataNameAndContentOrReturnCode::Swap(DataNameAndContentOrReturnCode* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(content_, other->content_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndContentOrReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNameAndContentOrReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int StructuredDataNameAndContentOrReturnCode::kSerialisedStructuredDataFieldNumber;
const int StructuredDataNameAndContentOrReturnCode::kSerialisedDataNameAndReturnCodeFieldNumber;
#endif  // !_MSC_VER

StructuredDataNameAndContentOrReturnCode::StructuredDataNameAndContentOrReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StructuredDataNameAndContentOrReturnCode::InitAsDefaultInstance() {
}

StructuredDataNameAndContentOrReturnCode::StructuredDataNameAndContentOrReturnCode(const StructuredDataNameAndContentOrReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StructuredDataNameAndContentOrReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_structured_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_data_name_and_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StructuredDataNameAndContentOrReturnCode::~StructuredDataNameAndContentOrReturnCode() {
  SharedDtor();
}

void StructuredDataNameAndContentOrReturnCode::SharedDtor() {
  if (serialised_structured_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_structured_data_;
  }
  if (serialised_data_name_and_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_and_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StructuredDataNameAndContentOrReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StructuredDataNameAndContentOrReturnCode& StructuredDataNameAndContentOrReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

StructuredDataNameAndContentOrReturnCode* StructuredDataNameAndContentOrReturnCode::default_instance_ = NULL;

StructuredDataNameAndContentOrReturnCode* StructuredDataNameAndContentOrReturnCode::New() const {
  return new StructuredDataNameAndContentOrReturnCode;
}

void StructuredDataNameAndContentOrReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_structured_data()) {
      if (serialised_structured_data_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_structured_data_->clear();
      }
    }
    if (has_serialised_data_name_and_return_code()) {
      if (serialised_data_name_and_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_and_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StructuredDataNameAndContentOrReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes serialised_structured_data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_structured_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_data_name_and_return_code;
        break;
      }

      // optional bytes serialised_data_name_and_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_data_name_and_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name_and_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StructuredDataNameAndContentOrReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes serialised_structured_data = 1;
  if (has_serialised_structured_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_structured_data(), output);
  }

  // optional bytes serialised_data_name_and_return_code = 2;
  if (has_serialised_data_name_and_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_data_name_and_return_code(), output);
  }

}

int StructuredDataNameAndContentOrReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes serialised_structured_data = 1;
    if (has_serialised_structured_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_structured_data());
    }

    // optional bytes serialised_data_name_and_return_code = 2;
    if (has_serialised_data_name_and_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name_and_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StructuredDataNameAndContentOrReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StructuredDataNameAndContentOrReturnCode*>(&from));
}

void StructuredDataNameAndContentOrReturnCode::MergeFrom(const StructuredDataNameAndContentOrReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_structured_data()) {
      set_serialised_structured_data(from.serialised_structured_data());
    }
    if (from.has_serialised_data_name_and_return_code()) {
      set_serialised_data_name_and_return_code(from.serialised_data_name_and_return_code());
    }
  }
}

void StructuredDataNameAndContentOrReturnCode::CopyFrom(const StructuredDataNameAndContentOrReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StructuredDataNameAndContentOrReturnCode::IsInitialized() const {

  return true;
}

void StructuredDataNameAndContentOrReturnCode::Swap(StructuredDataNameAndContentOrReturnCode* other) {
  if (other != this) {
    std::swap(serialised_structured_data_, other->serialised_structured_data_);
    std::swap(serialised_data_name_and_return_code_, other->serialised_data_name_and_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StructuredDataNameAndContentOrReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.StructuredDataNameAndContentOrReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndSizeAndSpaceAndReturnCode::kSerialisedNameFieldNumber;
const int DataNameAndSizeAndSpaceAndReturnCode::kSizeFieldNumber;
const int DataNameAndSizeAndSpaceAndReturnCode::kSpaceFieldNumber;
const int DataNameAndSizeAndSpaceAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

DataNameAndSizeAndSpaceAndReturnCode::DataNameAndSizeAndSpaceAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndSizeAndSpaceAndReturnCode::InitAsDefaultInstance() {
}

DataNameAndSizeAndSpaceAndReturnCode::DataNameAndSizeAndSpaceAndReturnCode(const DataNameAndSizeAndSpaceAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndSizeAndSpaceAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  size_ = GOOGLE_ULONGLONG(0);
  space_ = GOOGLE_LONGLONG(0);
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndSizeAndSpaceAndReturnCode::~DataNameAndSizeAndSpaceAndReturnCode() {
  SharedDtor();
}

void DataNameAndSizeAndSpaceAndReturnCode::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndSizeAndSpaceAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndSizeAndSpaceAndReturnCode& DataNameAndSizeAndSpaceAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndSizeAndSpaceAndReturnCode* DataNameAndSizeAndSpaceAndReturnCode::default_instance_ = NULL;

DataNameAndSizeAndSpaceAndReturnCode* DataNameAndSizeAndSpaceAndReturnCode::New() const {
  return new DataNameAndSizeAndSpaceAndReturnCode;
}

void DataNameAndSizeAndSpaceAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    size_ = GOOGLE_ULONGLONG(0);
    space_ = GOOGLE_LONGLONG(0);
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndSizeAndSpaceAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }

      // required uint64 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_space;
        break;
      }

      // required int64 space = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_space:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &space_)));
          set_has_space();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndSizeAndSpaceAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required uint64 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->size(), output);
  }

  // required int64 space = 3;
  if (has_space()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->space(), output);
  }

  // required bytes serialised_return_code = 4;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->serialised_return_code(), output);
  }

}

int DataNameAndSizeAndSpaceAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required uint64 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

    // required int64 space = 3;
    if (has_space()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->space());
    }

    // required bytes serialised_return_code = 4;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndSizeAndSpaceAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndSizeAndSpaceAndReturnCode*>(&from));
}

void DataNameAndSizeAndSpaceAndReturnCode::MergeFrom(const DataNameAndSizeAndSpaceAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_space()) {
      set_space(from.space());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void DataNameAndSizeAndSpaceAndReturnCode::CopyFrom(const DataNameAndSizeAndSpaceAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndSizeAndSpaceAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void DataNameAndSizeAndSpaceAndReturnCode::Swap(DataNameAndSizeAndSpaceAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(size_, other->size_);
    std::swap(space_, other->space_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndSizeAndSpaceAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.DataNameAndSizeAndSpaceAndReturnCode";
}


// ===================================================================

#ifndef _MSC_VER
const int TipOfTreeAndReturnCode::kSerialisedTipOfTreeFieldNumber;
const int TipOfTreeAndReturnCode::kSerialisedReturnCodeFieldNumber;
#endif  // !_MSC_VER

TipOfTreeAndReturnCode::TipOfTreeAndReturnCode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TipOfTreeAndReturnCode::InitAsDefaultInstance() {
}

TipOfTreeAndReturnCode::TipOfTreeAndReturnCode(const TipOfTreeAndReturnCode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TipOfTreeAndReturnCode::SharedCtor() {
  _cached_size_ = 0;
  serialised_tip_of_tree_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TipOfTreeAndReturnCode::~TipOfTreeAndReturnCode() {
  SharedDtor();
}

void TipOfTreeAndReturnCode::SharedDtor() {
  if (serialised_tip_of_tree_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_tip_of_tree_;
  }
  if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_return_code_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TipOfTreeAndReturnCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TipOfTreeAndReturnCode& TipOfTreeAndReturnCode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fclient_2fmessages_2eproto();
#endif
  return *default_instance_;
}

TipOfTreeAndReturnCode* TipOfTreeAndReturnCode::default_instance_ = NULL;

TipOfTreeAndReturnCode* TipOfTreeAndReturnCode::New() const {
  return new TipOfTreeAndReturnCode;
}

void TipOfTreeAndReturnCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_tip_of_tree()) {
      if (serialised_tip_of_tree_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_tip_of_tree_->clear();
      }
    }
    if (has_serialised_return_code()) {
      if (serialised_return_code_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_return_code_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TipOfTreeAndReturnCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes serialised_tip_of_tree = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_tip_of_tree()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_return_code;
        break;
      }

      // required bytes serialised_return_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_return_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_return_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TipOfTreeAndReturnCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes serialised_tip_of_tree = 1;
  if (has_serialised_tip_of_tree()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_tip_of_tree(), output);
  }

  // required bytes serialised_return_code = 2;
  if (has_serialised_return_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_return_code(), output);
  }

}

int TipOfTreeAndReturnCode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes serialised_tip_of_tree = 1;
    if (has_serialised_tip_of_tree()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_tip_of_tree());
    }

    // required bytes serialised_return_code = 2;
    if (has_serialised_return_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_return_code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TipOfTreeAndReturnCode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TipOfTreeAndReturnCode*>(&from));
}

void TipOfTreeAndReturnCode::MergeFrom(const TipOfTreeAndReturnCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_tip_of_tree()) {
      set_serialised_tip_of_tree(from.serialised_tip_of_tree());
    }
    if (from.has_serialised_return_code()) {
      set_serialised_return_code(from.serialised_return_code());
    }
  }
}

void TipOfTreeAndReturnCode::CopyFrom(const TipOfTreeAndReturnCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TipOfTreeAndReturnCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void TipOfTreeAndReturnCode::Swap(TipOfTreeAndReturnCode* other) {
  if (other != this) {
    std::swap(serialised_tip_of_tree_, other->serialised_tip_of_tree_);
    std::swap(serialised_return_code_, other->serialised_return_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TipOfTreeAndReturnCode::GetTypeName() const {
  return "maidsafe.nfs_client.protobuf.TipOfTreeAndReturnCode";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace nfs_client
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)
