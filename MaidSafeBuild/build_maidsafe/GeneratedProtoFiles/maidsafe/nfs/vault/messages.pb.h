// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/nfs/vault/messages.proto

#ifndef PROTOBUF_maidsafe_2fnfs_2fvault_2fmessages_2eproto__INCLUDED
#define PROTOBUF_maidsafe_2fnfs_2fvault_2fmessages_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace nfs_vault {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

class AvailableSize;
class DiffSize;
class DataName;
class DataNames;
class DataNameAndVersion;
class DataNameOldNewVersion;
class VersionTreeCreation;
class DataNameAndContent;
class DataNameAndRandomString;
class DataNameAndCost;
class DataNameAndSize;
class DataNameAndContentOrCheckResult;
class PmidHealth;

// ===================================================================

class AvailableSize : public ::google::protobuf::MessageLite {
 public:
  AvailableSize();
  virtual ~AvailableSize();

  AvailableSize(const AvailableSize& from);

  inline AvailableSize& operator=(const AvailableSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const AvailableSize& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AvailableSize* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AvailableSize* other);

  // implements Message ----------------------------------------------

  AvailableSize* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AvailableSize& from);
  void MergeFrom(const AvailableSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.AvailableSize)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::uint64 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static AvailableSize* default_instance_;
};
// -------------------------------------------------------------------

class DiffSize : public ::google::protobuf::MessageLite {
 public:
  DiffSize();
  virtual ~DiffSize();

  DiffSize(const DiffSize& from);

  inline DiffSize& operator=(const DiffSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const DiffSize& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DiffSize* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DiffSize* other);

  // implements Message ----------------------------------------------

  DiffSize* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DiffSize& from);
  void MergeFrom(const DiffSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int64 size() const;
  inline void set_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DiffSize)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::int64 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DiffSize* default_instance_;
};
// -------------------------------------------------------------------

class DataName : public ::google::protobuf::MessageLite {
 public:
  DataName();
  virtual ~DataName();

  DataName(const DataName& from);

  inline DataName& operator=(const DataName& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataName& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataName* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataName* other);

  // implements Message ----------------------------------------------

  DataName* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataName& from);
  void MergeFrom(const DataName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required bytes raw_name = 2;
  inline bool has_raw_name() const;
  inline void clear_raw_name();
  static const int kRawNameFieldNumber = 2;
  inline const ::std::string& raw_name() const;
  inline void set_raw_name(const ::std::string& value);
  inline void set_raw_name(const char* value);
  inline void set_raw_name(const void* value, size_t size);
  inline ::std::string* mutable_raw_name();
  inline ::std::string* release_raw_name();
  inline void set_allocated_raw_name(::std::string* raw_name);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataName)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_raw_name();
  inline void clear_has_raw_name();

  ::std::string* raw_name_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataName* default_instance_;
};
// -------------------------------------------------------------------

class DataNames : public ::google::protobuf::MessageLite {
 public:
  DataNames();
  virtual ~DataNames();

  DataNames(const DataNames& from);

  inline DataNames& operator=(const DataNames& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNames& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNames* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNames* other);

  // implements Message ----------------------------------------------

  DataNames* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNames& from);
  void MergeFrom(const DataNames& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .maidsafe.nfs_vault.protobuf.DataName data_names = 1;
  inline int data_names_size() const;
  inline void clear_data_names();
  static const int kDataNamesFieldNumber = 1;
  inline const ::maidsafe::nfs_vault::protobuf::DataName& data_names(int index) const;
  inline ::maidsafe::nfs_vault::protobuf::DataName* mutable_data_names(int index);
  inline ::maidsafe::nfs_vault::protobuf::DataName* add_data_names();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::nfs_vault::protobuf::DataName >&
      data_names() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::nfs_vault::protobuf::DataName >*
      mutable_data_names();

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNames)
 private:

  ::google::protobuf::RepeatedPtrField< ::maidsafe::nfs_vault::protobuf::DataName > data_names_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNames* default_instance_;
};
// -------------------------------------------------------------------

class DataNameAndVersion : public ::google::protobuf::MessageLite {
 public:
  DataNameAndVersion();
  virtual ~DataNameAndVersion();

  DataNameAndVersion(const DataNameAndVersion& from);

  inline DataNameAndVersion& operator=(const DataNameAndVersion& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameAndVersion& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameAndVersion* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameAndVersion* other);

  // implements Message ----------------------------------------------

  DataNameAndVersion* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameAndVersion& from);
  void MergeFrom(const DataNameAndVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_data_name = 1;
  inline bool has_serialised_data_name() const;
  inline void clear_serialised_data_name();
  static const int kSerialisedDataNameFieldNumber = 1;
  inline const ::std::string& serialised_data_name() const;
  inline void set_serialised_data_name(const ::std::string& value);
  inline void set_serialised_data_name(const char* value);
  inline void set_serialised_data_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_data_name();
  inline ::std::string* release_serialised_data_name();
  inline void set_allocated_serialised_data_name(::std::string* serialised_data_name);

  // required bytes serialised_version_name = 2;
  inline bool has_serialised_version_name() const;
  inline void clear_serialised_version_name();
  static const int kSerialisedVersionNameFieldNumber = 2;
  inline const ::std::string& serialised_version_name() const;
  inline void set_serialised_version_name(const ::std::string& value);
  inline void set_serialised_version_name(const char* value);
  inline void set_serialised_version_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_version_name();
  inline ::std::string* release_serialised_version_name();
  inline void set_allocated_serialised_version_name(::std::string* serialised_version_name);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameAndVersion)
 private:
  inline void set_has_serialised_data_name();
  inline void clear_has_serialised_data_name();
  inline void set_has_serialised_version_name();
  inline void clear_has_serialised_version_name();

  ::std::string* serialised_data_name_;
  ::std::string* serialised_version_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameAndVersion* default_instance_;
};
// -------------------------------------------------------------------

class DataNameOldNewVersion : public ::google::protobuf::MessageLite {
 public:
  DataNameOldNewVersion();
  virtual ~DataNameOldNewVersion();

  DataNameOldNewVersion(const DataNameOldNewVersion& from);

  inline DataNameOldNewVersion& operator=(const DataNameOldNewVersion& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameOldNewVersion& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameOldNewVersion* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameOldNewVersion* other);

  // implements Message ----------------------------------------------

  DataNameOldNewVersion* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameOldNewVersion& from);
  void MergeFrom(const DataNameOldNewVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_data_name = 1;
  inline bool has_serialised_data_name() const;
  inline void clear_serialised_data_name();
  static const int kSerialisedDataNameFieldNumber = 1;
  inline const ::std::string& serialised_data_name() const;
  inline void set_serialised_data_name(const ::std::string& value);
  inline void set_serialised_data_name(const char* value);
  inline void set_serialised_data_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_data_name();
  inline ::std::string* release_serialised_data_name();
  inline void set_allocated_serialised_data_name(::std::string* serialised_data_name);

  // optional bytes serialised_old_version_name = 2;
  inline bool has_serialised_old_version_name() const;
  inline void clear_serialised_old_version_name();
  static const int kSerialisedOldVersionNameFieldNumber = 2;
  inline const ::std::string& serialised_old_version_name() const;
  inline void set_serialised_old_version_name(const ::std::string& value);
  inline void set_serialised_old_version_name(const char* value);
  inline void set_serialised_old_version_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_old_version_name();
  inline ::std::string* release_serialised_old_version_name();
  inline void set_allocated_serialised_old_version_name(::std::string* serialised_old_version_name);

  // required bytes serialised_new_version_name = 3;
  inline bool has_serialised_new_version_name() const;
  inline void clear_serialised_new_version_name();
  static const int kSerialisedNewVersionNameFieldNumber = 3;
  inline const ::std::string& serialised_new_version_name() const;
  inline void set_serialised_new_version_name(const ::std::string& value);
  inline void set_serialised_new_version_name(const char* value);
  inline void set_serialised_new_version_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_new_version_name();
  inline ::std::string* release_serialised_new_version_name();
  inline void set_allocated_serialised_new_version_name(::std::string* serialised_new_version_name);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameOldNewVersion)
 private:
  inline void set_has_serialised_data_name();
  inline void clear_has_serialised_data_name();
  inline void set_has_serialised_old_version_name();
  inline void clear_has_serialised_old_version_name();
  inline void set_has_serialised_new_version_name();
  inline void clear_has_serialised_new_version_name();

  ::std::string* serialised_data_name_;
  ::std::string* serialised_old_version_name_;
  ::std::string* serialised_new_version_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameOldNewVersion* default_instance_;
};
// -------------------------------------------------------------------

class VersionTreeCreation : public ::google::protobuf::MessageLite {
 public:
  VersionTreeCreation();
  virtual ~VersionTreeCreation();

  VersionTreeCreation(const VersionTreeCreation& from);

  inline VersionTreeCreation& operator=(const VersionTreeCreation& from) {
    CopyFrom(from);
    return *this;
  }

  static const VersionTreeCreation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VersionTreeCreation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VersionTreeCreation* other);

  // implements Message ----------------------------------------------

  VersionTreeCreation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VersionTreeCreation& from);
  void MergeFrom(const VersionTreeCreation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_data_name = 1;
  inline bool has_serialised_data_name() const;
  inline void clear_serialised_data_name();
  static const int kSerialisedDataNameFieldNumber = 1;
  inline const ::std::string& serialised_data_name() const;
  inline void set_serialised_data_name(const ::std::string& value);
  inline void set_serialised_data_name(const char* value);
  inline void set_serialised_data_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_data_name();
  inline ::std::string* release_serialised_data_name();
  inline void set_allocated_serialised_data_name(::std::string* serialised_data_name);

  // required bytes serialised_version_name = 2;
  inline bool has_serialised_version_name() const;
  inline void clear_serialised_version_name();
  static const int kSerialisedVersionNameFieldNumber = 2;
  inline const ::std::string& serialised_version_name() const;
  inline void set_serialised_version_name(const ::std::string& value);
  inline void set_serialised_version_name(const char* value);
  inline void set_serialised_version_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_version_name();
  inline ::std::string* release_serialised_version_name();
  inline void set_allocated_serialised_version_name(::std::string* serialised_version_name);

  // required int32 max_versions = 3;
  inline bool has_max_versions() const;
  inline void clear_max_versions();
  static const int kMaxVersionsFieldNumber = 3;
  inline ::google::protobuf::int32 max_versions() const;
  inline void set_max_versions(::google::protobuf::int32 value);

  // required int32 max_branches = 4;
  inline bool has_max_branches() const;
  inline void clear_max_branches();
  static const int kMaxBranchesFieldNumber = 4;
  inline ::google::protobuf::int32 max_branches() const;
  inline void set_max_branches(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.VersionTreeCreation)
 private:
  inline void set_has_serialised_data_name();
  inline void clear_has_serialised_data_name();
  inline void set_has_serialised_version_name();
  inline void clear_has_serialised_version_name();
  inline void set_has_max_versions();
  inline void clear_has_max_versions();
  inline void set_has_max_branches();
  inline void clear_has_max_branches();

  ::std::string* serialised_data_name_;
  ::std::string* serialised_version_name_;
  ::google::protobuf::int32 max_versions_;
  ::google::protobuf::int32 max_branches_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static VersionTreeCreation* default_instance_;
};
// -------------------------------------------------------------------

class DataNameAndContent : public ::google::protobuf::MessageLite {
 public:
  DataNameAndContent();
  virtual ~DataNameAndContent();

  DataNameAndContent(const DataNameAndContent& from);

  inline DataNameAndContent& operator=(const DataNameAndContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameAndContent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameAndContent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameAndContent* other);

  // implements Message ----------------------------------------------

  DataNameAndContent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameAndContent& from);
  void MergeFrom(const DataNameAndContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_name = 1;
  inline bool has_serialised_name() const;
  inline void clear_serialised_name();
  static const int kSerialisedNameFieldNumber = 1;
  inline const ::std::string& serialised_name() const;
  inline void set_serialised_name(const ::std::string& value);
  inline void set_serialised_name(const char* value);
  inline void set_serialised_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_name();
  inline ::std::string* release_serialised_name();
  inline void set_allocated_serialised_name(::std::string* serialised_name);

  // required bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameAndContent)
 private:
  inline void set_has_serialised_name();
  inline void clear_has_serialised_name();
  inline void set_has_content();
  inline void clear_has_content();

  ::std::string* serialised_name_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameAndContent* default_instance_;
};
// -------------------------------------------------------------------

class DataNameAndRandomString : public ::google::protobuf::MessageLite {
 public:
  DataNameAndRandomString();
  virtual ~DataNameAndRandomString();

  DataNameAndRandomString(const DataNameAndRandomString& from);

  inline DataNameAndRandomString& operator=(const DataNameAndRandomString& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameAndRandomString& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameAndRandomString* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameAndRandomString* other);

  // implements Message ----------------------------------------------

  DataNameAndRandomString* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameAndRandomString& from);
  void MergeFrom(const DataNameAndRandomString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_name = 1;
  inline bool has_serialised_name() const;
  inline void clear_serialised_name();
  static const int kSerialisedNameFieldNumber = 1;
  inline const ::std::string& serialised_name() const;
  inline void set_serialised_name(const ::std::string& value);
  inline void set_serialised_name(const char* value);
  inline void set_serialised_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_name();
  inline ::std::string* release_serialised_name();
  inline void set_allocated_serialised_name(::std::string* serialised_name);

  // required bytes random_string = 2;
  inline bool has_random_string() const;
  inline void clear_random_string();
  static const int kRandomStringFieldNumber = 2;
  inline const ::std::string& random_string() const;
  inline void set_random_string(const ::std::string& value);
  inline void set_random_string(const char* value);
  inline void set_random_string(const void* value, size_t size);
  inline ::std::string* mutable_random_string();
  inline ::std::string* release_random_string();
  inline void set_allocated_random_string(::std::string* random_string);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameAndRandomString)
 private:
  inline void set_has_serialised_name();
  inline void clear_has_serialised_name();
  inline void set_has_random_string();
  inline void clear_has_random_string();

  ::std::string* serialised_name_;
  ::std::string* random_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameAndRandomString* default_instance_;
};
// -------------------------------------------------------------------

class DataNameAndCost : public ::google::protobuf::MessageLite {
 public:
  DataNameAndCost();
  virtual ~DataNameAndCost();

  DataNameAndCost(const DataNameAndCost& from);

  inline DataNameAndCost& operator=(const DataNameAndCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameAndCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameAndCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameAndCost* other);

  // implements Message ----------------------------------------------

  DataNameAndCost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameAndCost& from);
  void MergeFrom(const DataNameAndCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_name = 1;
  inline bool has_serialised_name() const;
  inline void clear_serialised_name();
  static const int kSerialisedNameFieldNumber = 1;
  inline const ::std::string& serialised_name() const;
  inline void set_serialised_name(const ::std::string& value);
  inline void set_serialised_name(const char* value);
  inline void set_serialised_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_name();
  inline ::std::string* release_serialised_name();
  inline void set_allocated_serialised_name(::std::string* serialised_name);

  // required int32 cost = 2;
  inline bool has_cost() const;
  inline void clear_cost();
  static const int kCostFieldNumber = 2;
  inline ::google::protobuf::int32 cost() const;
  inline void set_cost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameAndCost)
 private:
  inline void set_has_serialised_name();
  inline void clear_has_serialised_name();
  inline void set_has_cost();
  inline void clear_has_cost();

  ::std::string* serialised_name_;
  ::google::protobuf::int32 cost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameAndCost* default_instance_;
};
// -------------------------------------------------------------------

class DataNameAndSize : public ::google::protobuf::MessageLite {
 public:
  DataNameAndSize();
  virtual ~DataNameAndSize();

  DataNameAndSize(const DataNameAndSize& from);

  inline DataNameAndSize& operator=(const DataNameAndSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameAndSize& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameAndSize* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameAndSize* other);

  // implements Message ----------------------------------------------

  DataNameAndSize* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameAndSize& from);
  void MergeFrom(const DataNameAndSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_name = 1;
  inline bool has_serialised_name() const;
  inline void clear_serialised_name();
  static const int kSerialisedNameFieldNumber = 1;
  inline const ::std::string& serialised_name() const;
  inline void set_serialised_name(const ::std::string& value);
  inline void set_serialised_name(const char* value);
  inline void set_serialised_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_name();
  inline ::std::string* release_serialised_name();
  inline void set_allocated_serialised_name(::std::string* serialised_name);

  // required int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameAndSize)
 private:
  inline void set_has_serialised_name();
  inline void clear_has_serialised_name();
  inline void set_has_size();
  inline void clear_has_size();

  ::std::string* serialised_name_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameAndSize* default_instance_;
};
// -------------------------------------------------------------------

class DataNameAndContentOrCheckResult : public ::google::protobuf::MessageLite {
 public:
  DataNameAndContentOrCheckResult();
  virtual ~DataNameAndContentOrCheckResult();

  DataNameAndContentOrCheckResult(const DataNameAndContentOrCheckResult& from);

  inline DataNameAndContentOrCheckResult& operator=(const DataNameAndContentOrCheckResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const DataNameAndContentOrCheckResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataNameAndContentOrCheckResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataNameAndContentOrCheckResult* other);

  // implements Message ----------------------------------------------

  DataNameAndContentOrCheckResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataNameAndContentOrCheckResult& from);
  void MergeFrom(const DataNameAndContentOrCheckResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_name = 1;
  inline bool has_serialised_name() const;
  inline void clear_serialised_name();
  static const int kSerialisedNameFieldNumber = 1;
  inline const ::std::string& serialised_name() const;
  inline void set_serialised_name(const ::std::string& value);
  inline void set_serialised_name(const char* value);
  inline void set_serialised_name(const void* value, size_t size);
  inline ::std::string* mutable_serialised_name();
  inline ::std::string* release_serialised_name();
  inline void set_allocated_serialised_name(::std::string* serialised_name);

  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional bytes check_result = 3;
  inline bool has_check_result() const;
  inline void clear_check_result();
  static const int kCheckResultFieldNumber = 3;
  inline const ::std::string& check_result() const;
  inline void set_check_result(const ::std::string& value);
  inline void set_check_result(const char* value);
  inline void set_check_result(const void* value, size_t size);
  inline ::std::string* mutable_check_result();
  inline ::std::string* release_check_result();
  inline void set_allocated_check_result(::std::string* check_result);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.DataNameAndContentOrCheckResult)
 private:
  inline void set_has_serialised_name();
  inline void clear_has_serialised_name();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_check_result();
  inline void clear_has_check_result();

  ::std::string* serialised_name_;
  ::std::string* content_;
  ::std::string* check_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static DataNameAndContentOrCheckResult* default_instance_;
};
// -------------------------------------------------------------------

class PmidHealth : public ::google::protobuf::MessageLite {
 public:
  PmidHealth();
  virtual ~PmidHealth();

  PmidHealth(const PmidHealth& from);

  inline PmidHealth& operator=(const PmidHealth& from) {
    CopyFrom(from);
    return *this;
  }

  static const PmidHealth& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PmidHealth* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PmidHealth* other);

  // implements Message ----------------------------------------------

  PmidHealth* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PmidHealth& from);
  void MergeFrom(const PmidHealth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialised_pmid_health = 1;
  inline bool has_serialised_pmid_health() const;
  inline void clear_serialised_pmid_health();
  static const int kSerialisedPmidHealthFieldNumber = 1;
  inline const ::std::string& serialised_pmid_health() const;
  inline void set_serialised_pmid_health(const ::std::string& value);
  inline void set_serialised_pmid_health(const char* value);
  inline void set_serialised_pmid_health(const void* value, size_t size);
  inline ::std::string* mutable_serialised_pmid_health();
  inline ::std::string* release_serialised_pmid_health();
  inline void set_allocated_serialised_pmid_health(::std::string* serialised_pmid_health);

  // @@protoc_insertion_point(class_scope:maidsafe.nfs_vault.protobuf.PmidHealth)
 private:
  inline void set_has_serialised_pmid_health();
  inline void clear_has_serialised_pmid_health();

  ::std::string* serialised_pmid_health_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto();

  void InitAsDefaultInstance();
  static PmidHealth* default_instance_;
};
// ===================================================================


// ===================================================================

// AvailableSize

// required uint64 size = 1;
inline bool AvailableSize::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AvailableSize::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AvailableSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AvailableSize::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 AvailableSize::size() const {
  return size_;
}
inline void AvailableSize::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// DiffSize

// required int64 size = 1;
inline bool DiffSize::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiffSize::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiffSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiffSize::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::int64 DiffSize::size() const {
  return size_;
}
inline void DiffSize::set_size(::google::protobuf::int64 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// DataName

// required uint32 type = 1;
inline bool DataName::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataName::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataName::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataName::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 DataName::type() const {
  return type_;
}
inline void DataName::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required bytes raw_name = 2;
inline bool DataName::has_raw_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataName::set_has_raw_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataName::clear_has_raw_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataName::clear_raw_name() {
  if (raw_name_ != &::google::protobuf::internal::GetEmptyString()) {
    raw_name_->clear();
  }
  clear_has_raw_name();
}
inline const ::std::string& DataName::raw_name() const {
  return *raw_name_;
}
inline void DataName::set_raw_name(const ::std::string& value) {
  set_has_raw_name();
  if (raw_name_ == &::google::protobuf::internal::GetEmptyString()) {
    raw_name_ = new ::std::string;
  }
  raw_name_->assign(value);
}
inline void DataName::set_raw_name(const char* value) {
  set_has_raw_name();
  if (raw_name_ == &::google::protobuf::internal::GetEmptyString()) {
    raw_name_ = new ::std::string;
  }
  raw_name_->assign(value);
}
inline void DataName::set_raw_name(const void* value, size_t size) {
  set_has_raw_name();
  if (raw_name_ == &::google::protobuf::internal::GetEmptyString()) {
    raw_name_ = new ::std::string;
  }
  raw_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataName::mutable_raw_name() {
  set_has_raw_name();
  if (raw_name_ == &::google::protobuf::internal::GetEmptyString()) {
    raw_name_ = new ::std::string;
  }
  return raw_name_;
}
inline ::std::string* DataName::release_raw_name() {
  clear_has_raw_name();
  if (raw_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = raw_name_;
    raw_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataName::set_allocated_raw_name(::std::string* raw_name) {
  if (raw_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete raw_name_;
  }
  if (raw_name) {
    set_has_raw_name();
    raw_name_ = raw_name;
  } else {
    clear_has_raw_name();
    raw_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// DataNames

// repeated .maidsafe.nfs_vault.protobuf.DataName data_names = 1;
inline int DataNames::data_names_size() const {
  return data_names_.size();
}
inline void DataNames::clear_data_names() {
  data_names_.Clear();
}
inline const ::maidsafe::nfs_vault::protobuf::DataName& DataNames::data_names(int index) const {
  return data_names_.Get(index);
}
inline ::maidsafe::nfs_vault::protobuf::DataName* DataNames::mutable_data_names(int index) {
  return data_names_.Mutable(index);
}
inline ::maidsafe::nfs_vault::protobuf::DataName* DataNames::add_data_names() {
  return data_names_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::nfs_vault::protobuf::DataName >&
DataNames::data_names() const {
  return data_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::nfs_vault::protobuf::DataName >*
DataNames::mutable_data_names() {
  return &data_names_;
}

// -------------------------------------------------------------------

// DataNameAndVersion

// required bytes serialised_data_name = 1;
inline bool DataNameAndVersion::has_serialised_data_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameAndVersion::set_has_serialised_data_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameAndVersion::clear_has_serialised_data_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameAndVersion::clear_serialised_data_name() {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_->clear();
  }
  clear_has_serialised_data_name();
}
inline const ::std::string& DataNameAndVersion::serialised_data_name() const {
  return *serialised_data_name_;
}
inline void DataNameAndVersion::set_serialised_data_name(const ::std::string& value) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(value);
}
inline void DataNameAndVersion::set_serialised_data_name(const char* value) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(value);
}
inline void DataNameAndVersion::set_serialised_data_name(const void* value, size_t size) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndVersion::mutable_serialised_data_name() {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  return serialised_data_name_;
}
inline ::std::string* DataNameAndVersion::release_serialised_data_name() {
  clear_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_data_name_;
    serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndVersion::set_allocated_serialised_data_name(::std::string* serialised_data_name) {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_;
  }
  if (serialised_data_name) {
    set_has_serialised_data_name();
    serialised_data_name_ = serialised_data_name;
  } else {
    clear_has_serialised_data_name();
    serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes serialised_version_name = 2;
inline bool DataNameAndVersion::has_serialised_version_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameAndVersion::set_has_serialised_version_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameAndVersion::clear_has_serialised_version_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameAndVersion::clear_serialised_version_name() {
  if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_->clear();
  }
  clear_has_serialised_version_name();
}
inline const ::std::string& DataNameAndVersion::serialised_version_name() const {
  return *serialised_version_name_;
}
inline void DataNameAndVersion::set_serialised_version_name(const ::std::string& value) {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  serialised_version_name_->assign(value);
}
inline void DataNameAndVersion::set_serialised_version_name(const char* value) {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  serialised_version_name_->assign(value);
}
inline void DataNameAndVersion::set_serialised_version_name(const void* value, size_t size) {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  serialised_version_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndVersion::mutable_serialised_version_name() {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  return serialised_version_name_;
}
inline ::std::string* DataNameAndVersion::release_serialised_version_name() {
  clear_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_version_name_;
    serialised_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndVersion::set_allocated_serialised_version_name(::std::string* serialised_version_name) {
  if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_version_name_;
  }
  if (serialised_version_name) {
    set_has_serialised_version_name();
    serialised_version_name_ = serialised_version_name;
  } else {
    clear_has_serialised_version_name();
    serialised_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// DataNameOldNewVersion

// required bytes serialised_data_name = 1;
inline bool DataNameOldNewVersion::has_serialised_data_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameOldNewVersion::set_has_serialised_data_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameOldNewVersion::clear_has_serialised_data_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameOldNewVersion::clear_serialised_data_name() {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_->clear();
  }
  clear_has_serialised_data_name();
}
inline const ::std::string& DataNameOldNewVersion::serialised_data_name() const {
  return *serialised_data_name_;
}
inline void DataNameOldNewVersion::set_serialised_data_name(const ::std::string& value) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(value);
}
inline void DataNameOldNewVersion::set_serialised_data_name(const char* value) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(value);
}
inline void DataNameOldNewVersion::set_serialised_data_name(const void* value, size_t size) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameOldNewVersion::mutable_serialised_data_name() {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  return serialised_data_name_;
}
inline ::std::string* DataNameOldNewVersion::release_serialised_data_name() {
  clear_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_data_name_;
    serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameOldNewVersion::set_allocated_serialised_data_name(::std::string* serialised_data_name) {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_;
  }
  if (serialised_data_name) {
    set_has_serialised_data_name();
    serialised_data_name_ = serialised_data_name;
  } else {
    clear_has_serialised_data_name();
    serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes serialised_old_version_name = 2;
inline bool DataNameOldNewVersion::has_serialised_old_version_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameOldNewVersion::set_has_serialised_old_version_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameOldNewVersion::clear_has_serialised_old_version_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameOldNewVersion::clear_serialised_old_version_name() {
  if (serialised_old_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_old_version_name_->clear();
  }
  clear_has_serialised_old_version_name();
}
inline const ::std::string& DataNameOldNewVersion::serialised_old_version_name() const {
  return *serialised_old_version_name_;
}
inline void DataNameOldNewVersion::set_serialised_old_version_name(const ::std::string& value) {
  set_has_serialised_old_version_name();
  if (serialised_old_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_old_version_name_ = new ::std::string;
  }
  serialised_old_version_name_->assign(value);
}
inline void DataNameOldNewVersion::set_serialised_old_version_name(const char* value) {
  set_has_serialised_old_version_name();
  if (serialised_old_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_old_version_name_ = new ::std::string;
  }
  serialised_old_version_name_->assign(value);
}
inline void DataNameOldNewVersion::set_serialised_old_version_name(const void* value, size_t size) {
  set_has_serialised_old_version_name();
  if (serialised_old_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_old_version_name_ = new ::std::string;
  }
  serialised_old_version_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameOldNewVersion::mutable_serialised_old_version_name() {
  set_has_serialised_old_version_name();
  if (serialised_old_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_old_version_name_ = new ::std::string;
  }
  return serialised_old_version_name_;
}
inline ::std::string* DataNameOldNewVersion::release_serialised_old_version_name() {
  clear_has_serialised_old_version_name();
  if (serialised_old_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_old_version_name_;
    serialised_old_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameOldNewVersion::set_allocated_serialised_old_version_name(::std::string* serialised_old_version_name) {
  if (serialised_old_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_old_version_name_;
  }
  if (serialised_old_version_name) {
    set_has_serialised_old_version_name();
    serialised_old_version_name_ = serialised_old_version_name;
  } else {
    clear_has_serialised_old_version_name();
    serialised_old_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes serialised_new_version_name = 3;
inline bool DataNameOldNewVersion::has_serialised_new_version_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataNameOldNewVersion::set_has_serialised_new_version_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataNameOldNewVersion::clear_has_serialised_new_version_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataNameOldNewVersion::clear_serialised_new_version_name() {
  if (serialised_new_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_new_version_name_->clear();
  }
  clear_has_serialised_new_version_name();
}
inline const ::std::string& DataNameOldNewVersion::serialised_new_version_name() const {
  return *serialised_new_version_name_;
}
inline void DataNameOldNewVersion::set_serialised_new_version_name(const ::std::string& value) {
  set_has_serialised_new_version_name();
  if (serialised_new_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_new_version_name_ = new ::std::string;
  }
  serialised_new_version_name_->assign(value);
}
inline void DataNameOldNewVersion::set_serialised_new_version_name(const char* value) {
  set_has_serialised_new_version_name();
  if (serialised_new_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_new_version_name_ = new ::std::string;
  }
  serialised_new_version_name_->assign(value);
}
inline void DataNameOldNewVersion::set_serialised_new_version_name(const void* value, size_t size) {
  set_has_serialised_new_version_name();
  if (serialised_new_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_new_version_name_ = new ::std::string;
  }
  serialised_new_version_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameOldNewVersion::mutable_serialised_new_version_name() {
  set_has_serialised_new_version_name();
  if (serialised_new_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_new_version_name_ = new ::std::string;
  }
  return serialised_new_version_name_;
}
inline ::std::string* DataNameOldNewVersion::release_serialised_new_version_name() {
  clear_has_serialised_new_version_name();
  if (serialised_new_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_new_version_name_;
    serialised_new_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameOldNewVersion::set_allocated_serialised_new_version_name(::std::string* serialised_new_version_name) {
  if (serialised_new_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_new_version_name_;
  }
  if (serialised_new_version_name) {
    set_has_serialised_new_version_name();
    serialised_new_version_name_ = serialised_new_version_name;
  } else {
    clear_has_serialised_new_version_name();
    serialised_new_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// VersionTreeCreation

// required bytes serialised_data_name = 1;
inline bool VersionTreeCreation::has_serialised_data_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionTreeCreation::set_has_serialised_data_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionTreeCreation::clear_has_serialised_data_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionTreeCreation::clear_serialised_data_name() {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_->clear();
  }
  clear_has_serialised_data_name();
}
inline const ::std::string& VersionTreeCreation::serialised_data_name() const {
  return *serialised_data_name_;
}
inline void VersionTreeCreation::set_serialised_data_name(const ::std::string& value) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(value);
}
inline void VersionTreeCreation::set_serialised_data_name(const char* value) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(value);
}
inline void VersionTreeCreation::set_serialised_data_name(const void* value, size_t size) {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  serialised_data_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionTreeCreation::mutable_serialised_data_name() {
  set_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_name_ = new ::std::string;
  }
  return serialised_data_name_;
}
inline ::std::string* VersionTreeCreation::release_serialised_data_name() {
  clear_has_serialised_data_name();
  if (serialised_data_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_data_name_;
    serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VersionTreeCreation::set_allocated_serialised_data_name(::std::string* serialised_data_name) {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_;
  }
  if (serialised_data_name) {
    set_has_serialised_data_name();
    serialised_data_name_ = serialised_data_name;
  } else {
    clear_has_serialised_data_name();
    serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes serialised_version_name = 2;
inline bool VersionTreeCreation::has_serialised_version_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionTreeCreation::set_has_serialised_version_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionTreeCreation::clear_has_serialised_version_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionTreeCreation::clear_serialised_version_name() {
  if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_->clear();
  }
  clear_has_serialised_version_name();
}
inline const ::std::string& VersionTreeCreation::serialised_version_name() const {
  return *serialised_version_name_;
}
inline void VersionTreeCreation::set_serialised_version_name(const ::std::string& value) {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  serialised_version_name_->assign(value);
}
inline void VersionTreeCreation::set_serialised_version_name(const char* value) {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  serialised_version_name_->assign(value);
}
inline void VersionTreeCreation::set_serialised_version_name(const void* value, size_t size) {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  serialised_version_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionTreeCreation::mutable_serialised_version_name() {
  set_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_version_name_ = new ::std::string;
  }
  return serialised_version_name_;
}
inline ::std::string* VersionTreeCreation::release_serialised_version_name() {
  clear_has_serialised_version_name();
  if (serialised_version_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_version_name_;
    serialised_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VersionTreeCreation::set_allocated_serialised_version_name(::std::string* serialised_version_name) {
  if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_version_name_;
  }
  if (serialised_version_name) {
    set_has_serialised_version_name();
    serialised_version_name_ = serialised_version_name;
  } else {
    clear_has_serialised_version_name();
    serialised_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 max_versions = 3;
inline bool VersionTreeCreation::has_max_versions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionTreeCreation::set_has_max_versions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VersionTreeCreation::clear_has_max_versions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VersionTreeCreation::clear_max_versions() {
  max_versions_ = 0;
  clear_has_max_versions();
}
inline ::google::protobuf::int32 VersionTreeCreation::max_versions() const {
  return max_versions_;
}
inline void VersionTreeCreation::set_max_versions(::google::protobuf::int32 value) {
  set_has_max_versions();
  max_versions_ = value;
}

// required int32 max_branches = 4;
inline bool VersionTreeCreation::has_max_branches() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionTreeCreation::set_has_max_branches() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VersionTreeCreation::clear_has_max_branches() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VersionTreeCreation::clear_max_branches() {
  max_branches_ = 0;
  clear_has_max_branches();
}
inline ::google::protobuf::int32 VersionTreeCreation::max_branches() const {
  return max_branches_;
}
inline void VersionTreeCreation::set_max_branches(::google::protobuf::int32 value) {
  set_has_max_branches();
  max_branches_ = value;
}

// -------------------------------------------------------------------

// DataNameAndContent

// required bytes serialised_name = 1;
inline bool DataNameAndContent::has_serialised_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameAndContent::set_has_serialised_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameAndContent::clear_has_serialised_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameAndContent::clear_serialised_name() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_->clear();
  }
  clear_has_serialised_name();
}
inline const ::std::string& DataNameAndContent::serialised_name() const {
  return *serialised_name_;
}
inline void DataNameAndContent::set_serialised_name(const ::std::string& value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndContent::set_serialised_name(const char* value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndContent::set_serialised_name(const void* value, size_t size) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndContent::mutable_serialised_name() {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  return serialised_name_;
}
inline ::std::string* DataNameAndContent::release_serialised_name() {
  clear_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_name_;
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndContent::set_allocated_serialised_name(::std::string* serialised_name) {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_name) {
    set_has_serialised_name();
    serialised_name_ = serialised_name;
  } else {
    clear_has_serialised_name();
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes content = 2;
inline bool DataNameAndContent::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameAndContent::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameAndContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameAndContent::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& DataNameAndContent::content() const {
  return *content_;
}
inline void DataNameAndContent::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void DataNameAndContent::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void DataNameAndContent::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndContent::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* DataNameAndContent::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndContent::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// DataNameAndRandomString

// required bytes serialised_name = 1;
inline bool DataNameAndRandomString::has_serialised_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameAndRandomString::set_has_serialised_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameAndRandomString::clear_has_serialised_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameAndRandomString::clear_serialised_name() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_->clear();
  }
  clear_has_serialised_name();
}
inline const ::std::string& DataNameAndRandomString::serialised_name() const {
  return *serialised_name_;
}
inline void DataNameAndRandomString::set_serialised_name(const ::std::string& value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndRandomString::set_serialised_name(const char* value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndRandomString::set_serialised_name(const void* value, size_t size) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndRandomString::mutable_serialised_name() {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  return serialised_name_;
}
inline ::std::string* DataNameAndRandomString::release_serialised_name() {
  clear_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_name_;
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndRandomString::set_allocated_serialised_name(::std::string* serialised_name) {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_name) {
    set_has_serialised_name();
    serialised_name_ = serialised_name;
  } else {
    clear_has_serialised_name();
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes random_string = 2;
inline bool DataNameAndRandomString::has_random_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameAndRandomString::set_has_random_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameAndRandomString::clear_has_random_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameAndRandomString::clear_random_string() {
  if (random_string_ != &::google::protobuf::internal::GetEmptyString()) {
    random_string_->clear();
  }
  clear_has_random_string();
}
inline const ::std::string& DataNameAndRandomString::random_string() const {
  return *random_string_;
}
inline void DataNameAndRandomString::set_random_string(const ::std::string& value) {
  set_has_random_string();
  if (random_string_ == &::google::protobuf::internal::GetEmptyString()) {
    random_string_ = new ::std::string;
  }
  random_string_->assign(value);
}
inline void DataNameAndRandomString::set_random_string(const char* value) {
  set_has_random_string();
  if (random_string_ == &::google::protobuf::internal::GetEmptyString()) {
    random_string_ = new ::std::string;
  }
  random_string_->assign(value);
}
inline void DataNameAndRandomString::set_random_string(const void* value, size_t size) {
  set_has_random_string();
  if (random_string_ == &::google::protobuf::internal::GetEmptyString()) {
    random_string_ = new ::std::string;
  }
  random_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndRandomString::mutable_random_string() {
  set_has_random_string();
  if (random_string_ == &::google::protobuf::internal::GetEmptyString()) {
    random_string_ = new ::std::string;
  }
  return random_string_;
}
inline ::std::string* DataNameAndRandomString::release_random_string() {
  clear_has_random_string();
  if (random_string_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = random_string_;
    random_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndRandomString::set_allocated_random_string(::std::string* random_string) {
  if (random_string_ != &::google::protobuf::internal::GetEmptyString()) {
    delete random_string_;
  }
  if (random_string) {
    set_has_random_string();
    random_string_ = random_string;
  } else {
    clear_has_random_string();
    random_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// DataNameAndCost

// required bytes serialised_name = 1;
inline bool DataNameAndCost::has_serialised_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameAndCost::set_has_serialised_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameAndCost::clear_has_serialised_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameAndCost::clear_serialised_name() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_->clear();
  }
  clear_has_serialised_name();
}
inline const ::std::string& DataNameAndCost::serialised_name() const {
  return *serialised_name_;
}
inline void DataNameAndCost::set_serialised_name(const ::std::string& value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndCost::set_serialised_name(const char* value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndCost::set_serialised_name(const void* value, size_t size) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndCost::mutable_serialised_name() {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  return serialised_name_;
}
inline ::std::string* DataNameAndCost::release_serialised_name() {
  clear_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_name_;
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndCost::set_allocated_serialised_name(::std::string* serialised_name) {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_name) {
    set_has_serialised_name();
    serialised_name_ = serialised_name;
  } else {
    clear_has_serialised_name();
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 cost = 2;
inline bool DataNameAndCost::has_cost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameAndCost::set_has_cost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameAndCost::clear_has_cost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameAndCost::clear_cost() {
  cost_ = 0;
  clear_has_cost();
}
inline ::google::protobuf::int32 DataNameAndCost::cost() const {
  return cost_;
}
inline void DataNameAndCost::set_cost(::google::protobuf::int32 value) {
  set_has_cost();
  cost_ = value;
}

// -------------------------------------------------------------------

// DataNameAndSize

// required bytes serialised_name = 1;
inline bool DataNameAndSize::has_serialised_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameAndSize::set_has_serialised_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameAndSize::clear_has_serialised_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameAndSize::clear_serialised_name() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_->clear();
  }
  clear_has_serialised_name();
}
inline const ::std::string& DataNameAndSize::serialised_name() const {
  return *serialised_name_;
}
inline void DataNameAndSize::set_serialised_name(const ::std::string& value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndSize::set_serialised_name(const char* value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndSize::set_serialised_name(const void* value, size_t size) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndSize::mutable_serialised_name() {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  return serialised_name_;
}
inline ::std::string* DataNameAndSize::release_serialised_name() {
  clear_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_name_;
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndSize::set_allocated_serialised_name(::std::string* serialised_name) {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_name) {
    set_has_serialised_name();
    serialised_name_ = serialised_name;
  } else {
    clear_has_serialised_name();
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 size = 2;
inline bool DataNameAndSize::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameAndSize::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameAndSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameAndSize::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 DataNameAndSize::size() const {
  return size_;
}
inline void DataNameAndSize::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// DataNameAndContentOrCheckResult

// required bytes serialised_name = 1;
inline bool DataNameAndContentOrCheckResult::has_serialised_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataNameAndContentOrCheckResult::set_has_serialised_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataNameAndContentOrCheckResult::clear_has_serialised_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataNameAndContentOrCheckResult::clear_serialised_name() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_->clear();
  }
  clear_has_serialised_name();
}
inline const ::std::string& DataNameAndContentOrCheckResult::serialised_name() const {
  return *serialised_name_;
}
inline void DataNameAndContentOrCheckResult::set_serialised_name(const ::std::string& value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndContentOrCheckResult::set_serialised_name(const char* value) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(value);
}
inline void DataNameAndContentOrCheckResult::set_serialised_name(const void* value, size_t size) {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  serialised_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndContentOrCheckResult::mutable_serialised_name() {
  set_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_name_ = new ::std::string;
  }
  return serialised_name_;
}
inline ::std::string* DataNameAndContentOrCheckResult::release_serialised_name() {
  clear_has_serialised_name();
  if (serialised_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_name_;
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndContentOrCheckResult::set_allocated_serialised_name(::std::string* serialised_name) {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (serialised_name) {
    set_has_serialised_name();
    serialised_name_ = serialised_name;
  } else {
    clear_has_serialised_name();
    serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes content = 2;
inline bool DataNameAndContentOrCheckResult::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataNameAndContentOrCheckResult::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataNameAndContentOrCheckResult::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataNameAndContentOrCheckResult::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& DataNameAndContentOrCheckResult::content() const {
  return *content_;
}
inline void DataNameAndContentOrCheckResult::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void DataNameAndContentOrCheckResult::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void DataNameAndContentOrCheckResult::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndContentOrCheckResult::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* DataNameAndContentOrCheckResult::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndContentOrCheckResult::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes check_result = 3;
inline bool DataNameAndContentOrCheckResult::has_check_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataNameAndContentOrCheckResult::set_has_check_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataNameAndContentOrCheckResult::clear_has_check_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataNameAndContentOrCheckResult::clear_check_result() {
  if (check_result_ != &::google::protobuf::internal::GetEmptyString()) {
    check_result_->clear();
  }
  clear_has_check_result();
}
inline const ::std::string& DataNameAndContentOrCheckResult::check_result() const {
  return *check_result_;
}
inline void DataNameAndContentOrCheckResult::set_check_result(const ::std::string& value) {
  set_has_check_result();
  if (check_result_ == &::google::protobuf::internal::GetEmptyString()) {
    check_result_ = new ::std::string;
  }
  check_result_->assign(value);
}
inline void DataNameAndContentOrCheckResult::set_check_result(const char* value) {
  set_has_check_result();
  if (check_result_ == &::google::protobuf::internal::GetEmptyString()) {
    check_result_ = new ::std::string;
  }
  check_result_->assign(value);
}
inline void DataNameAndContentOrCheckResult::set_check_result(const void* value, size_t size) {
  set_has_check_result();
  if (check_result_ == &::google::protobuf::internal::GetEmptyString()) {
    check_result_ = new ::std::string;
  }
  check_result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataNameAndContentOrCheckResult::mutable_check_result() {
  set_has_check_result();
  if (check_result_ == &::google::protobuf::internal::GetEmptyString()) {
    check_result_ = new ::std::string;
  }
  return check_result_;
}
inline ::std::string* DataNameAndContentOrCheckResult::release_check_result() {
  clear_has_check_result();
  if (check_result_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = check_result_;
    check_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataNameAndContentOrCheckResult::set_allocated_check_result(::std::string* check_result) {
  if (check_result_ != &::google::protobuf::internal::GetEmptyString()) {
    delete check_result_;
  }
  if (check_result) {
    set_has_check_result();
    check_result_ = check_result;
  } else {
    clear_has_check_result();
    check_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// PmidHealth

// required bytes serialised_pmid_health = 1;
inline bool PmidHealth::has_serialised_pmid_health() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PmidHealth::set_has_serialised_pmid_health() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PmidHealth::clear_has_serialised_pmid_health() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PmidHealth::clear_serialised_pmid_health() {
  if (serialised_pmid_health_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_pmid_health_->clear();
  }
  clear_has_serialised_pmid_health();
}
inline const ::std::string& PmidHealth::serialised_pmid_health() const {
  return *serialised_pmid_health_;
}
inline void PmidHealth::set_serialised_pmid_health(const ::std::string& value) {
  set_has_serialised_pmid_health();
  if (serialised_pmid_health_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_pmid_health_ = new ::std::string;
  }
  serialised_pmid_health_->assign(value);
}
inline void PmidHealth::set_serialised_pmid_health(const char* value) {
  set_has_serialised_pmid_health();
  if (serialised_pmid_health_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_pmid_health_ = new ::std::string;
  }
  serialised_pmid_health_->assign(value);
}
inline void PmidHealth::set_serialised_pmid_health(const void* value, size_t size) {
  set_has_serialised_pmid_health();
  if (serialised_pmid_health_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_pmid_health_ = new ::std::string;
  }
  serialised_pmid_health_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PmidHealth::mutable_serialised_pmid_health() {
  set_has_serialised_pmid_health();
  if (serialised_pmid_health_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_pmid_health_ = new ::std::string;
  }
  return serialised_pmid_health_;
}
inline ::std::string* PmidHealth::release_serialised_pmid_health() {
  clear_has_serialised_pmid_health();
  if (serialised_pmid_health_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_pmid_health_;
    serialised_pmid_health_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PmidHealth::set_allocated_serialised_pmid_health(::std::string* serialised_pmid_health) {
  if (serialised_pmid_health_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_pmid_health_;
  }
  if (serialised_pmid_health) {
    set_has_serialised_pmid_health();
    serialised_pmid_health_ = serialised_pmid_health;
  } else {
    clear_has_serialised_pmid_health();
    serialised_pmid_health_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace nfs_vault
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_maidsafe_2fnfs_2fvault_2fmessages_2eproto__INCLUDED
