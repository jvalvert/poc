// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/nfs/vault/messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "maidsafe/nfs/vault/messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace nfs_vault {
namespace protobuf {

void protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto() {
  delete AvailableSize::default_instance_;
  delete DiffSize::default_instance_;
  delete DataName::default_instance_;
  delete DataNames::default_instance_;
  delete DataNameAndVersion::default_instance_;
  delete DataNameOldNewVersion::default_instance_;
  delete VersionTreeCreation::default_instance_;
  delete DataNameAndContent::default_instance_;
  delete DataNameAndRandomString::default_instance_;
  delete DataNameAndCost::default_instance_;
  delete DataNameAndSize::default_instance_;
  delete DataNameAndContentOrCheckResult::default_instance_;
  delete PmidHealth::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  AvailableSize::default_instance_ = new AvailableSize();
  DiffSize::default_instance_ = new DiffSize();
  DataName::default_instance_ = new DataName();
  DataNames::default_instance_ = new DataNames();
  DataNameAndVersion::default_instance_ = new DataNameAndVersion();
  DataNameOldNewVersion::default_instance_ = new DataNameOldNewVersion();
  VersionTreeCreation::default_instance_ = new VersionTreeCreation();
  DataNameAndContent::default_instance_ = new DataNameAndContent();
  DataNameAndRandomString::default_instance_ = new DataNameAndRandomString();
  DataNameAndCost::default_instance_ = new DataNameAndCost();
  DataNameAndSize::default_instance_ = new DataNameAndSize();
  DataNameAndContentOrCheckResult::default_instance_ = new DataNameAndContentOrCheckResult();
  PmidHealth::default_instance_ = new PmidHealth();
  AvailableSize::default_instance_->InitAsDefaultInstance();
  DiffSize::default_instance_->InitAsDefaultInstance();
  DataName::default_instance_->InitAsDefaultInstance();
  DataNames::default_instance_->InitAsDefaultInstance();
  DataNameAndVersion::default_instance_->InitAsDefaultInstance();
  DataNameOldNewVersion::default_instance_->InitAsDefaultInstance();
  VersionTreeCreation::default_instance_->InitAsDefaultInstance();
  DataNameAndContent::default_instance_->InitAsDefaultInstance();
  DataNameAndRandomString::default_instance_->InitAsDefaultInstance();
  DataNameAndCost::default_instance_->InitAsDefaultInstance();
  DataNameAndSize::default_instance_->InitAsDefaultInstance();
  DataNameAndContentOrCheckResult::default_instance_->InitAsDefaultInstance();
  PmidHealth::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_maidsafe_2fnfs_2fvault_2fmessages_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_once_);
void protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_once_,
                 &protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_maidsafe_2fnfs_2fvault_2fmessages_2eproto {
  StaticDescriptorInitializer_maidsafe_2fnfs_2fvault_2fmessages_2eproto() {
    protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
  }
} static_descriptor_initializer_maidsafe_2fnfs_2fvault_2fmessages_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int AvailableSize::kSizeFieldNumber;
#endif  // !_MSC_VER

AvailableSize::AvailableSize()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AvailableSize::InitAsDefaultInstance() {
}

AvailableSize::AvailableSize(const AvailableSize& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AvailableSize::SharedCtor() {
  _cached_size_ = 0;
  size_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AvailableSize::~AvailableSize() {
  SharedDtor();
}

void AvailableSize::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AvailableSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AvailableSize& AvailableSize::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

AvailableSize* AvailableSize::default_instance_ = NULL;

AvailableSize* AvailableSize::New() const {
  return new AvailableSize;
}

void AvailableSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AvailableSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AvailableSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->size(), output);
  }

}

int AvailableSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AvailableSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AvailableSize*>(&from));
}

void AvailableSize::MergeFrom(const AvailableSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
  }
}

void AvailableSize::CopyFrom(const AvailableSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AvailableSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AvailableSize::Swap(AvailableSize* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AvailableSize::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.AvailableSize";
}


// ===================================================================

#ifndef _MSC_VER
const int DiffSize::kSizeFieldNumber;
#endif  // !_MSC_VER

DiffSize::DiffSize()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DiffSize::InitAsDefaultInstance() {
}

DiffSize::DiffSize(const DiffSize& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DiffSize::SharedCtor() {
  _cached_size_ = 0;
  size_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiffSize::~DiffSize() {
  SharedDtor();
}

void DiffSize::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DiffSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DiffSize& DiffSize::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DiffSize* DiffSize::default_instance_ = NULL;

DiffSize* DiffSize::New() const {
  return new DiffSize;
}

void DiffSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DiffSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DiffSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->size(), output);
  }

}

int DiffSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->size());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiffSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DiffSize*>(&from));
}

void DiffSize::MergeFrom(const DiffSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
  }
}

void DiffSize::CopyFrom(const DiffSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiffSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DiffSize::Swap(DiffSize* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DiffSize::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DiffSize";
}


// ===================================================================

#ifndef _MSC_VER
const int DataName::kTypeFieldNumber;
const int DataName::kRawNameFieldNumber;
#endif  // !_MSC_VER

DataName::DataName()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataName::InitAsDefaultInstance() {
}

DataName::DataName(const DataName& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataName::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0u;
  raw_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataName::~DataName() {
  SharedDtor();
}

void DataName::SharedDtor() {
  if (raw_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete raw_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataName::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataName& DataName::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataName* DataName::default_instance_ = NULL;

DataName* DataName::New() const {
  return new DataName;
}

void DataName::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0u;
    if (has_raw_name()) {
      if (raw_name_ != &::google::protobuf::internal::GetEmptyString()) {
        raw_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataName::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_raw_name;
        break;
      }

      // required bytes raw_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_raw_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_raw_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataName::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->type(), output);
  }

  // required bytes raw_name = 2;
  if (has_raw_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->raw_name(), output);
  }

}

int DataName::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // required bytes raw_name = 2;
    if (has_raw_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->raw_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataName::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataName*>(&from));
}

void DataName::MergeFrom(const DataName& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_raw_name()) {
      set_raw_name(from.raw_name());
    }
  }
}

void DataName::CopyFrom(const DataName& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataName::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataName::Swap(DataName* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(raw_name_, other->raw_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataName::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataName";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNames::kDataNamesFieldNumber;
#endif  // !_MSC_VER

DataNames::DataNames()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNames::InitAsDefaultInstance() {
}

DataNames::DataNames(const DataNames& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNames::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNames::~DataNames() {
  SharedDtor();
}

void DataNames::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNames::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNames& DataNames::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNames* DataNames::default_instance_ = NULL;

DataNames* DataNames::New() const {
  return new DataNames;
}

void DataNames::Clear() {
  data_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNames::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .maidsafe.nfs_vault.protobuf.DataName data_names = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data_names()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_data_names;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNames::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .maidsafe.nfs_vault.protobuf.DataName data_names = 1;
  for (int i = 0; i < this->data_names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data_names(i), output);
  }

}

int DataNames::ByteSize() const {
  int total_size = 0;

  // repeated .maidsafe.nfs_vault.protobuf.DataName data_names = 1;
  total_size += 1 * this->data_names_size();
  for (int i = 0; i < this->data_names_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data_names(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNames::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNames*>(&from));
}

void DataNames::MergeFrom(const DataNames& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_names_.MergeFrom(from.data_names_);
}

void DataNames::CopyFrom(const DataNames& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNames::IsInitialized() const {

  for (int i = 0; i < data_names_size(); i++) {
    if (!this->data_names(i).IsInitialized()) return false;
  }
  return true;
}

void DataNames::Swap(DataNames* other) {
  if (other != this) {
    data_names_.Swap(&other->data_names_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNames::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNames";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndVersion::kSerialisedDataNameFieldNumber;
const int DataNameAndVersion::kSerialisedVersionNameFieldNumber;
#endif  // !_MSC_VER

DataNameAndVersion::DataNameAndVersion()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndVersion::InitAsDefaultInstance() {
}

DataNameAndVersion::DataNameAndVersion(const DataNameAndVersion& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndVersion::SharedCtor() {
  _cached_size_ = 0;
  serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndVersion::~DataNameAndVersion() {
  SharedDtor();
}

void DataNameAndVersion::SharedDtor() {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_;
  }
  if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_version_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndVersion& DataNameAndVersion::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndVersion* DataNameAndVersion::default_instance_ = NULL;

DataNameAndVersion* DataNameAndVersion::New() const {
  return new DataNameAndVersion;
}

void DataNameAndVersion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_data_name()) {
      if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_->clear();
      }
    }
    if (has_serialised_version_name()) {
      if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_version_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_data_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_version_name;
        break;
      }

      // required bytes serialised_version_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_version_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_version_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_data_name = 1;
  if (has_serialised_data_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_data_name(), output);
  }

  // required bytes serialised_version_name = 2;
  if (has_serialised_version_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_version_name(), output);
  }

}

int DataNameAndVersion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_data_name = 1;
    if (has_serialised_data_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name());
    }

    // required bytes serialised_version_name = 2;
    if (has_serialised_version_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_version_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndVersion::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndVersion*>(&from));
}

void DataNameAndVersion::MergeFrom(const DataNameAndVersion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_data_name()) {
      set_serialised_data_name(from.serialised_data_name());
    }
    if (from.has_serialised_version_name()) {
      set_serialised_version_name(from.serialised_version_name());
    }
  }
}

void DataNameAndVersion::CopyFrom(const DataNameAndVersion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndVersion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameAndVersion::Swap(DataNameAndVersion* other) {
  if (other != this) {
    std::swap(serialised_data_name_, other->serialised_data_name_);
    std::swap(serialised_version_name_, other->serialised_version_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndVersion::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameAndVersion";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameOldNewVersion::kSerialisedDataNameFieldNumber;
const int DataNameOldNewVersion::kSerialisedOldVersionNameFieldNumber;
const int DataNameOldNewVersion::kSerialisedNewVersionNameFieldNumber;
#endif  // !_MSC_VER

DataNameOldNewVersion::DataNameOldNewVersion()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameOldNewVersion::InitAsDefaultInstance() {
}

DataNameOldNewVersion::DataNameOldNewVersion(const DataNameOldNewVersion& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameOldNewVersion::SharedCtor() {
  _cached_size_ = 0;
  serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_old_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_new_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameOldNewVersion::~DataNameOldNewVersion() {
  SharedDtor();
}

void DataNameOldNewVersion::SharedDtor() {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_;
  }
  if (serialised_old_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_old_version_name_;
  }
  if (serialised_new_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_new_version_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameOldNewVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameOldNewVersion& DataNameOldNewVersion::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameOldNewVersion* DataNameOldNewVersion::default_instance_ = NULL;

DataNameOldNewVersion* DataNameOldNewVersion::New() const {
  return new DataNameOldNewVersion;
}

void DataNameOldNewVersion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_data_name()) {
      if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_->clear();
      }
    }
    if (has_serialised_old_version_name()) {
      if (serialised_old_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_old_version_name_->clear();
      }
    }
    if (has_serialised_new_version_name()) {
      if (serialised_new_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_new_version_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameOldNewVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_data_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_old_version_name;
        break;
      }

      // optional bytes serialised_old_version_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_old_version_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_old_version_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_serialised_new_version_name;
        break;
      }

      // required bytes serialised_new_version_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_new_version_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_new_version_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameOldNewVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_data_name = 1;
  if (has_serialised_data_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_data_name(), output);
  }

  // optional bytes serialised_old_version_name = 2;
  if (has_serialised_old_version_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_old_version_name(), output);
  }

  // required bytes serialised_new_version_name = 3;
  if (has_serialised_new_version_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->serialised_new_version_name(), output);
  }

}

int DataNameOldNewVersion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_data_name = 1;
    if (has_serialised_data_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name());
    }

    // optional bytes serialised_old_version_name = 2;
    if (has_serialised_old_version_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_old_version_name());
    }

    // required bytes serialised_new_version_name = 3;
    if (has_serialised_new_version_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_new_version_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameOldNewVersion::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameOldNewVersion*>(&from));
}

void DataNameOldNewVersion::MergeFrom(const DataNameOldNewVersion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_data_name()) {
      set_serialised_data_name(from.serialised_data_name());
    }
    if (from.has_serialised_old_version_name()) {
      set_serialised_old_version_name(from.serialised_old_version_name());
    }
    if (from.has_serialised_new_version_name()) {
      set_serialised_new_version_name(from.serialised_new_version_name());
    }
  }
}

void DataNameOldNewVersion::CopyFrom(const DataNameOldNewVersion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameOldNewVersion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  return true;
}

void DataNameOldNewVersion::Swap(DataNameOldNewVersion* other) {
  if (other != this) {
    std::swap(serialised_data_name_, other->serialised_data_name_);
    std::swap(serialised_old_version_name_, other->serialised_old_version_name_);
    std::swap(serialised_new_version_name_, other->serialised_new_version_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameOldNewVersion::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameOldNewVersion";
}


// ===================================================================

#ifndef _MSC_VER
const int VersionTreeCreation::kSerialisedDataNameFieldNumber;
const int VersionTreeCreation::kSerialisedVersionNameFieldNumber;
const int VersionTreeCreation::kMaxVersionsFieldNumber;
const int VersionTreeCreation::kMaxBranchesFieldNumber;
#endif  // !_MSC_VER

VersionTreeCreation::VersionTreeCreation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VersionTreeCreation::InitAsDefaultInstance() {
}

VersionTreeCreation::VersionTreeCreation(const VersionTreeCreation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VersionTreeCreation::SharedCtor() {
  _cached_size_ = 0;
  serialised_data_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_version_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  max_versions_ = 0;
  max_branches_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionTreeCreation::~VersionTreeCreation() {
  SharedDtor();
}

void VersionTreeCreation::SharedDtor() {
  if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_name_;
  }
  if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_version_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VersionTreeCreation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VersionTreeCreation& VersionTreeCreation::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

VersionTreeCreation* VersionTreeCreation::default_instance_ = NULL;

VersionTreeCreation* VersionTreeCreation::New() const {
  return new VersionTreeCreation;
}

void VersionTreeCreation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_data_name()) {
      if (serialised_data_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_data_name_->clear();
      }
    }
    if (has_serialised_version_name()) {
      if (serialised_version_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_version_name_->clear();
      }
    }
    max_versions_ = 0;
    max_branches_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VersionTreeCreation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_data_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_data_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_version_name;
        break;
      }

      // required bytes serialised_version_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_version_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_version_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_max_versions;
        break;
      }

      // required int32 max_versions = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_versions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_versions_)));
          set_has_max_versions();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_max_branches;
        break;
      }

      // required int32 max_branches = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_branches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_branches_)));
          set_has_max_branches();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VersionTreeCreation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_data_name = 1;
  if (has_serialised_data_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_data_name(), output);
  }

  // required bytes serialised_version_name = 2;
  if (has_serialised_version_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_version_name(), output);
  }

  // required int32 max_versions = 3;
  if (has_max_versions()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->max_versions(), output);
  }

  // required int32 max_branches = 4;
  if (has_max_branches()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->max_branches(), output);
  }

}

int VersionTreeCreation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_data_name = 1;
    if (has_serialised_data_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_data_name());
    }

    // required bytes serialised_version_name = 2;
    if (has_serialised_version_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_version_name());
    }

    // required int32 max_versions = 3;
    if (has_max_versions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_versions());
    }

    // required int32 max_branches = 4;
    if (has_max_branches()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_branches());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionTreeCreation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VersionTreeCreation*>(&from));
}

void VersionTreeCreation::MergeFrom(const VersionTreeCreation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_data_name()) {
      set_serialised_data_name(from.serialised_data_name());
    }
    if (from.has_serialised_version_name()) {
      set_serialised_version_name(from.serialised_version_name());
    }
    if (from.has_max_versions()) {
      set_max_versions(from.max_versions());
    }
    if (from.has_max_branches()) {
      set_max_branches(from.max_branches());
    }
  }
}

void VersionTreeCreation::CopyFrom(const VersionTreeCreation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionTreeCreation::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void VersionTreeCreation::Swap(VersionTreeCreation* other) {
  if (other != this) {
    std::swap(serialised_data_name_, other->serialised_data_name_);
    std::swap(serialised_version_name_, other->serialised_version_name_);
    std::swap(max_versions_, other->max_versions_);
    std::swap(max_branches_, other->max_branches_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VersionTreeCreation::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.VersionTreeCreation";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndContent::kSerialisedNameFieldNumber;
const int DataNameAndContent::kContentFieldNumber;
#endif  // !_MSC_VER

DataNameAndContent::DataNameAndContent()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndContent::InitAsDefaultInstance() {
}

DataNameAndContent::DataNameAndContent(const DataNameAndContent& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndContent::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndContent::~DataNameAndContent() {
  SharedDtor();
}

void DataNameAndContent::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    delete content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndContent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndContent& DataNameAndContent::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndContent* DataNameAndContent::default_instance_ = NULL;

DataNameAndContent* DataNameAndContent::New() const {
  return new DataNameAndContent;
}

void DataNameAndContent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyString()) {
        content_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndContent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_content;
        break;
      }

      // required bytes content = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndContent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required bytes content = 2;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->content(), output);
  }

}

int DataNameAndContent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required bytes content = 2;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->content());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndContent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndContent*>(&from));
}

void DataNameAndContent::MergeFrom(const DataNameAndContent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
  }
}

void DataNameAndContent::CopyFrom(const DataNameAndContent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndContent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameAndContent::Swap(DataNameAndContent* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(content_, other->content_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndContent::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameAndContent";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndRandomString::kSerialisedNameFieldNumber;
const int DataNameAndRandomString::kRandomStringFieldNumber;
#endif  // !_MSC_VER

DataNameAndRandomString::DataNameAndRandomString()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndRandomString::InitAsDefaultInstance() {
}

DataNameAndRandomString::DataNameAndRandomString(const DataNameAndRandomString& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndRandomString::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  random_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndRandomString::~DataNameAndRandomString() {
  SharedDtor();
}

void DataNameAndRandomString::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (random_string_ != &::google::protobuf::internal::GetEmptyString()) {
    delete random_string_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndRandomString::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndRandomString& DataNameAndRandomString::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndRandomString* DataNameAndRandomString::default_instance_ = NULL;

DataNameAndRandomString* DataNameAndRandomString::New() const {
  return new DataNameAndRandomString;
}

void DataNameAndRandomString::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    if (has_random_string()) {
      if (random_string_ != &::google::protobuf::internal::GetEmptyString()) {
        random_string_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndRandomString::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_random_string;
        break;
      }

      // required bytes random_string = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_random_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_random_string()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndRandomString::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required bytes random_string = 2;
  if (has_random_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->random_string(), output);
  }

}

int DataNameAndRandomString::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required bytes random_string = 2;
    if (has_random_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->random_string());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndRandomString::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndRandomString*>(&from));
}

void DataNameAndRandomString::MergeFrom(const DataNameAndRandomString& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_random_string()) {
      set_random_string(from.random_string());
    }
  }
}

void DataNameAndRandomString::CopyFrom(const DataNameAndRandomString& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndRandomString::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameAndRandomString::Swap(DataNameAndRandomString* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(random_string_, other->random_string_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndRandomString::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameAndRandomString";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndCost::kSerialisedNameFieldNumber;
const int DataNameAndCost::kCostFieldNumber;
#endif  // !_MSC_VER

DataNameAndCost::DataNameAndCost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndCost::InitAsDefaultInstance() {
}

DataNameAndCost::DataNameAndCost(const DataNameAndCost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndCost::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  cost_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndCost::~DataNameAndCost() {
  SharedDtor();
}

void DataNameAndCost::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndCost& DataNameAndCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndCost* DataNameAndCost::default_instance_ = NULL;

DataNameAndCost* DataNameAndCost::New() const {
  return new DataNameAndCost;
}

void DataNameAndCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    cost_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cost;
        break;
      }

      // required int32 cost = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cost_)));
          set_has_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required int32 cost = 2;
  if (has_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->cost(), output);
  }

}

int DataNameAndCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required int32 cost = 2;
    if (has_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cost());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndCost*>(&from));
}

void DataNameAndCost::MergeFrom(const DataNameAndCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_cost()) {
      set_cost(from.cost());
    }
  }
}

void DataNameAndCost::CopyFrom(const DataNameAndCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndCost::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameAndCost::Swap(DataNameAndCost* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(cost_, other->cost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndCost::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameAndCost";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndSize::kSerialisedNameFieldNumber;
const int DataNameAndSize::kSizeFieldNumber;
#endif  // !_MSC_VER

DataNameAndSize::DataNameAndSize()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndSize::InitAsDefaultInstance() {
}

DataNameAndSize::DataNameAndSize(const DataNameAndSize& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndSize::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndSize::~DataNameAndSize() {
  SharedDtor();
}

void DataNameAndSize::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndSize& DataNameAndSize::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndSize* DataNameAndSize::default_instance_ = NULL;

DataNameAndSize* DataNameAndSize::New() const {
  return new DataNameAndSize;
}

void DataNameAndSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    size_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }

      // required int32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // required int32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->size(), output);
  }

}

int DataNameAndSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // required int32 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndSize*>(&from));
}

void DataNameAndSize::MergeFrom(const DataNameAndSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
}

void DataNameAndSize::CopyFrom(const DataNameAndSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void DataNameAndSize::Swap(DataNameAndSize* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndSize::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameAndSize";
}


// ===================================================================

#ifndef _MSC_VER
const int DataNameAndContentOrCheckResult::kSerialisedNameFieldNumber;
const int DataNameAndContentOrCheckResult::kContentFieldNumber;
const int DataNameAndContentOrCheckResult::kCheckResultFieldNumber;
#endif  // !_MSC_VER

DataNameAndContentOrCheckResult::DataNameAndContentOrCheckResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DataNameAndContentOrCheckResult::InitAsDefaultInstance() {
}

DataNameAndContentOrCheckResult::DataNameAndContentOrCheckResult(const DataNameAndContentOrCheckResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DataNameAndContentOrCheckResult::SharedCtor() {
  _cached_size_ = 0;
  serialised_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  check_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataNameAndContentOrCheckResult::~DataNameAndContentOrCheckResult() {
  SharedDtor();
}

void DataNameAndContentOrCheckResult::SharedDtor() {
  if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_name_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyString()) {
    delete content_;
  }
  if (check_result_ != &::google::protobuf::internal::GetEmptyString()) {
    delete check_result_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DataNameAndContentOrCheckResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataNameAndContentOrCheckResult& DataNameAndContentOrCheckResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

DataNameAndContentOrCheckResult* DataNameAndContentOrCheckResult::default_instance_ = NULL;

DataNameAndContentOrCheckResult* DataNameAndContentOrCheckResult::New() const {
  return new DataNameAndContentOrCheckResult;
}

void DataNameAndContentOrCheckResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_name()) {
      if (serialised_name_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_name_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyString()) {
        content_->clear();
      }
    }
    if (has_check_result()) {
      if (check_result_ != &::google::protobuf::internal::GetEmptyString()) {
        check_result_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DataNameAndContentOrCheckResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_content;
        break;
      }

      // optional bytes content = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_check_result;
        break;
      }

      // optional bytes check_result = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_check_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_check_result()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataNameAndContentOrCheckResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_name = 1;
  if (has_serialised_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_name(), output);
  }

  // optional bytes content = 2;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->content(), output);
  }

  // optional bytes check_result = 3;
  if (has_check_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->check_result(), output);
  }

}

int DataNameAndContentOrCheckResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_name = 1;
    if (has_serialised_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_name());
    }

    // optional bytes content = 2;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->content());
    }

    // optional bytes check_result = 3;
    if (has_check_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->check_result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataNameAndContentOrCheckResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataNameAndContentOrCheckResult*>(&from));
}

void DataNameAndContentOrCheckResult::MergeFrom(const DataNameAndContentOrCheckResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_name()) {
      set_serialised_name(from.serialised_name());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_check_result()) {
      set_check_result(from.check_result());
    }
  }
}

void DataNameAndContentOrCheckResult::CopyFrom(const DataNameAndContentOrCheckResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataNameAndContentOrCheckResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DataNameAndContentOrCheckResult::Swap(DataNameAndContentOrCheckResult* other) {
  if (other != this) {
    std::swap(serialised_name_, other->serialised_name_);
    std::swap(content_, other->content_);
    std::swap(check_result_, other->check_result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DataNameAndContentOrCheckResult::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.DataNameAndContentOrCheckResult";
}


// ===================================================================

#ifndef _MSC_VER
const int PmidHealth::kSerialisedPmidHealthFieldNumber;
#endif  // !_MSC_VER

PmidHealth::PmidHealth()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PmidHealth::InitAsDefaultInstance() {
}

PmidHealth::PmidHealth(const PmidHealth& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PmidHealth::SharedCtor() {
  _cached_size_ = 0;
  serialised_pmid_health_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PmidHealth::~PmidHealth() {
  SharedDtor();
}

void PmidHealth::SharedDtor() {
  if (serialised_pmid_health_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_pmid_health_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PmidHealth::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PmidHealth& PmidHealth::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fnfs_2fvault_2fmessages_2eproto();
#endif
  return *default_instance_;
}

PmidHealth* PmidHealth::default_instance_ = NULL;

PmidHealth* PmidHealth::New() const {
  return new PmidHealth;
}

void PmidHealth::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_serialised_pmid_health()) {
      if (serialised_pmid_health_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_pmid_health_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PmidHealth::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes serialised_pmid_health = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_pmid_health()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PmidHealth::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes serialised_pmid_health = 1;
  if (has_serialised_pmid_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->serialised_pmid_health(), output);
  }

}

int PmidHealth::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes serialised_pmid_health = 1;
    if (has_serialised_pmid_health()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_pmid_health());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PmidHealth::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PmidHealth*>(&from));
}

void PmidHealth::MergeFrom(const PmidHealth& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serialised_pmid_health()) {
      set_serialised_pmid_health(from.serialised_pmid_health());
    }
  }
}

void PmidHealth::CopyFrom(const PmidHealth& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PmidHealth::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PmidHealth::Swap(PmidHealth* other) {
  if (other != this) {
    std::swap(serialised_pmid_health_, other->serialised_pmid_health_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PmidHealth::GetTypeName() const {
  return "maidsafe.nfs_vault.protobuf.PmidHealth";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace nfs_vault
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)
