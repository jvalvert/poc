// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/routing/routing.proto

#ifndef PROTOBUF_maidsafe_2frouting_2frouting_2eproto__INCLUDED
#define PROTOBUF_maidsafe_2frouting_2frouting_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace routing {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

class Layer;
class Endpoint;
class Contact;
class ConfigFile;
class Message;
class SignedMessage;
class ConnectRequest;
class ConnectResponse;
class ConnectSuccess;
class ConnectSuccessAcknowledgement;
class FindNodesRequest;
class FindNodesResponse;
class PingRequest;
class PingResponse;
class RemoveRequest;
class RemoveResponse;
class NodeIdList;
class NodeIdList_NodeId;
class BasicNodeInfo;
class ClosestNodesUpdate;
class InformClientOfhNewCloseNode;
class GetGroup;
class NodeInfo;

enum NatType {
  kSymmetric = 0,
  kOther = 1,
  kUnknown = 2
};
bool NatType_IsValid(int value);
const NatType NatType_MIN = kSymmetric;
const NatType NatType_MAX = kUnknown;
const int NatType_ARRAYSIZE = NatType_MAX + 1;

enum ConnectResponseType {
  kAccepted = 0,
  kRejected = 1,
  kConnectAttemptAlreadyRunning = 2
};
bool ConnectResponseType_IsValid(int value);
const ConnectResponseType ConnectResponseType_MIN = kAccepted;
const ConnectResponseType ConnectResponseType_MAX = kConnectAttemptAlreadyRunning;
const int ConnectResponseType_ARRAYSIZE = ConnectResponseType_MAX + 1;

// ===================================================================

class Layer : public ::google::protobuf::MessageLite {
 public:
  Layer();
  virtual ~Layer();

  Layer(const Layer& from);

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }

  static const Layer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Layer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Layer* other);

  // implements Message ----------------------------------------------

  Layer* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Layer& from);
  void MergeFrom(const Layer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline ::google::protobuf::int32 identifier() const;
  inline void set_identifier(::google::protobuf::int32 value);

  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.Layer)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_message();
  inline void clear_has_message();

  ::std::string* message_;
  ::google::protobuf::int32 identifier_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static Layer* default_instance_;
};
// -------------------------------------------------------------------

class Endpoint : public ::google::protobuf::MessageLite {
 public:
  Endpoint();
  virtual ~Endpoint();

  Endpoint(const Endpoint& from);

  inline Endpoint& operator=(const Endpoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const Endpoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Endpoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Endpoint* other);

  // implements Message ----------------------------------------------

  Endpoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Endpoint& from);
  void MergeFrom(const Endpoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.Endpoint)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string* ip_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static Endpoint* default_instance_;
};
// -------------------------------------------------------------------

class Contact : public ::google::protobuf::MessageLite {
 public:
  Contact();
  virtual ~Contact();

  Contact(const Contact& from);

  inline Contact& operator=(const Contact& from) {
    CopyFrom(from);
    return *this;
  }

  static const Contact& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Contact* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Contact* other);

  // implements Message ----------------------------------------------

  Contact* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Contact& from);
  void MergeFrom(const Contact& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required bytes connection_id = 2;
  inline bool has_connection_id() const;
  inline void clear_connection_id();
  static const int kConnectionIdFieldNumber = 2;
  inline const ::std::string& connection_id() const;
  inline void set_connection_id(const ::std::string& value);
  inline void set_connection_id(const char* value);
  inline void set_connection_id(const void* value, size_t size);
  inline ::std::string* mutable_connection_id();
  inline ::std::string* release_connection_id();
  inline void set_allocated_connection_id(::std::string* connection_id);

  // required .maidsafe.routing.protobuf.Endpoint private_endpoint = 3;
  inline bool has_private_endpoint() const;
  inline void clear_private_endpoint();
  static const int kPrivateEndpointFieldNumber = 3;
  inline const ::maidsafe::routing::protobuf::Endpoint& private_endpoint() const;
  inline ::maidsafe::routing::protobuf::Endpoint* mutable_private_endpoint();
  inline ::maidsafe::routing::protobuf::Endpoint* release_private_endpoint();
  inline void set_allocated_private_endpoint(::maidsafe::routing::protobuf::Endpoint* private_endpoint);

  // required .maidsafe.routing.protobuf.Endpoint public_endpoint = 4;
  inline bool has_public_endpoint() const;
  inline void clear_public_endpoint();
  static const int kPublicEndpointFieldNumber = 4;
  inline const ::maidsafe::routing::protobuf::Endpoint& public_endpoint() const;
  inline ::maidsafe::routing::protobuf::Endpoint* mutable_public_endpoint();
  inline ::maidsafe::routing::protobuf::Endpoint* release_public_endpoint();
  inline void set_allocated_public_endpoint(::maidsafe::routing::protobuf::Endpoint* public_endpoint);

  // optional .maidsafe.routing.protobuf.NatType nat_type = 5;
  inline bool has_nat_type() const;
  inline void clear_nat_type();
  static const int kNatTypeFieldNumber = 5;
  inline ::maidsafe::routing::protobuf::NatType nat_type() const;
  inline void set_nat_type(::maidsafe::routing::protobuf::NatType value);

  // optional bool tcp = 6;
  inline bool has_tcp() const;
  inline void clear_tcp();
  static const int kTcpFieldNumber = 6;
  inline bool tcp() const;
  inline void set_tcp(bool value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.Contact)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_connection_id();
  inline void clear_has_connection_id();
  inline void set_has_private_endpoint();
  inline void clear_has_private_endpoint();
  inline void set_has_public_endpoint();
  inline void clear_has_public_endpoint();
  inline void set_has_nat_type();
  inline void clear_has_nat_type();
  inline void set_has_tcp();
  inline void clear_has_tcp();

  ::std::string* node_id_;
  ::std::string* connection_id_;
  ::maidsafe::routing::protobuf::Endpoint* private_endpoint_;
  ::maidsafe::routing::protobuf::Endpoint* public_endpoint_;
  int nat_type_;
  bool tcp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static Contact* default_instance_;
};
// -------------------------------------------------------------------

class ConfigFile : public ::google::protobuf::MessageLite {
 public:
  ConfigFile();
  virtual ~ConfigFile();

  ConfigFile(const ConfigFile& from);

  inline ConfigFile& operator=(const ConfigFile& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConfigFile& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigFile* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigFile* other);

  // implements Message ----------------------------------------------

  ConfigFile* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigFile& from);
  void MergeFrom(const ConfigFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // optional bytes private_key = 2;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.ConfigFile)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_private_key();
  inline void clear_has_private_key();

  ::std::string* node_id_;
  ::std::string* private_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static ConfigFile* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::MessageLite {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const Message& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Message* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes source_id = 1;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 1;
  inline const ::std::string& source_id() const;
  inline void set_source_id(const ::std::string& value);
  inline void set_source_id(const char* value);
  inline void set_source_id(const void* value, size_t size);
  inline ::std::string* mutable_source_id();
  inline ::std::string* release_source_id();
  inline void set_allocated_source_id(::std::string* source_id);

  // optional bytes destination_id = 2;
  inline bool has_destination_id() const;
  inline void clear_destination_id();
  static const int kDestinationIdFieldNumber = 2;
  inline const ::std::string& destination_id() const;
  inline void set_destination_id(const ::std::string& value);
  inline void set_destination_id(const char* value);
  inline void set_destination_id(const void* value, size_t size);
  inline ::std::string* mutable_destination_id();
  inline ::std::string* release_destination_id();
  inline void set_allocated_destination_id(::std::string* destination_id);

  // required bool routing_message = 3;
  inline bool has_routing_message() const;
  inline void clear_routing_message();
  static const int kRoutingMessageFieldNumber = 3;
  inline bool routing_message() const;
  inline void set_routing_message(bool value);

  // optional bytes last_id = 4;
  inline bool has_last_id() const;
  inline void clear_last_id();
  static const int kLastIdFieldNumber = 4;
  inline const ::std::string& last_id() const;
  inline void set_last_id(const ::std::string& value);
  inline void set_last_id(const char* value);
  inline void set_last_id(const void* value, size_t size);
  inline ::std::string* mutable_last_id();
  inline ::std::string* release_last_id();
  inline void set_allocated_last_id(::std::string* last_id);

  // optional bytes relay_id = 5;
  inline bool has_relay_id() const;
  inline void clear_relay_id();
  static const int kRelayIdFieldNumber = 5;
  inline const ::std::string& relay_id() const;
  inline void set_relay_id(const ::std::string& value);
  inline void set_relay_id(const char* value);
  inline void set_relay_id(const void* value, size_t size);
  inline ::std::string* mutable_relay_id();
  inline ::std::string* release_relay_id();
  inline void set_allocated_relay_id(::std::string* relay_id);

  // repeated bytes data = 6;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 6;
  inline const ::std::string& data(int index) const;
  inline ::std::string* mutable_data(int index);
  inline void set_data(int index, const ::std::string& value);
  inline void set_data(int index, const char* value);
  inline void set_data(int index, const void* value, size_t size);
  inline ::std::string* add_data();
  inline void add_data(const ::std::string& value);
  inline void add_data(const char* value);
  inline void add_data(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // optional bytes signature = 7;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 7;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // required bool direct = 8;
  inline bool has_direct() const;
  inline void clear_direct();
  static const int kDirectFieldNumber = 8;
  inline bool direct() const;
  inline void set_direct(bool value);

  // optional int32 replication = 9;
  inline bool has_replication() const;
  inline void clear_replication();
  static const int kReplicationFieldNumber = 9;
  inline ::google::protobuf::int32 replication() const;
  inline void set_replication(::google::protobuf::int32 value);

  // optional sint32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 cacheable = 11;
  inline bool has_cacheable() const;
  inline void clear_cacheable();
  static const int kCacheableFieldNumber = 11;
  inline ::google::protobuf::int32 cacheable() const;
  inline void set_cacheable(::google::protobuf::int32 value);

  // optional int32 id = 12;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 12;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool client_node = 13;
  inline bool has_client_node() const;
  inline void clear_client_node();
  static const int kClientNodeFieldNumber = 13;
  inline bool client_node() const;
  inline void set_client_node(bool value);

  // optional bytes relay_connection_id = 14;
  inline bool has_relay_connection_id() const;
  inline void clear_relay_connection_id();
  static const int kRelayConnectionIdFieldNumber = 14;
  inline const ::std::string& relay_connection_id() const;
  inline void set_relay_connection_id(const ::std::string& value);
  inline void set_relay_connection_id(const char* value);
  inline void set_relay_connection_id(const void* value, size_t size);
  inline ::std::string* mutable_relay_connection_id();
  inline ::std::string* release_relay_connection_id();
  inline void set_allocated_relay_connection_id(::std::string* relay_connection_id);

  // optional bool closest_to_this_node = 15;
  inline bool has_closest_to_this_node() const;
  inline void clear_closest_to_this_node();
  static const int kClosestToThisNodeFieldNumber = 15;
  inline bool closest_to_this_node() const;
  inline void set_closest_to_this_node(bool value);

  // optional bool close_to_this_node = 16;
  inline bool has_close_to_this_node() const;
  inline void clear_close_to_this_node();
  static const int kCloseToThisNodeFieldNumber = 16;
  inline bool close_to_this_node() const;
  inline void set_close_to_this_node(bool value);

  // repeated bytes route_history = 17;
  inline int route_history_size() const;
  inline void clear_route_history();
  static const int kRouteHistoryFieldNumber = 17;
  inline const ::std::string& route_history(int index) const;
  inline ::std::string* mutable_route_history(int index);
  inline void set_route_history(int index, const ::std::string& value);
  inline void set_route_history(int index, const char* value);
  inline void set_route_history(int index, const void* value, size_t size);
  inline ::std::string* add_route_history();
  inline void add_route_history(const ::std::string& value);
  inline void add_route_history(const char* value);
  inline void add_route_history(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& route_history() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_route_history();

  // required bool request = 18;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 18;
  inline bool request() const;
  inline void set_request(bool value);

  // required int32 hops_to_live = 19;
  inline bool has_hops_to_live() const;
  inline void clear_hops_to_live();
  static const int kHopsToLiveFieldNumber = 19;
  inline ::google::protobuf::int32 hops_to_live() const;
  inline void set_hops_to_live(::google::protobuf::int32 value);

  // optional bool visited = 20;
  inline bool has_visited() const;
  inline void clear_visited();
  static const int kVisitedFieldNumber = 20;
  inline bool visited() const;
  inline void set_visited(bool value);

  // optional bytes average_distace = 21;
  inline bool has_average_distace() const;
  inline void clear_average_distace();
  static const int kAverageDistaceFieldNumber = 21;
  inline const ::std::string& average_distace() const;
  inline void set_average_distace(const ::std::string& value);
  inline void set_average_distace(const char* value);
  inline void set_average_distace(const void* value, size_t size);
  inline ::std::string* mutable_average_distace();
  inline ::std::string* release_average_distace();
  inline void set_allocated_average_distace(::std::string* average_distace);

  // optional bytes group_source = 22;
  inline bool has_group_source() const;
  inline void clear_group_source();
  static const int kGroupSourceFieldNumber = 22;
  inline const ::std::string& group_source() const;
  inline void set_group_source(const ::std::string& value);
  inline void set_group_source(const char* value);
  inline void set_group_source(const void* value, size_t size);
  inline ::std::string* mutable_group_source();
  inline ::std::string* release_group_source();
  inline void set_allocated_group_source(::std::string* group_source);

  // optional bytes group_destination = 23;
  inline bool has_group_destination() const;
  inline void clear_group_destination();
  static const int kGroupDestinationFieldNumber = 23;
  inline const ::std::string& group_destination() const;
  inline void set_group_destination(const ::std::string& value);
  inline void set_group_destination(const char* value);
  inline void set_group_destination(const void* value, size_t size);
  inline ::std::string* mutable_group_destination();
  inline ::std::string* release_group_destination();
  inline void set_allocated_group_destination(::std::string* group_destination);

  // optional bool actual_destination_is_relay_id = 24;
  inline bool has_actual_destination_is_relay_id() const;
  inline void clear_actual_destination_is_relay_id();
  static const int kActualDestinationIsRelayIdFieldNumber = 24;
  inline bool actual_destination_is_relay_id() const;
  inline void set_actual_destination_is_relay_id(bool value);

  // optional int32 ack_id = 25;
  inline bool has_ack_id() const;
  inline void clear_ack_id();
  static const int kAckIdFieldNumber = 25;
  inline ::google::protobuf::int32 ack_id() const;
  inline void set_ack_id(::google::protobuf::int32 value);

  // repeated bytes ack_node_ids = 26;
  inline int ack_node_ids_size() const;
  inline void clear_ack_node_ids();
  static const int kAckNodeIdsFieldNumber = 26;
  inline const ::std::string& ack_node_ids(int index) const;
  inline ::std::string* mutable_ack_node_ids(int index);
  inline void set_ack_node_ids(int index, const ::std::string& value);
  inline void set_ack_node_ids(int index, const char* value);
  inline void set_ack_node_ids(int index, const void* value, size_t size);
  inline ::std::string* add_ack_node_ids();
  inline void add_ack_node_ids(const ::std::string& value);
  inline void add_ack_node_ids(const char* value);
  inline void add_ack_node_ids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ack_node_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ack_node_ids();

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.Message)
 private:
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_destination_id();
  inline void clear_has_destination_id();
  inline void set_has_routing_message();
  inline void clear_has_routing_message();
  inline void set_has_last_id();
  inline void clear_has_last_id();
  inline void set_has_relay_id();
  inline void clear_has_relay_id();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_direct();
  inline void clear_has_direct();
  inline void set_has_replication();
  inline void clear_has_replication();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_cacheable();
  inline void clear_has_cacheable();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_client_node();
  inline void clear_has_client_node();
  inline void set_has_relay_connection_id();
  inline void clear_has_relay_connection_id();
  inline void set_has_closest_to_this_node();
  inline void clear_has_closest_to_this_node();
  inline void set_has_close_to_this_node();
  inline void clear_has_close_to_this_node();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_hops_to_live();
  inline void clear_has_hops_to_live();
  inline void set_has_visited();
  inline void clear_has_visited();
  inline void set_has_average_distace();
  inline void clear_has_average_distace();
  inline void set_has_group_source();
  inline void clear_has_group_source();
  inline void set_has_group_destination();
  inline void clear_has_group_destination();
  inline void set_has_actual_destination_is_relay_id();
  inline void clear_has_actual_destination_is_relay_id();
  inline void set_has_ack_id();
  inline void clear_has_ack_id();

  ::std::string* source_id_;
  ::std::string* destination_id_;
  ::std::string* last_id_;
  ::std::string* relay_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  ::std::string* signature_;
  ::google::protobuf::int32 replication_;
  bool routing_message_;
  bool direct_;
  bool client_node_;
  bool closest_to_this_node_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 cacheable_;
  ::std::string* relay_connection_id_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 hops_to_live_;
  ::google::protobuf::RepeatedPtrField< ::std::string> route_history_;
  bool close_to_this_node_;
  bool request_;
  bool visited_;
  bool actual_destination_is_relay_id_;
  ::google::protobuf::int32 ack_id_;
  ::std::string* average_distace_;
  ::std::string* group_source_;
  ::std::string* group_destination_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ack_node_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class SignedMessage : public ::google::protobuf::MessageLite {
 public:
  SignedMessage();
  virtual ~SignedMessage();

  SignedMessage(const SignedMessage& from);

  inline SignedMessage& operator=(const SignedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SignedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SignedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SignedMessage* other);

  // implements Message ----------------------------------------------

  SignedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SignedMessage& from);
  void MergeFrom(const SignedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // required bytes id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.SignedMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string* message_;
  ::std::string* signature_;
  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static SignedMessage* default_instance_;
};
// -------------------------------------------------------------------

class ConnectRequest : public ::google::protobuf::MessageLite {
 public:
  ConnectRequest();
  virtual ~ConnectRequest();

  ConnectRequest(const ConnectRequest& from);

  inline ConnectRequest& operator=(const ConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnectRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnectRequest* other);

  // implements Message ----------------------------------------------

  ConnectRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnectRequest& from);
  void MergeFrom(const ConnectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .maidsafe.routing.protobuf.Contact contact = 1;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 1;
  inline const ::maidsafe::routing::protobuf::Contact& contact() const;
  inline ::maidsafe::routing::protobuf::Contact* mutable_contact();
  inline ::maidsafe::routing::protobuf::Contact* release_contact();
  inline void set_allocated_contact(::maidsafe::routing::protobuf::Contact* contact);

  // required bytes peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // optional bool bootstrap = 3;
  inline bool has_bootstrap() const;
  inline void clear_bootstrap();
  static const int kBootstrapFieldNumber = 3;
  inline bool bootstrap() const;
  inline void set_bootstrap(bool value);

  // optional uint64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.ConnectRequest)
 private:
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_bootstrap();
  inline void clear_has_bootstrap();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::maidsafe::routing::protobuf::Contact* contact_;
  ::std::string* peer_id_;
  ::google::protobuf::uint64 timestamp_;
  bool bootstrap_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static ConnectRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConnectResponse : public ::google::protobuf::MessageLite {
 public:
  ConnectResponse();
  virtual ~ConnectResponse();

  ConnectResponse(const ConnectResponse& from);

  inline ConnectResponse& operator=(const ConnectResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnectResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnectResponse* other);

  // implements Message ----------------------------------------------

  ConnectResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnectResponse& from);
  void MergeFrom(const ConnectResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .maidsafe.routing.protobuf.ConnectResponseType answer = 1;
  inline bool has_answer() const;
  inline void clear_answer();
  static const int kAnswerFieldNumber = 1;
  inline ::maidsafe::routing::protobuf::ConnectResponseType answer() const;
  inline void set_answer(::maidsafe::routing::protobuf::ConnectResponseType value);

  // optional .maidsafe.routing.protobuf.Contact contact = 2;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 2;
  inline const ::maidsafe::routing::protobuf::Contact& contact() const;
  inline ::maidsafe::routing::protobuf::Contact* mutable_contact();
  inline ::maidsafe::routing::protobuf::Contact* release_contact();
  inline void set_allocated_contact(::maidsafe::routing::protobuf::Contact* contact);

  // optional bytes connection_id = 3;
  inline bool has_connection_id() const;
  inline void clear_connection_id();
  static const int kConnectionIdFieldNumber = 3;
  inline const ::std::string& connection_id() const;
  inline void set_connection_id(const ::std::string& value);
  inline void set_connection_id(const char* value);
  inline void set_connection_id(const void* value, size_t size);
  inline ::std::string* mutable_connection_id();
  inline ::std::string* release_connection_id();
  inline void set_allocated_connection_id(::std::string* connection_id);

  // optional .maidsafe.routing.protobuf.Endpoint seen_endpoint = 4;
  inline bool has_seen_endpoint() const;
  inline void clear_seen_endpoint();
  static const int kSeenEndpointFieldNumber = 4;
  inline const ::maidsafe::routing::protobuf::Endpoint& seen_endpoint() const;
  inline ::maidsafe::routing::protobuf::Endpoint* mutable_seen_endpoint();
  inline ::maidsafe::routing::protobuf::Endpoint* release_seen_endpoint();
  inline void set_allocated_seen_endpoint(::maidsafe::routing::protobuf::Endpoint* seen_endpoint);

  // optional uint64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required bytes original_request = 6;
  inline bool has_original_request() const;
  inline void clear_original_request();
  static const int kOriginalRequestFieldNumber = 6;
  inline const ::std::string& original_request() const;
  inline void set_original_request(const ::std::string& value);
  inline void set_original_request(const char* value);
  inline void set_original_request(const void* value, size_t size);
  inline ::std::string* mutable_original_request();
  inline ::std::string* release_original_request();
  inline void set_allocated_original_request(::std::string* original_request);

  // required bytes original_signature = 7;
  inline bool has_original_signature() const;
  inline void clear_original_signature();
  static const int kOriginalSignatureFieldNumber = 7;
  inline const ::std::string& original_signature() const;
  inline void set_original_signature(const ::std::string& value);
  inline void set_original_signature(const char* value);
  inline void set_original_signature(const void* value, size_t size);
  inline ::std::string* mutable_original_signature();
  inline ::std::string* release_original_signature();
  inline void set_allocated_original_signature(::std::string* original_signature);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.ConnectResponse)
 private:
  inline void set_has_answer();
  inline void clear_has_answer();
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_connection_id();
  inline void clear_has_connection_id();
  inline void set_has_seen_endpoint();
  inline void clear_has_seen_endpoint();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_original_request();
  inline void clear_has_original_request();
  inline void set_has_original_signature();
  inline void clear_has_original_signature();

  ::maidsafe::routing::protobuf::Contact* contact_;
  ::std::string* connection_id_;
  ::maidsafe::routing::protobuf::Endpoint* seen_endpoint_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* original_request_;
  ::std::string* original_signature_;
  int answer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static ConnectResponse* default_instance_;
};
// -------------------------------------------------------------------

class ConnectSuccess : public ::google::protobuf::MessageLite {
 public:
  ConnectSuccess();
  virtual ~ConnectSuccess();

  ConnectSuccess(const ConnectSuccess& from);

  inline ConnectSuccess& operator=(const ConnectSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectSuccess& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnectSuccess* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnectSuccess* other);

  // implements Message ----------------------------------------------

  ConnectSuccess* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnectSuccess& from);
  void MergeFrom(const ConnectSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required bytes connection_id = 2;
  inline bool has_connection_id() const;
  inline void clear_connection_id();
  static const int kConnectionIdFieldNumber = 2;
  inline const ::std::string& connection_id() const;
  inline void set_connection_id(const ::std::string& value);
  inline void set_connection_id(const char* value);
  inline void set_connection_id(const void* value, size_t size);
  inline ::std::string* mutable_connection_id();
  inline ::std::string* release_connection_id();
  inline void set_allocated_connection_id(::std::string* connection_id);

  // required bool requestor = 3;
  inline bool has_requestor() const;
  inline void clear_requestor();
  static const int kRequestorFieldNumber = 3;
  inline bool requestor() const;
  inline void set_requestor(bool value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.ConnectSuccess)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_connection_id();
  inline void clear_has_connection_id();
  inline void set_has_requestor();
  inline void clear_has_requestor();

  ::std::string* node_id_;
  ::std::string* connection_id_;
  bool requestor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static ConnectSuccess* default_instance_;
};
// -------------------------------------------------------------------

class ConnectSuccessAcknowledgement : public ::google::protobuf::MessageLite {
 public:
  ConnectSuccessAcknowledgement();
  virtual ~ConnectSuccessAcknowledgement();

  ConnectSuccessAcknowledgement(const ConnectSuccessAcknowledgement& from);

  inline ConnectSuccessAcknowledgement& operator=(const ConnectSuccessAcknowledgement& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectSuccessAcknowledgement& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConnectSuccessAcknowledgement* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConnectSuccessAcknowledgement* other);

  // implements Message ----------------------------------------------

  ConnectSuccessAcknowledgement* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConnectSuccessAcknowledgement& from);
  void MergeFrom(const ConnectSuccessAcknowledgement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required bytes connection_id = 2;
  inline bool has_connection_id() const;
  inline void clear_connection_id();
  static const int kConnectionIdFieldNumber = 2;
  inline const ::std::string& connection_id() const;
  inline void set_connection_id(const ::std::string& value);
  inline void set_connection_id(const char* value);
  inline void set_connection_id(const void* value, size_t size);
  inline ::std::string* mutable_connection_id();
  inline ::std::string* release_connection_id();
  inline void set_allocated_connection_id(::std::string* connection_id);

  // repeated bytes close_ids = 3;
  inline int close_ids_size() const;
  inline void clear_close_ids();
  static const int kCloseIdsFieldNumber = 3;
  inline const ::std::string& close_ids(int index) const;
  inline ::std::string* mutable_close_ids(int index);
  inline void set_close_ids(int index, const ::std::string& value);
  inline void set_close_ids(int index, const char* value);
  inline void set_close_ids(int index, const void* value, size_t size);
  inline ::std::string* add_close_ids();
  inline void add_close_ids(const ::std::string& value);
  inline void add_close_ids(const char* value);
  inline void add_close_ids(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& close_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_close_ids();

  // required bool requestor = 4;
  inline bool has_requestor() const;
  inline void clear_requestor();
  static const int kRequestorFieldNumber = 4;
  inline bool requestor() const;
  inline void set_requestor(bool value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.ConnectSuccessAcknowledgement)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_connection_id();
  inline void clear_has_connection_id();
  inline void set_has_requestor();
  inline void clear_has_requestor();

  ::std::string* node_id_;
  ::std::string* connection_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> close_ids_;
  bool requestor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static ConnectSuccessAcknowledgement* default_instance_;
};
// -------------------------------------------------------------------

class FindNodesRequest : public ::google::protobuf::MessageLite {
 public:
  FindNodesRequest();
  virtual ~FindNodesRequest();

  FindNodesRequest(const FindNodesRequest& from);

  inline FindNodesRequest& operator=(const FindNodesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const FindNodesRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindNodesRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindNodesRequest* other);

  // implements Message ----------------------------------------------

  FindNodesRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindNodesRequest& from);
  void MergeFrom(const FindNodesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_nodes_requested = 1;
  inline bool has_num_nodes_requested() const;
  inline void clear_num_nodes_requested();
  static const int kNumNodesRequestedFieldNumber = 1;
  inline ::google::protobuf::uint32 num_nodes_requested() const;
  inline void set_num_nodes_requested(::google::protobuf::uint32 value);

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.FindNodesRequest)
 private:
  inline void set_has_num_nodes_requested();
  inline void clear_has_num_nodes_requested();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 num_nodes_requested_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static FindNodesRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindNodesResponse : public ::google::protobuf::MessageLite {
 public:
  FindNodesResponse();
  virtual ~FindNodesResponse();

  FindNodesResponse(const FindNodesResponse& from);

  inline FindNodesResponse& operator=(const FindNodesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const FindNodesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindNodesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindNodesResponse* other);

  // implements Message ----------------------------------------------

  FindNodesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindNodesResponse& from);
  void MergeFrom(const FindNodesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::std::string& nodes(int index) const;
  inline ::std::string* mutable_nodes(int index);
  inline void set_nodes(int index, const ::std::string& value);
  inline void set_nodes(int index, const char* value);
  inline void set_nodes(int index, const void* value, size_t size);
  inline ::std::string* add_nodes();
  inline void add_nodes(const ::std::string& value);
  inline void add_nodes(const char* value);
  inline void add_nodes(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nodes();

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required bytes original_request = 3;
  inline bool has_original_request() const;
  inline void clear_original_request();
  static const int kOriginalRequestFieldNumber = 3;
  inline const ::std::string& original_request() const;
  inline void set_original_request(const ::std::string& value);
  inline void set_original_request(const char* value);
  inline void set_original_request(const void* value, size_t size);
  inline ::std::string* mutable_original_request();
  inline ::std::string* release_original_request();
  inline void set_allocated_original_request(::std::string* original_request);

  // required bytes original_signature = 4;
  inline bool has_original_signature() const;
  inline void clear_original_signature();
  static const int kOriginalSignatureFieldNumber = 4;
  inline const ::std::string& original_signature() const;
  inline void set_original_signature(const ::std::string& value);
  inline void set_original_signature(const char* value);
  inline void set_original_signature(const void* value, size_t size);
  inline ::std::string* mutable_original_signature();
  inline ::std::string* release_original_signature();
  inline void set_allocated_original_signature(::std::string* original_signature);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.FindNodesResponse)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_original_request();
  inline void clear_has_original_request();
  inline void set_has_original_signature();
  inline void clear_has_original_signature();

  ::google::protobuf::RepeatedPtrField< ::std::string> nodes_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* original_request_;
  ::std::string* original_signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static FindNodesResponse* default_instance_;
};
// -------------------------------------------------------------------

class PingRequest : public ::google::protobuf::MessageLite {
 public:
  PingRequest();
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingRequest* other);

  // implements Message ----------------------------------------------

  PingRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool ping = 1;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 1;
  inline bool ping() const;
  inline void set_ping(bool value);

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.PingRequest)
 private:
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint64 timestamp_;
  bool ping_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static PingRequest* default_instance_;
};
// -------------------------------------------------------------------

class PingResponse : public ::google::protobuf::MessageLite {
 public:
  PingResponse();
  virtual ~PingResponse();

  PingResponse(const PingResponse& from);

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingResponse* other);

  // implements Message ----------------------------------------------

  PingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingResponse& from);
  void MergeFrom(const PingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool pong = 1;
  inline bool has_pong() const;
  inline void clear_pong();
  static const int kPongFieldNumber = 1;
  inline bool pong() const;
  inline void set_pong(bool value);

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // required bytes original_request = 3;
  inline bool has_original_request() const;
  inline void clear_original_request();
  static const int kOriginalRequestFieldNumber = 3;
  inline const ::std::string& original_request() const;
  inline void set_original_request(const ::std::string& value);
  inline void set_original_request(const char* value);
  inline void set_original_request(const void* value, size_t size);
  inline ::std::string* mutable_original_request();
  inline ::std::string* release_original_request();
  inline void set_allocated_original_request(::std::string* original_request);

  // required bytes original_signature = 4;
  inline bool has_original_signature() const;
  inline void clear_original_signature();
  static const int kOriginalSignatureFieldNumber = 4;
  inline const ::std::string& original_signature() const;
  inline void set_original_signature(const ::std::string& value);
  inline void set_original_signature(const char* value);
  inline void set_original_signature(const void* value, size_t size);
  inline ::std::string* mutable_original_signature();
  inline ::std::string* release_original_signature();
  inline void set_allocated_original_signature(::std::string* original_signature);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.PingResponse)
 private:
  inline void set_has_pong();
  inline void clear_has_pong();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_original_request();
  inline void clear_has_original_request();
  inline void set_has_original_signature();
  inline void clear_has_original_signature();

  ::google::protobuf::uint64 timestamp_;
  ::std::string* original_request_;
  ::std::string* original_signature_;
  bool pong_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static PingResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveRequest : public ::google::protobuf::MessageLite {
 public:
  RemoveRequest();
  virtual ~RemoveRequest();

  RemoveRequest(const RemoveRequest& from);

  inline RemoveRequest& operator=(const RemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveRequest* other);

  // implements Message ----------------------------------------------

  RemoveRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveRequest& from);
  void MergeFrom(const RemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes peer_id = 1;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 1;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // repeated bytes attempted_nodes = 2;
  inline int attempted_nodes_size() const;
  inline void clear_attempted_nodes();
  static const int kAttemptedNodesFieldNumber = 2;
  inline const ::std::string& attempted_nodes(int index) const;
  inline ::std::string* mutable_attempted_nodes(int index);
  inline void set_attempted_nodes(int index, const ::std::string& value);
  inline void set_attempted_nodes(int index, const char* value);
  inline void set_attempted_nodes(int index, const void* value, size_t size);
  inline ::std::string* add_attempted_nodes();
  inline void add_attempted_nodes(const ::std::string& value);
  inline void add_attempted_nodes(const char* value);
  inline void add_attempted_nodes(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attempted_nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attempted_nodes();

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.RemoveRequest)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();

  ::std::string* peer_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attempted_nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static RemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoveResponse : public ::google::protobuf::MessageLite {
 public:
  RemoveResponse();
  virtual ~RemoveResponse();

  RemoveResponse(const RemoveResponse& from);

  inline RemoveResponse& operator=(const RemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const RemoveResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RemoveResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RemoveResponse* other);

  // implements Message ----------------------------------------------

  RemoveResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RemoveResponse& from);
  void MergeFrom(const RemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // required bytes peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline const ::std::string& peer_id() const;
  inline void set_peer_id(const ::std::string& value);
  inline void set_peer_id(const char* value);
  inline void set_peer_id(const void* value, size_t size);
  inline ::std::string* mutable_peer_id();
  inline ::std::string* release_peer_id();
  inline void set_allocated_peer_id(::std::string* peer_id);

  // required bytes original_request = 3;
  inline bool has_original_request() const;
  inline void clear_original_request();
  static const int kOriginalRequestFieldNumber = 3;
  inline const ::std::string& original_request() const;
  inline void set_original_request(const ::std::string& value);
  inline void set_original_request(const char* value);
  inline void set_original_request(const void* value, size_t size);
  inline ::std::string* mutable_original_request();
  inline ::std::string* release_original_request();
  inline void set_allocated_original_request(::std::string* original_request);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.RemoveResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_peer_id();
  inline void clear_has_peer_id();
  inline void set_has_original_request();
  inline void clear_has_original_request();

  ::std::string* peer_id_;
  ::std::string* original_request_;
  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static RemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class NodeIdList_NodeId : public ::google::protobuf::MessageLite {
 public:
  NodeIdList_NodeId();
  virtual ~NodeIdList_NodeId();

  NodeIdList_NodeId(const NodeIdList_NodeId& from);

  inline NodeIdList_NodeId& operator=(const NodeIdList_NodeId& from) {
    CopyFrom(from);
    return *this;
  }

  static const NodeIdList_NodeId& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NodeIdList_NodeId* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NodeIdList_NodeId* other);

  // implements Message ----------------------------------------------

  NodeIdList_NodeId* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NodeIdList_NodeId& from);
  void MergeFrom(const NodeIdList_NodeId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.NodeIdList.NodeId)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::std::string* node_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static NodeIdList_NodeId* default_instance_;
};
// -------------------------------------------------------------------

class NodeIdList : public ::google::protobuf::MessageLite {
 public:
  NodeIdList();
  virtual ~NodeIdList();

  NodeIdList(const NodeIdList& from);

  inline NodeIdList& operator=(const NodeIdList& from) {
    CopyFrom(from);
    return *this;
  }

  static const NodeIdList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NodeIdList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NodeIdList* other);

  // implements Message ----------------------------------------------

  NodeIdList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NodeIdList& from);
  void MergeFrom(const NodeIdList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef NodeIdList_NodeId NodeId;

  // accessors -------------------------------------------------------

  // repeated .maidsafe.routing.protobuf.NodeIdList.NodeId node_id_list = 1;
  inline int node_id_list_size() const;
  inline void clear_node_id_list();
  static const int kNodeIdListFieldNumber = 1;
  inline const ::maidsafe::routing::protobuf::NodeIdList_NodeId& node_id_list(int index) const;
  inline ::maidsafe::routing::protobuf::NodeIdList_NodeId* mutable_node_id_list(int index);
  inline ::maidsafe::routing::protobuf::NodeIdList_NodeId* add_node_id_list();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::NodeIdList_NodeId >&
      node_id_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::NodeIdList_NodeId >*
      mutable_node_id_list();

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.NodeIdList)
 private:

  ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::NodeIdList_NodeId > node_id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static NodeIdList* default_instance_;
};
// -------------------------------------------------------------------

class BasicNodeInfo : public ::google::protobuf::MessageLite {
 public:
  BasicNodeInfo();
  virtual ~BasicNodeInfo();

  BasicNodeInfo(const BasicNodeInfo& from);

  inline BasicNodeInfo& operator=(const BasicNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BasicNodeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BasicNodeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BasicNodeInfo* other);

  // implements Message ----------------------------------------------

  BasicNodeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BasicNodeInfo& from);
  void MergeFrom(const BasicNodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required int32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.BasicNodeInfo)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::std::string* node_id_;
  ::google::protobuf::int32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static BasicNodeInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClosestNodesUpdate : public ::google::protobuf::MessageLite {
 public:
  ClosestNodesUpdate();
  virtual ~ClosestNodesUpdate();

  ClosestNodesUpdate(const ClosestNodesUpdate& from);

  inline ClosestNodesUpdate& operator=(const ClosestNodesUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClosestNodesUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClosestNodesUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClosestNodesUpdate* other);

  // implements Message ----------------------------------------------

  ClosestNodesUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClosestNodesUpdate& from);
  void MergeFrom(const ClosestNodesUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node() const;
  inline void set_node(const ::std::string& value);
  inline void set_node(const char* value);
  inline void set_node(const void* value, size_t size);
  inline ::std::string* mutable_node();
  inline ::std::string* release_node();
  inline void set_allocated_node(::std::string* node);

  // repeated .maidsafe.routing.protobuf.BasicNodeInfo nodes_info = 2;
  inline int nodes_info_size() const;
  inline void clear_nodes_info();
  static const int kNodesInfoFieldNumber = 2;
  inline const ::maidsafe::routing::protobuf::BasicNodeInfo& nodes_info(int index) const;
  inline ::maidsafe::routing::protobuf::BasicNodeInfo* mutable_nodes_info(int index);
  inline ::maidsafe::routing::protobuf::BasicNodeInfo* add_nodes_info();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::BasicNodeInfo >&
      nodes_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::BasicNodeInfo >*
      mutable_nodes_info();

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.ClosestNodesUpdate)
 private:
  inline void set_has_node();
  inline void clear_has_node();

  ::std::string* node_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::BasicNodeInfo > nodes_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static ClosestNodesUpdate* default_instance_;
};
// -------------------------------------------------------------------

class InformClientOfhNewCloseNode : public ::google::protobuf::MessageLite {
 public:
  InformClientOfhNewCloseNode();
  virtual ~InformClientOfhNewCloseNode();

  InformClientOfhNewCloseNode(const InformClientOfhNewCloseNode& from);

  inline InformClientOfhNewCloseNode& operator=(const InformClientOfhNewCloseNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const InformClientOfhNewCloseNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InformClientOfhNewCloseNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InformClientOfhNewCloseNode* other);

  // implements Message ----------------------------------------------

  InformClientOfhNewCloseNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InformClientOfhNewCloseNode& from);
  void MergeFrom(const InformClientOfhNewCloseNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.InformClientOfhNewCloseNode)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::std::string* node_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static InformClientOfhNewCloseNode* default_instance_;
};
// -------------------------------------------------------------------

class GetGroup : public ::google::protobuf::MessageLite {
 public:
  GetGroup();
  virtual ~GetGroup();

  GetGroup(const GetGroup& from);

  inline GetGroup& operator=(const GetGroup& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetGroup& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetGroup* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetGroup* other);

  // implements Message ----------------------------------------------

  GetGroup* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetGroup& from);
  void MergeFrom(const GetGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // repeated bytes group_nodes_id = 2;
  inline int group_nodes_id_size() const;
  inline void clear_group_nodes_id();
  static const int kGroupNodesIdFieldNumber = 2;
  inline const ::std::string& group_nodes_id(int index) const;
  inline ::std::string* mutable_group_nodes_id(int index);
  inline void set_group_nodes_id(int index, const ::std::string& value);
  inline void set_group_nodes_id(int index, const char* value);
  inline void set_group_nodes_id(int index, const void* value, size_t size);
  inline ::std::string* add_group_nodes_id();
  inline void add_group_nodes_id(const ::std::string& value);
  inline void add_group_nodes_id(const char* value);
  inline void add_group_nodes_id(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& group_nodes_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_group_nodes_id();

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.GetGroup)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::std::string* node_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> group_nodes_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static GetGroup* default_instance_;
};
// -------------------------------------------------------------------

class NodeInfo : public ::google::protobuf::MessageLite {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const NodeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NodeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NodeInfo* other);

  // implements Message ----------------------------------------------

  NodeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::std::string& node_id() const;
  inline void set_node_id(const ::std::string& value);
  inline void set_node_id(const char* value);
  inline void set_node_id(const void* value, size_t size);
  inline ::std::string* mutable_node_id();
  inline ::std::string* release_node_id();
  inline void set_allocated_node_id(::std::string* node_id);

  // required int32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // repeated int32 dimension_list = 3;
  inline int dimension_list_size() const;
  inline void clear_dimension_list();
  static const int kDimensionListFieldNumber = 3;
  inline ::google::protobuf::int32 dimension_list(int index) const;
  inline void set_dimension_list(int index, ::google::protobuf::int32 value);
  inline void add_dimension_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dimension_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dimension_list();

  // @@protoc_insertion_point(class_scope:maidsafe.routing.protobuf.NodeInfo)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::std::string* node_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dimension_list_;
  ::google::protobuf::int32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2frouting_2frouting_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2frouting_2frouting_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2frouting_2frouting_2eproto();

  void InitAsDefaultInstance();
  static NodeInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// Layer

// required int32 identifier = 1;
inline bool Layer::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Layer::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Layer::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Layer::clear_identifier() {
  identifier_ = 0;
  clear_has_identifier();
}
inline ::google::protobuf::int32 Layer::identifier() const {
  return identifier_;
}
inline void Layer::set_identifier(::google::protobuf::int32 value) {
  set_has_identifier();
  identifier_ = value;
}

// required bytes message = 2;
inline bool Layer::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Layer::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Layer::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Layer::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyString()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Layer::message() const {
  return *message_;
}
inline void Layer::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Layer::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Layer::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Layer::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Layer::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Layer::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Endpoint

// required bytes ip = 1;
inline bool Endpoint::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Endpoint::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Endpoint::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Endpoint::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyString()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Endpoint::ip() const {
  return *ip_;
}
inline void Endpoint::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyString()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Endpoint::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyString()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Endpoint::set_ip(const void* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyString()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Endpoint::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyString()) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Endpoint::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Endpoint::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyString()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 port = 2;
inline bool Endpoint::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Endpoint::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Endpoint::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Endpoint::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Endpoint::port() const {
  return port_;
}
inline void Endpoint::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// Contact

// required bytes node_id = 1;
inline bool Contact::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contact::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contact::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contact::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& Contact::node_id() const {
  return *node_id_;
}
inline void Contact::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Contact::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void Contact::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* Contact::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Contact::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes connection_id = 2;
inline bool Contact::has_connection_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Contact::set_has_connection_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Contact::clear_has_connection_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Contact::clear_connection_id() {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    connection_id_->clear();
  }
  clear_has_connection_id();
}
inline const ::std::string& Contact::connection_id() const {
  return *connection_id_;
}
inline void Contact::set_connection_id(const ::std::string& value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void Contact::set_connection_id(const char* value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void Contact::set_connection_id(const void* value, size_t size) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Contact::mutable_connection_id() {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  return connection_id_;
}
inline ::std::string* Contact::release_connection_id() {
  clear_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = connection_id_;
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Contact::set_allocated_connection_id(::std::string* connection_id) {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete connection_id_;
  }
  if (connection_id) {
    set_has_connection_id();
    connection_id_ = connection_id;
  } else {
    clear_has_connection_id();
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required .maidsafe.routing.protobuf.Endpoint private_endpoint = 3;
inline bool Contact::has_private_endpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Contact::set_has_private_endpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Contact::clear_has_private_endpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Contact::clear_private_endpoint() {
  if (private_endpoint_ != NULL) private_endpoint_->::maidsafe::routing::protobuf::Endpoint::Clear();
  clear_has_private_endpoint();
}
inline const ::maidsafe::routing::protobuf::Endpoint& Contact::private_endpoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return private_endpoint_ != NULL ? *private_endpoint_ : *default_instance().private_endpoint_;
#else
  return private_endpoint_ != NULL ? *private_endpoint_ : *default_instance_->private_endpoint_;
#endif
}
inline ::maidsafe::routing::protobuf::Endpoint* Contact::mutable_private_endpoint() {
  set_has_private_endpoint();
  if (private_endpoint_ == NULL) private_endpoint_ = new ::maidsafe::routing::protobuf::Endpoint;
  return private_endpoint_;
}
inline ::maidsafe::routing::protobuf::Endpoint* Contact::release_private_endpoint() {
  clear_has_private_endpoint();
  ::maidsafe::routing::protobuf::Endpoint* temp = private_endpoint_;
  private_endpoint_ = NULL;
  return temp;
}
inline void Contact::set_allocated_private_endpoint(::maidsafe::routing::protobuf::Endpoint* private_endpoint) {
  delete private_endpoint_;
  private_endpoint_ = private_endpoint;
  if (private_endpoint) {
    set_has_private_endpoint();
  } else {
    clear_has_private_endpoint();
  }
}

// required .maidsafe.routing.protobuf.Endpoint public_endpoint = 4;
inline bool Contact::has_public_endpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Contact::set_has_public_endpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Contact::clear_has_public_endpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Contact::clear_public_endpoint() {
  if (public_endpoint_ != NULL) public_endpoint_->::maidsafe::routing::protobuf::Endpoint::Clear();
  clear_has_public_endpoint();
}
inline const ::maidsafe::routing::protobuf::Endpoint& Contact::public_endpoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return public_endpoint_ != NULL ? *public_endpoint_ : *default_instance().public_endpoint_;
#else
  return public_endpoint_ != NULL ? *public_endpoint_ : *default_instance_->public_endpoint_;
#endif
}
inline ::maidsafe::routing::protobuf::Endpoint* Contact::mutable_public_endpoint() {
  set_has_public_endpoint();
  if (public_endpoint_ == NULL) public_endpoint_ = new ::maidsafe::routing::protobuf::Endpoint;
  return public_endpoint_;
}
inline ::maidsafe::routing::protobuf::Endpoint* Contact::release_public_endpoint() {
  clear_has_public_endpoint();
  ::maidsafe::routing::protobuf::Endpoint* temp = public_endpoint_;
  public_endpoint_ = NULL;
  return temp;
}
inline void Contact::set_allocated_public_endpoint(::maidsafe::routing::protobuf::Endpoint* public_endpoint) {
  delete public_endpoint_;
  public_endpoint_ = public_endpoint;
  if (public_endpoint) {
    set_has_public_endpoint();
  } else {
    clear_has_public_endpoint();
  }
}

// optional .maidsafe.routing.protobuf.NatType nat_type = 5;
inline bool Contact::has_nat_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Contact::set_has_nat_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Contact::clear_has_nat_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Contact::clear_nat_type() {
  nat_type_ = 0;
  clear_has_nat_type();
}
inline ::maidsafe::routing::protobuf::NatType Contact::nat_type() const {
  return static_cast< ::maidsafe::routing::protobuf::NatType >(nat_type_);
}
inline void Contact::set_nat_type(::maidsafe::routing::protobuf::NatType value) {
  assert(::maidsafe::routing::protobuf::NatType_IsValid(value));
  set_has_nat_type();
  nat_type_ = value;
}

// optional bool tcp = 6;
inline bool Contact::has_tcp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Contact::set_has_tcp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Contact::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Contact::clear_tcp() {
  tcp_ = false;
  clear_has_tcp();
}
inline bool Contact::tcp() const {
  return tcp_;
}
inline void Contact::set_tcp(bool value) {
  set_has_tcp();
  tcp_ = value;
}

// -------------------------------------------------------------------

// ConfigFile

// optional bytes node_id = 1;
inline bool ConfigFile::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigFile::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigFile::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigFile::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& ConfigFile::node_id() const {
  return *node_id_;
}
inline void ConfigFile::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void ConfigFile::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void ConfigFile::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigFile::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* ConfigFile::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConfigFile::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes private_key = 2;
inline bool ConfigFile::has_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigFile::set_has_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigFile::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigFile::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& ConfigFile::private_key() const {
  return *private_key_;
}
inline void ConfigFile::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void ConfigFile::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void ConfigFile::set_private_key(const void* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigFile::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* ConfigFile::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConfigFile::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Message

// optional bytes source_id = 1;
inline bool Message::has_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_source_id() {
  if (source_id_ != &::google::protobuf::internal::GetEmptyString()) {
    source_id_->clear();
  }
  clear_has_source_id();
}
inline const ::std::string& Message::source_id() const {
  return *source_id_;
}
inline void Message::set_source_id(const ::std::string& value) {
  set_has_source_id();
  if (source_id_ == &::google::protobuf::internal::GetEmptyString()) {
    source_id_ = new ::std::string;
  }
  source_id_->assign(value);
}
inline void Message::set_source_id(const char* value) {
  set_has_source_id();
  if (source_id_ == &::google::protobuf::internal::GetEmptyString()) {
    source_id_ = new ::std::string;
  }
  source_id_->assign(value);
}
inline void Message::set_source_id(const void* value, size_t size) {
  set_has_source_id();
  if (source_id_ == &::google::protobuf::internal::GetEmptyString()) {
    source_id_ = new ::std::string;
  }
  source_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_source_id() {
  set_has_source_id();
  if (source_id_ == &::google::protobuf::internal::GetEmptyString()) {
    source_id_ = new ::std::string;
  }
  return source_id_;
}
inline ::std::string* Message::release_source_id() {
  clear_has_source_id();
  if (source_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = source_id_;
    source_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_source_id(::std::string* source_id) {
  if (source_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete source_id_;
  }
  if (source_id) {
    set_has_source_id();
    source_id_ = source_id;
  } else {
    clear_has_source_id();
    source_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes destination_id = 2;
inline bool Message::has_destination_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_destination_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_destination_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_destination_id() {
  if (destination_id_ != &::google::protobuf::internal::GetEmptyString()) {
    destination_id_->clear();
  }
  clear_has_destination_id();
}
inline const ::std::string& Message::destination_id() const {
  return *destination_id_;
}
inline void Message::set_destination_id(const ::std::string& value) {
  set_has_destination_id();
  if (destination_id_ == &::google::protobuf::internal::GetEmptyString()) {
    destination_id_ = new ::std::string;
  }
  destination_id_->assign(value);
}
inline void Message::set_destination_id(const char* value) {
  set_has_destination_id();
  if (destination_id_ == &::google::protobuf::internal::GetEmptyString()) {
    destination_id_ = new ::std::string;
  }
  destination_id_->assign(value);
}
inline void Message::set_destination_id(const void* value, size_t size) {
  set_has_destination_id();
  if (destination_id_ == &::google::protobuf::internal::GetEmptyString()) {
    destination_id_ = new ::std::string;
  }
  destination_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_destination_id() {
  set_has_destination_id();
  if (destination_id_ == &::google::protobuf::internal::GetEmptyString()) {
    destination_id_ = new ::std::string;
  }
  return destination_id_;
}
inline ::std::string* Message::release_destination_id() {
  clear_has_destination_id();
  if (destination_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = destination_id_;
    destination_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_destination_id(::std::string* destination_id) {
  if (destination_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete destination_id_;
  }
  if (destination_id) {
    set_has_destination_id();
    destination_id_ = destination_id;
  } else {
    clear_has_destination_id();
    destination_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bool routing_message = 3;
inline bool Message::has_routing_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_routing_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_routing_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_routing_message() {
  routing_message_ = false;
  clear_has_routing_message();
}
inline bool Message::routing_message() const {
  return routing_message_;
}
inline void Message::set_routing_message(bool value) {
  set_has_routing_message();
  routing_message_ = value;
}

// optional bytes last_id = 4;
inline bool Message::has_last_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_last_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_last_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_last_id() {
  if (last_id_ != &::google::protobuf::internal::GetEmptyString()) {
    last_id_->clear();
  }
  clear_has_last_id();
}
inline const ::std::string& Message::last_id() const {
  return *last_id_;
}
inline void Message::set_last_id(const ::std::string& value) {
  set_has_last_id();
  if (last_id_ == &::google::protobuf::internal::GetEmptyString()) {
    last_id_ = new ::std::string;
  }
  last_id_->assign(value);
}
inline void Message::set_last_id(const char* value) {
  set_has_last_id();
  if (last_id_ == &::google::protobuf::internal::GetEmptyString()) {
    last_id_ = new ::std::string;
  }
  last_id_->assign(value);
}
inline void Message::set_last_id(const void* value, size_t size) {
  set_has_last_id();
  if (last_id_ == &::google::protobuf::internal::GetEmptyString()) {
    last_id_ = new ::std::string;
  }
  last_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_last_id() {
  set_has_last_id();
  if (last_id_ == &::google::protobuf::internal::GetEmptyString()) {
    last_id_ = new ::std::string;
  }
  return last_id_;
}
inline ::std::string* Message::release_last_id() {
  clear_has_last_id();
  if (last_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = last_id_;
    last_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_last_id(::std::string* last_id) {
  if (last_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete last_id_;
  }
  if (last_id) {
    set_has_last_id();
    last_id_ = last_id;
  } else {
    clear_has_last_id();
    last_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes relay_id = 5;
inline bool Message::has_relay_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_relay_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_relay_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_relay_id() {
  if (relay_id_ != &::google::protobuf::internal::GetEmptyString()) {
    relay_id_->clear();
  }
  clear_has_relay_id();
}
inline const ::std::string& Message::relay_id() const {
  return *relay_id_;
}
inline void Message::set_relay_id(const ::std::string& value) {
  set_has_relay_id();
  if (relay_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_id_ = new ::std::string;
  }
  relay_id_->assign(value);
}
inline void Message::set_relay_id(const char* value) {
  set_has_relay_id();
  if (relay_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_id_ = new ::std::string;
  }
  relay_id_->assign(value);
}
inline void Message::set_relay_id(const void* value, size_t size) {
  set_has_relay_id();
  if (relay_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_id_ = new ::std::string;
  }
  relay_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_relay_id() {
  set_has_relay_id();
  if (relay_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_id_ = new ::std::string;
  }
  return relay_id_;
}
inline ::std::string* Message::release_relay_id() {
  clear_has_relay_id();
  if (relay_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = relay_id_;
    relay_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_relay_id(::std::string* relay_id) {
  if (relay_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete relay_id_;
  }
  if (relay_id) {
    set_has_relay_id();
    relay_id_ = relay_id;
  } else {
    clear_has_relay_id();
    relay_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated bytes data = 6;
inline int Message::data_size() const {
  return data_.size();
}
inline void Message::clear_data() {
  data_.Clear();
}
inline const ::std::string& Message::data(int index) const {
  return data_.Get(index);
}
inline ::std::string* Message::mutable_data(int index) {
  return data_.Mutable(index);
}
inline void Message::set_data(int index, const ::std::string& value) {
  data_.Mutable(index)->assign(value);
}
inline void Message::set_data(int index, const char* value) {
  data_.Mutable(index)->assign(value);
}
inline void Message::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::add_data() {
  return data_.Add();
}
inline void Message::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
}
inline void Message::add_data(const char* value) {
  data_.Add()->assign(value);
}
inline void Message::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Message::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Message::mutable_data() {
  return &data_;
}

// optional bytes signature = 7;
inline bool Message::has_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_signature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_signature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& Message::signature() const {
  return *signature_;
}
inline void Message::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Message::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void Message::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* Message::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bool direct = 8;
inline bool Message::has_direct() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_direct() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_direct() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_direct() {
  direct_ = false;
  clear_has_direct();
}
inline bool Message::direct() const {
  return direct_;
}
inline void Message::set_direct(bool value) {
  set_has_direct();
  direct_ = value;
}

// optional int32 replication = 9;
inline bool Message::has_replication() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_replication() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_replication() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_replication() {
  replication_ = 0;
  clear_has_replication();
}
inline ::google::protobuf::int32 Message::replication() const {
  return replication_;
}
inline void Message::set_replication(::google::protobuf::int32 value) {
  set_has_replication();
  replication_ = value;
}

// optional sint32 type = 10;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Message::type() const {
  return type_;
}
inline void Message::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 cacheable = 11;
inline bool Message::has_cacheable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_cacheable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_cacheable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_cacheable() {
  cacheable_ = 0;
  clear_has_cacheable();
}
inline ::google::protobuf::int32 Message::cacheable() const {
  return cacheable_;
}
inline void Message::set_cacheable(::google::protobuf::int32 value) {
  set_has_cacheable();
  cacheable_ = value;
}

// optional int32 id = 12;
inline bool Message::has_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Message::id() const {
  return id_;
}
inline void Message::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required bool client_node = 13;
inline bool Message::has_client_node() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_client_node() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_client_node() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_client_node() {
  client_node_ = false;
  clear_has_client_node();
}
inline bool Message::client_node() const {
  return client_node_;
}
inline void Message::set_client_node(bool value) {
  set_has_client_node();
  client_node_ = value;
}

// optional bytes relay_connection_id = 14;
inline bool Message::has_relay_connection_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_relay_connection_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_relay_connection_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_relay_connection_id() {
  if (relay_connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    relay_connection_id_->clear();
  }
  clear_has_relay_connection_id();
}
inline const ::std::string& Message::relay_connection_id() const {
  return *relay_connection_id_;
}
inline void Message::set_relay_connection_id(const ::std::string& value) {
  set_has_relay_connection_id();
  if (relay_connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_connection_id_ = new ::std::string;
  }
  relay_connection_id_->assign(value);
}
inline void Message::set_relay_connection_id(const char* value) {
  set_has_relay_connection_id();
  if (relay_connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_connection_id_ = new ::std::string;
  }
  relay_connection_id_->assign(value);
}
inline void Message::set_relay_connection_id(const void* value, size_t size) {
  set_has_relay_connection_id();
  if (relay_connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_connection_id_ = new ::std::string;
  }
  relay_connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_relay_connection_id() {
  set_has_relay_connection_id();
  if (relay_connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    relay_connection_id_ = new ::std::string;
  }
  return relay_connection_id_;
}
inline ::std::string* Message::release_relay_connection_id() {
  clear_has_relay_connection_id();
  if (relay_connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = relay_connection_id_;
    relay_connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_relay_connection_id(::std::string* relay_connection_id) {
  if (relay_connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete relay_connection_id_;
  }
  if (relay_connection_id) {
    set_has_relay_connection_id();
    relay_connection_id_ = relay_connection_id;
  } else {
    clear_has_relay_connection_id();
    relay_connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool closest_to_this_node = 15;
inline bool Message::has_closest_to_this_node() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_closest_to_this_node() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_closest_to_this_node() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_closest_to_this_node() {
  closest_to_this_node_ = false;
  clear_has_closest_to_this_node();
}
inline bool Message::closest_to_this_node() const {
  return closest_to_this_node_;
}
inline void Message::set_closest_to_this_node(bool value) {
  set_has_closest_to_this_node();
  closest_to_this_node_ = value;
}

// optional bool close_to_this_node = 16;
inline bool Message::has_close_to_this_node() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message::set_has_close_to_this_node() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message::clear_has_close_to_this_node() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message::clear_close_to_this_node() {
  close_to_this_node_ = false;
  clear_has_close_to_this_node();
}
inline bool Message::close_to_this_node() const {
  return close_to_this_node_;
}
inline void Message::set_close_to_this_node(bool value) {
  set_has_close_to_this_node();
  close_to_this_node_ = value;
}

// repeated bytes route_history = 17;
inline int Message::route_history_size() const {
  return route_history_.size();
}
inline void Message::clear_route_history() {
  route_history_.Clear();
}
inline const ::std::string& Message::route_history(int index) const {
  return route_history_.Get(index);
}
inline ::std::string* Message::mutable_route_history(int index) {
  return route_history_.Mutable(index);
}
inline void Message::set_route_history(int index, const ::std::string& value) {
  route_history_.Mutable(index)->assign(value);
}
inline void Message::set_route_history(int index, const char* value) {
  route_history_.Mutable(index)->assign(value);
}
inline void Message::set_route_history(int index, const void* value, size_t size) {
  route_history_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::add_route_history() {
  return route_history_.Add();
}
inline void Message::add_route_history(const ::std::string& value) {
  route_history_.Add()->assign(value);
}
inline void Message::add_route_history(const char* value) {
  route_history_.Add()->assign(value);
}
inline void Message::add_route_history(const void* value, size_t size) {
  route_history_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Message::route_history() const {
  return route_history_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Message::mutable_route_history() {
  return &route_history_;
}

// required bool request = 18;
inline bool Message::has_request() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message::set_has_request() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message::clear_has_request() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message::clear_request() {
  request_ = false;
  clear_has_request();
}
inline bool Message::request() const {
  return request_;
}
inline void Message::set_request(bool value) {
  set_has_request();
  request_ = value;
}

// required int32 hops_to_live = 19;
inline bool Message::has_hops_to_live() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message::set_has_hops_to_live() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message::clear_has_hops_to_live() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message::clear_hops_to_live() {
  hops_to_live_ = 0;
  clear_has_hops_to_live();
}
inline ::google::protobuf::int32 Message::hops_to_live() const {
  return hops_to_live_;
}
inline void Message::set_hops_to_live(::google::protobuf::int32 value) {
  set_has_hops_to_live();
  hops_to_live_ = value;
}

// optional bool visited = 20;
inline bool Message::has_visited() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Message::set_has_visited() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Message::clear_has_visited() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Message::clear_visited() {
  visited_ = false;
  clear_has_visited();
}
inline bool Message::visited() const {
  return visited_;
}
inline void Message::set_visited(bool value) {
  set_has_visited();
  visited_ = value;
}

// optional bytes average_distace = 21;
inline bool Message::has_average_distace() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Message::set_has_average_distace() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Message::clear_has_average_distace() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Message::clear_average_distace() {
  if (average_distace_ != &::google::protobuf::internal::GetEmptyString()) {
    average_distace_->clear();
  }
  clear_has_average_distace();
}
inline const ::std::string& Message::average_distace() const {
  return *average_distace_;
}
inline void Message::set_average_distace(const ::std::string& value) {
  set_has_average_distace();
  if (average_distace_ == &::google::protobuf::internal::GetEmptyString()) {
    average_distace_ = new ::std::string;
  }
  average_distace_->assign(value);
}
inline void Message::set_average_distace(const char* value) {
  set_has_average_distace();
  if (average_distace_ == &::google::protobuf::internal::GetEmptyString()) {
    average_distace_ = new ::std::string;
  }
  average_distace_->assign(value);
}
inline void Message::set_average_distace(const void* value, size_t size) {
  set_has_average_distace();
  if (average_distace_ == &::google::protobuf::internal::GetEmptyString()) {
    average_distace_ = new ::std::string;
  }
  average_distace_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_average_distace() {
  set_has_average_distace();
  if (average_distace_ == &::google::protobuf::internal::GetEmptyString()) {
    average_distace_ = new ::std::string;
  }
  return average_distace_;
}
inline ::std::string* Message::release_average_distace() {
  clear_has_average_distace();
  if (average_distace_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = average_distace_;
    average_distace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_average_distace(::std::string* average_distace) {
  if (average_distace_ != &::google::protobuf::internal::GetEmptyString()) {
    delete average_distace_;
  }
  if (average_distace) {
    set_has_average_distace();
    average_distace_ = average_distace;
  } else {
    clear_has_average_distace();
    average_distace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes group_source = 22;
inline bool Message::has_group_source() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Message::set_has_group_source() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Message::clear_has_group_source() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Message::clear_group_source() {
  if (group_source_ != &::google::protobuf::internal::GetEmptyString()) {
    group_source_->clear();
  }
  clear_has_group_source();
}
inline const ::std::string& Message::group_source() const {
  return *group_source_;
}
inline void Message::set_group_source(const ::std::string& value) {
  set_has_group_source();
  if (group_source_ == &::google::protobuf::internal::GetEmptyString()) {
    group_source_ = new ::std::string;
  }
  group_source_->assign(value);
}
inline void Message::set_group_source(const char* value) {
  set_has_group_source();
  if (group_source_ == &::google::protobuf::internal::GetEmptyString()) {
    group_source_ = new ::std::string;
  }
  group_source_->assign(value);
}
inline void Message::set_group_source(const void* value, size_t size) {
  set_has_group_source();
  if (group_source_ == &::google::protobuf::internal::GetEmptyString()) {
    group_source_ = new ::std::string;
  }
  group_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_group_source() {
  set_has_group_source();
  if (group_source_ == &::google::protobuf::internal::GetEmptyString()) {
    group_source_ = new ::std::string;
  }
  return group_source_;
}
inline ::std::string* Message::release_group_source() {
  clear_has_group_source();
  if (group_source_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_source_;
    group_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_group_source(::std::string* group_source) {
  if (group_source_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_source_;
  }
  if (group_source) {
    set_has_group_source();
    group_source_ = group_source;
  } else {
    clear_has_group_source();
    group_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes group_destination = 23;
inline bool Message::has_group_destination() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Message::set_has_group_destination() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Message::clear_has_group_destination() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Message::clear_group_destination() {
  if (group_destination_ != &::google::protobuf::internal::GetEmptyString()) {
    group_destination_->clear();
  }
  clear_has_group_destination();
}
inline const ::std::string& Message::group_destination() const {
  return *group_destination_;
}
inline void Message::set_group_destination(const ::std::string& value) {
  set_has_group_destination();
  if (group_destination_ == &::google::protobuf::internal::GetEmptyString()) {
    group_destination_ = new ::std::string;
  }
  group_destination_->assign(value);
}
inline void Message::set_group_destination(const char* value) {
  set_has_group_destination();
  if (group_destination_ == &::google::protobuf::internal::GetEmptyString()) {
    group_destination_ = new ::std::string;
  }
  group_destination_->assign(value);
}
inline void Message::set_group_destination(const void* value, size_t size) {
  set_has_group_destination();
  if (group_destination_ == &::google::protobuf::internal::GetEmptyString()) {
    group_destination_ = new ::std::string;
  }
  group_destination_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_group_destination() {
  set_has_group_destination();
  if (group_destination_ == &::google::protobuf::internal::GetEmptyString()) {
    group_destination_ = new ::std::string;
  }
  return group_destination_;
}
inline ::std::string* Message::release_group_destination() {
  clear_has_group_destination();
  if (group_destination_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = group_destination_;
    group_destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Message::set_allocated_group_destination(::std::string* group_destination) {
  if (group_destination_ != &::google::protobuf::internal::GetEmptyString()) {
    delete group_destination_;
  }
  if (group_destination) {
    set_has_group_destination();
    group_destination_ = group_destination;
  } else {
    clear_has_group_destination();
    group_destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool actual_destination_is_relay_id = 24;
inline bool Message::has_actual_destination_is_relay_id() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Message::set_has_actual_destination_is_relay_id() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Message::clear_has_actual_destination_is_relay_id() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Message::clear_actual_destination_is_relay_id() {
  actual_destination_is_relay_id_ = false;
  clear_has_actual_destination_is_relay_id();
}
inline bool Message::actual_destination_is_relay_id() const {
  return actual_destination_is_relay_id_;
}
inline void Message::set_actual_destination_is_relay_id(bool value) {
  set_has_actual_destination_is_relay_id();
  actual_destination_is_relay_id_ = value;
}

// optional int32 ack_id = 25;
inline bool Message::has_ack_id() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Message::set_has_ack_id() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Message::clear_has_ack_id() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Message::clear_ack_id() {
  ack_id_ = 0;
  clear_has_ack_id();
}
inline ::google::protobuf::int32 Message::ack_id() const {
  return ack_id_;
}
inline void Message::set_ack_id(::google::protobuf::int32 value) {
  set_has_ack_id();
  ack_id_ = value;
}

// repeated bytes ack_node_ids = 26;
inline int Message::ack_node_ids_size() const {
  return ack_node_ids_.size();
}
inline void Message::clear_ack_node_ids() {
  ack_node_ids_.Clear();
}
inline const ::std::string& Message::ack_node_ids(int index) const {
  return ack_node_ids_.Get(index);
}
inline ::std::string* Message::mutable_ack_node_ids(int index) {
  return ack_node_ids_.Mutable(index);
}
inline void Message::set_ack_node_ids(int index, const ::std::string& value) {
  ack_node_ids_.Mutable(index)->assign(value);
}
inline void Message::set_ack_node_ids(int index, const char* value) {
  ack_node_ids_.Mutable(index)->assign(value);
}
inline void Message::set_ack_node_ids(int index, const void* value, size_t size) {
  ack_node_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::add_ack_node_ids() {
  return ack_node_ids_.Add();
}
inline void Message::add_ack_node_ids(const ::std::string& value) {
  ack_node_ids_.Add()->assign(value);
}
inline void Message::add_ack_node_ids(const char* value) {
  ack_node_ids_.Add()->assign(value);
}
inline void Message::add_ack_node_ids(const void* value, size_t size) {
  ack_node_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Message::ack_node_ids() const {
  return ack_node_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Message::mutable_ack_node_ids() {
  return &ack_node_ids_;
}

// -------------------------------------------------------------------

// SignedMessage

// required bytes message = 1;
inline bool SignedMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyString()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& SignedMessage::message() const {
  return *message_;
}
inline void SignedMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SignedMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SignedMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* SignedMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SignedMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes signature = 2;
inline bool SignedMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedMessage::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& SignedMessage::signature() const {
  return *signature_;
}
inline void SignedMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedMessage::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedMessage::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* SignedMessage::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SignedMessage::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes id = 3;
inline bool SignedMessage::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedMessage::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::GetEmptyString()) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SignedMessage::id() const {
  return *id_;
}
inline void SignedMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedMessage::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SignedMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SignedMessage::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ConnectRequest

// required .maidsafe.routing.protobuf.Contact contact = 1;
inline bool ConnectRequest::has_contact() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectRequest::set_has_contact() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectRequest::clear_has_contact() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectRequest::clear_contact() {
  if (contact_ != NULL) contact_->::maidsafe::routing::protobuf::Contact::Clear();
  clear_has_contact();
}
inline const ::maidsafe::routing::protobuf::Contact& ConnectRequest::contact() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return contact_ != NULL ? *contact_ : *default_instance().contact_;
#else
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
#endif
}
inline ::maidsafe::routing::protobuf::Contact* ConnectRequest::mutable_contact() {
  set_has_contact();
  if (contact_ == NULL) contact_ = new ::maidsafe::routing::protobuf::Contact;
  return contact_;
}
inline ::maidsafe::routing::protobuf::Contact* ConnectRequest::release_contact() {
  clear_has_contact();
  ::maidsafe::routing::protobuf::Contact* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline void ConnectRequest::set_allocated_contact(::maidsafe::routing::protobuf::Contact* contact) {
  delete contact_;
  contact_ = contact;
  if (contact) {
    set_has_contact();
  } else {
    clear_has_contact();
  }
}

// required bytes peer_id = 2;
inline bool ConnectRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectRequest::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::GetEmptyString()) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& ConnectRequest::peer_id() const {
  return *peer_id_;
}
inline void ConnectRequest::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void ConnectRequest::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void ConnectRequest::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectRequest::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* ConnectRequest::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectRequest::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool bootstrap = 3;
inline bool ConnectRequest::has_bootstrap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectRequest::set_has_bootstrap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectRequest::clear_has_bootstrap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectRequest::clear_bootstrap() {
  bootstrap_ = false;
  clear_has_bootstrap();
}
inline bool ConnectRequest::bootstrap() const {
  return bootstrap_;
}
inline void ConnectRequest::set_bootstrap(bool value) {
  set_has_bootstrap();
  bootstrap_ = value;
}

// optional uint64 timestamp = 4;
inline bool ConnectRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectRequest::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ConnectRequest::timestamp() const {
  return timestamp_;
}
inline void ConnectRequest::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// ConnectResponse

// required .maidsafe.routing.protobuf.ConnectResponseType answer = 1;
inline bool ConnectResponse::has_answer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectResponse::set_has_answer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectResponse::clear_has_answer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectResponse::clear_answer() {
  answer_ = 0;
  clear_has_answer();
}
inline ::maidsafe::routing::protobuf::ConnectResponseType ConnectResponse::answer() const {
  return static_cast< ::maidsafe::routing::protobuf::ConnectResponseType >(answer_);
}
inline void ConnectResponse::set_answer(::maidsafe::routing::protobuf::ConnectResponseType value) {
  assert(::maidsafe::routing::protobuf::ConnectResponseType_IsValid(value));
  set_has_answer();
  answer_ = value;
}

// optional .maidsafe.routing.protobuf.Contact contact = 2;
inline bool ConnectResponse::has_contact() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectResponse::set_has_contact() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectResponse::clear_has_contact() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectResponse::clear_contact() {
  if (contact_ != NULL) contact_->::maidsafe::routing::protobuf::Contact::Clear();
  clear_has_contact();
}
inline const ::maidsafe::routing::protobuf::Contact& ConnectResponse::contact() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return contact_ != NULL ? *contact_ : *default_instance().contact_;
#else
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
#endif
}
inline ::maidsafe::routing::protobuf::Contact* ConnectResponse::mutable_contact() {
  set_has_contact();
  if (contact_ == NULL) contact_ = new ::maidsafe::routing::protobuf::Contact;
  return contact_;
}
inline ::maidsafe::routing::protobuf::Contact* ConnectResponse::release_contact() {
  clear_has_contact();
  ::maidsafe::routing::protobuf::Contact* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_contact(::maidsafe::routing::protobuf::Contact* contact) {
  delete contact_;
  contact_ = contact;
  if (contact) {
    set_has_contact();
  } else {
    clear_has_contact();
  }
}

// optional bytes connection_id = 3;
inline bool ConnectResponse::has_connection_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectResponse::set_has_connection_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectResponse::clear_has_connection_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectResponse::clear_connection_id() {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    connection_id_->clear();
  }
  clear_has_connection_id();
}
inline const ::std::string& ConnectResponse::connection_id() const {
  return *connection_id_;
}
inline void ConnectResponse::set_connection_id(const ::std::string& value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ConnectResponse::set_connection_id(const char* value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ConnectResponse::set_connection_id(const void* value, size_t size) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_connection_id() {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  return connection_id_;
}
inline ::std::string* ConnectResponse::release_connection_id() {
  clear_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = connection_id_;
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectResponse::set_allocated_connection_id(::std::string* connection_id) {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete connection_id_;
  }
  if (connection_id) {
    set_has_connection_id();
    connection_id_ = connection_id;
  } else {
    clear_has_connection_id();
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .maidsafe.routing.protobuf.Endpoint seen_endpoint = 4;
inline bool ConnectResponse::has_seen_endpoint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectResponse::set_has_seen_endpoint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectResponse::clear_has_seen_endpoint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectResponse::clear_seen_endpoint() {
  if (seen_endpoint_ != NULL) seen_endpoint_->::maidsafe::routing::protobuf::Endpoint::Clear();
  clear_has_seen_endpoint();
}
inline const ::maidsafe::routing::protobuf::Endpoint& ConnectResponse::seen_endpoint() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return seen_endpoint_ != NULL ? *seen_endpoint_ : *default_instance().seen_endpoint_;
#else
  return seen_endpoint_ != NULL ? *seen_endpoint_ : *default_instance_->seen_endpoint_;
#endif
}
inline ::maidsafe::routing::protobuf::Endpoint* ConnectResponse::mutable_seen_endpoint() {
  set_has_seen_endpoint();
  if (seen_endpoint_ == NULL) seen_endpoint_ = new ::maidsafe::routing::protobuf::Endpoint;
  return seen_endpoint_;
}
inline ::maidsafe::routing::protobuf::Endpoint* ConnectResponse::release_seen_endpoint() {
  clear_has_seen_endpoint();
  ::maidsafe::routing::protobuf::Endpoint* temp = seen_endpoint_;
  seen_endpoint_ = NULL;
  return temp;
}
inline void ConnectResponse::set_allocated_seen_endpoint(::maidsafe::routing::protobuf::Endpoint* seen_endpoint) {
  delete seen_endpoint_;
  seen_endpoint_ = seen_endpoint;
  if (seen_endpoint) {
    set_has_seen_endpoint();
  } else {
    clear_has_seen_endpoint();
  }
}

// optional uint64 timestamp = 5;
inline bool ConnectResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectResponse::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ConnectResponse::timestamp() const {
  return timestamp_;
}
inline void ConnectResponse::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required bytes original_request = 6;
inline bool ConnectResponse::has_original_request() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConnectResponse::set_has_original_request() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConnectResponse::clear_has_original_request() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConnectResponse::clear_original_request() {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    original_request_->clear();
  }
  clear_has_original_request();
}
inline const ::std::string& ConnectResponse::original_request() const {
  return *original_request_;
}
inline void ConnectResponse::set_original_request(const ::std::string& value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void ConnectResponse::set_original_request(const char* value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void ConnectResponse::set_original_request(const void* value, size_t size) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_original_request() {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  return original_request_;
}
inline ::std::string* ConnectResponse::release_original_request() {
  clear_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_request_;
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectResponse::set_allocated_original_request(::std::string* original_request) {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_request_;
  }
  if (original_request) {
    set_has_original_request();
    original_request_ = original_request;
  } else {
    clear_has_original_request();
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes original_signature = 7;
inline bool ConnectResponse::has_original_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConnectResponse::set_has_original_signature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConnectResponse::clear_has_original_signature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConnectResponse::clear_original_signature() {
  if (original_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    original_signature_->clear();
  }
  clear_has_original_signature();
}
inline const ::std::string& ConnectResponse::original_signature() const {
  return *original_signature_;
}
inline void ConnectResponse::set_original_signature(const ::std::string& value) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(value);
}
inline void ConnectResponse::set_original_signature(const char* value) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(value);
}
inline void ConnectResponse::set_original_signature(const void* value, size_t size) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectResponse::mutable_original_signature() {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  return original_signature_;
}
inline ::std::string* ConnectResponse::release_original_signature() {
  clear_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_signature_;
    original_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectResponse::set_allocated_original_signature(::std::string* original_signature) {
  if (original_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_signature_;
  }
  if (original_signature) {
    set_has_original_signature();
    original_signature_ = original_signature;
  } else {
    clear_has_original_signature();
    original_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ConnectSuccess

// required bytes node_id = 1;
inline bool ConnectSuccess::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectSuccess::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectSuccess::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectSuccess::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& ConnectSuccess::node_id() const {
  return *node_id_;
}
inline void ConnectSuccess::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void ConnectSuccess::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void ConnectSuccess::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectSuccess::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* ConnectSuccess::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectSuccess::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes connection_id = 2;
inline bool ConnectSuccess::has_connection_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectSuccess::set_has_connection_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectSuccess::clear_has_connection_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectSuccess::clear_connection_id() {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    connection_id_->clear();
  }
  clear_has_connection_id();
}
inline const ::std::string& ConnectSuccess::connection_id() const {
  return *connection_id_;
}
inline void ConnectSuccess::set_connection_id(const ::std::string& value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ConnectSuccess::set_connection_id(const char* value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ConnectSuccess::set_connection_id(const void* value, size_t size) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectSuccess::mutable_connection_id() {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  return connection_id_;
}
inline ::std::string* ConnectSuccess::release_connection_id() {
  clear_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = connection_id_;
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectSuccess::set_allocated_connection_id(::std::string* connection_id) {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete connection_id_;
  }
  if (connection_id) {
    set_has_connection_id();
    connection_id_ = connection_id;
  } else {
    clear_has_connection_id();
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bool requestor = 3;
inline bool ConnectSuccess::has_requestor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectSuccess::set_has_requestor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectSuccess::clear_has_requestor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectSuccess::clear_requestor() {
  requestor_ = false;
  clear_has_requestor();
}
inline bool ConnectSuccess::requestor() const {
  return requestor_;
}
inline void ConnectSuccess::set_requestor(bool value) {
  set_has_requestor();
  requestor_ = value;
}

// -------------------------------------------------------------------

// ConnectSuccessAcknowledgement

// required bytes node_id = 1;
inline bool ConnectSuccessAcknowledgement::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectSuccessAcknowledgement::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectSuccessAcknowledgement::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectSuccessAcknowledgement::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& ConnectSuccessAcknowledgement::node_id() const {
  return *node_id_;
}
inline void ConnectSuccessAcknowledgement::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void ConnectSuccessAcknowledgement::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void ConnectSuccessAcknowledgement::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectSuccessAcknowledgement::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* ConnectSuccessAcknowledgement::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectSuccessAcknowledgement::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes connection_id = 2;
inline bool ConnectSuccessAcknowledgement::has_connection_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectSuccessAcknowledgement::set_has_connection_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectSuccessAcknowledgement::clear_has_connection_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectSuccessAcknowledgement::clear_connection_id() {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    connection_id_->clear();
  }
  clear_has_connection_id();
}
inline const ::std::string& ConnectSuccessAcknowledgement::connection_id() const {
  return *connection_id_;
}
inline void ConnectSuccessAcknowledgement::set_connection_id(const ::std::string& value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ConnectSuccessAcknowledgement::set_connection_id(const char* value) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(value);
}
inline void ConnectSuccessAcknowledgement::set_connection_id(const void* value, size_t size) {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  connection_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectSuccessAcknowledgement::mutable_connection_id() {
  set_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    connection_id_ = new ::std::string;
  }
  return connection_id_;
}
inline ::std::string* ConnectSuccessAcknowledgement::release_connection_id() {
  clear_has_connection_id();
  if (connection_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = connection_id_;
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ConnectSuccessAcknowledgement::set_allocated_connection_id(::std::string* connection_id) {
  if (connection_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete connection_id_;
  }
  if (connection_id) {
    set_has_connection_id();
    connection_id_ = connection_id;
  } else {
    clear_has_connection_id();
    connection_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated bytes close_ids = 3;
inline int ConnectSuccessAcknowledgement::close_ids_size() const {
  return close_ids_.size();
}
inline void ConnectSuccessAcknowledgement::clear_close_ids() {
  close_ids_.Clear();
}
inline const ::std::string& ConnectSuccessAcknowledgement::close_ids(int index) const {
  return close_ids_.Get(index);
}
inline ::std::string* ConnectSuccessAcknowledgement::mutable_close_ids(int index) {
  return close_ids_.Mutable(index);
}
inline void ConnectSuccessAcknowledgement::set_close_ids(int index, const ::std::string& value) {
  close_ids_.Mutable(index)->assign(value);
}
inline void ConnectSuccessAcknowledgement::set_close_ids(int index, const char* value) {
  close_ids_.Mutable(index)->assign(value);
}
inline void ConnectSuccessAcknowledgement::set_close_ids(int index, const void* value, size_t size) {
  close_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectSuccessAcknowledgement::add_close_ids() {
  return close_ids_.Add();
}
inline void ConnectSuccessAcknowledgement::add_close_ids(const ::std::string& value) {
  close_ids_.Add()->assign(value);
}
inline void ConnectSuccessAcknowledgement::add_close_ids(const char* value) {
  close_ids_.Add()->assign(value);
}
inline void ConnectSuccessAcknowledgement::add_close_ids(const void* value, size_t size) {
  close_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConnectSuccessAcknowledgement::close_ids() const {
  return close_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConnectSuccessAcknowledgement::mutable_close_ids() {
  return &close_ids_;
}

// required bool requestor = 4;
inline bool ConnectSuccessAcknowledgement::has_requestor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectSuccessAcknowledgement::set_has_requestor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectSuccessAcknowledgement::clear_has_requestor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectSuccessAcknowledgement::clear_requestor() {
  requestor_ = false;
  clear_has_requestor();
}
inline bool ConnectSuccessAcknowledgement::requestor() const {
  return requestor_;
}
inline void ConnectSuccessAcknowledgement::set_requestor(bool value) {
  set_has_requestor();
  requestor_ = value;
}

// -------------------------------------------------------------------

// FindNodesRequest

// required uint32 num_nodes_requested = 1;
inline bool FindNodesRequest::has_num_nodes_requested() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindNodesRequest::set_has_num_nodes_requested() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindNodesRequest::clear_has_num_nodes_requested() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindNodesRequest::clear_num_nodes_requested() {
  num_nodes_requested_ = 0u;
  clear_has_num_nodes_requested();
}
inline ::google::protobuf::uint32 FindNodesRequest::num_nodes_requested() const {
  return num_nodes_requested_;
}
inline void FindNodesRequest::set_num_nodes_requested(::google::protobuf::uint32 value) {
  set_has_num_nodes_requested();
  num_nodes_requested_ = value;
}

// optional uint64 timestamp = 2;
inline bool FindNodesRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindNodesRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindNodesRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindNodesRequest::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 FindNodesRequest::timestamp() const {
  return timestamp_;
}
inline void FindNodesRequest::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// FindNodesResponse

// repeated bytes nodes = 1;
inline int FindNodesResponse::nodes_size() const {
  return nodes_.size();
}
inline void FindNodesResponse::clear_nodes() {
  nodes_.Clear();
}
inline const ::std::string& FindNodesResponse::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::std::string* FindNodesResponse::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline void FindNodesResponse::set_nodes(int index, const ::std::string& value) {
  nodes_.Mutable(index)->assign(value);
}
inline void FindNodesResponse::set_nodes(int index, const char* value) {
  nodes_.Mutable(index)->assign(value);
}
inline void FindNodesResponse::set_nodes(int index, const void* value, size_t size) {
  nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindNodesResponse::add_nodes() {
  return nodes_.Add();
}
inline void FindNodesResponse::add_nodes(const ::std::string& value) {
  nodes_.Add()->assign(value);
}
inline void FindNodesResponse::add_nodes(const char* value) {
  nodes_.Add()->assign(value);
}
inline void FindNodesResponse::add_nodes(const void* value, size_t size) {
  nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindNodesResponse::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FindNodesResponse::mutable_nodes() {
  return &nodes_;
}

// optional uint64 timestamp = 2;
inline bool FindNodesResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindNodesResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindNodesResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindNodesResponse::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 FindNodesResponse::timestamp() const {
  return timestamp_;
}
inline void FindNodesResponse::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required bytes original_request = 3;
inline bool FindNodesResponse::has_original_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FindNodesResponse::set_has_original_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FindNodesResponse::clear_has_original_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FindNodesResponse::clear_original_request() {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    original_request_->clear();
  }
  clear_has_original_request();
}
inline const ::std::string& FindNodesResponse::original_request() const {
  return *original_request_;
}
inline void FindNodesResponse::set_original_request(const ::std::string& value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void FindNodesResponse::set_original_request(const char* value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void FindNodesResponse::set_original_request(const void* value, size_t size) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindNodesResponse::mutable_original_request() {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  return original_request_;
}
inline ::std::string* FindNodesResponse::release_original_request() {
  clear_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_request_;
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FindNodesResponse::set_allocated_original_request(::std::string* original_request) {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_request_;
  }
  if (original_request) {
    set_has_original_request();
    original_request_ = original_request;
  } else {
    clear_has_original_request();
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes original_signature = 4;
inline bool FindNodesResponse::has_original_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FindNodesResponse::set_has_original_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FindNodesResponse::clear_has_original_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FindNodesResponse::clear_original_signature() {
  if (original_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    original_signature_->clear();
  }
  clear_has_original_signature();
}
inline const ::std::string& FindNodesResponse::original_signature() const {
  return *original_signature_;
}
inline void FindNodesResponse::set_original_signature(const ::std::string& value) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(value);
}
inline void FindNodesResponse::set_original_signature(const char* value) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(value);
}
inline void FindNodesResponse::set_original_signature(const void* value, size_t size) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindNodesResponse::mutable_original_signature() {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  return original_signature_;
}
inline ::std::string* FindNodesResponse::release_original_signature() {
  clear_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_signature_;
    original_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void FindNodesResponse::set_allocated_original_signature(::std::string* original_signature) {
  if (original_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_signature_;
  }
  if (original_signature) {
    set_has_original_signature();
    original_signature_ = original_signature;
  } else {
    clear_has_original_signature();
    original_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// PingRequest

// required bool ping = 1;
inline bool PingRequest::has_ping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingRequest::set_has_ping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingRequest::clear_has_ping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingRequest::clear_ping() {
  ping_ = false;
  clear_has_ping();
}
inline bool PingRequest::ping() const {
  return ping_;
}
inline void PingRequest::set_ping(bool value) {
  set_has_ping();
  ping_ = value;
}

// optional uint64 timestamp = 2;
inline bool PingRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingRequest::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 PingRequest::timestamp() const {
  return timestamp_;
}
inline void PingRequest::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// PingResponse

// required bool pong = 1;
inline bool PingResponse::has_pong() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingResponse::set_has_pong() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingResponse::clear_has_pong() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingResponse::clear_pong() {
  pong_ = false;
  clear_has_pong();
}
inline bool PingResponse::pong() const {
  return pong_;
}
inline void PingResponse::set_pong(bool value) {
  set_has_pong();
  pong_ = value;
}

// optional uint64 timestamp = 2;
inline bool PingResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingResponse::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 PingResponse::timestamp() const {
  return timestamp_;
}
inline void PingResponse::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required bytes original_request = 3;
inline bool PingResponse::has_original_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PingResponse::set_has_original_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PingResponse::clear_has_original_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PingResponse::clear_original_request() {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    original_request_->clear();
  }
  clear_has_original_request();
}
inline const ::std::string& PingResponse::original_request() const {
  return *original_request_;
}
inline void PingResponse::set_original_request(const ::std::string& value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void PingResponse::set_original_request(const char* value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void PingResponse::set_original_request(const void* value, size_t size) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingResponse::mutable_original_request() {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  return original_request_;
}
inline ::std::string* PingResponse::release_original_request() {
  clear_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_request_;
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PingResponse::set_allocated_original_request(::std::string* original_request) {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_request_;
  }
  if (original_request) {
    set_has_original_request();
    original_request_ = original_request;
  } else {
    clear_has_original_request();
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes original_signature = 4;
inline bool PingResponse::has_original_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PingResponse::set_has_original_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PingResponse::clear_has_original_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PingResponse::clear_original_signature() {
  if (original_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    original_signature_->clear();
  }
  clear_has_original_signature();
}
inline const ::std::string& PingResponse::original_signature() const {
  return *original_signature_;
}
inline void PingResponse::set_original_signature(const ::std::string& value) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(value);
}
inline void PingResponse::set_original_signature(const char* value) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(value);
}
inline void PingResponse::set_original_signature(const void* value, size_t size) {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  original_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PingResponse::mutable_original_signature() {
  set_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    original_signature_ = new ::std::string;
  }
  return original_signature_;
}
inline ::std::string* PingResponse::release_original_signature() {
  clear_has_original_signature();
  if (original_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_signature_;
    original_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PingResponse::set_allocated_original_signature(::std::string* original_signature) {
  if (original_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_signature_;
  }
  if (original_signature) {
    set_has_original_signature();
    original_signature_ = original_signature;
  } else {
    clear_has_original_signature();
    original_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// RemoveRequest

// required bytes peer_id = 1;
inline bool RemoveRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveRequest::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::GetEmptyString()) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& RemoveRequest::peer_id() const {
  return *peer_id_;
}
inline void RemoveRequest::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void RemoveRequest::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void RemoveRequest::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveRequest::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* RemoveRequest::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RemoveRequest::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated bytes attempted_nodes = 2;
inline int RemoveRequest::attempted_nodes_size() const {
  return attempted_nodes_.size();
}
inline void RemoveRequest::clear_attempted_nodes() {
  attempted_nodes_.Clear();
}
inline const ::std::string& RemoveRequest::attempted_nodes(int index) const {
  return attempted_nodes_.Get(index);
}
inline ::std::string* RemoveRequest::mutable_attempted_nodes(int index) {
  return attempted_nodes_.Mutable(index);
}
inline void RemoveRequest::set_attempted_nodes(int index, const ::std::string& value) {
  attempted_nodes_.Mutable(index)->assign(value);
}
inline void RemoveRequest::set_attempted_nodes(int index, const char* value) {
  attempted_nodes_.Mutable(index)->assign(value);
}
inline void RemoveRequest::set_attempted_nodes(int index, const void* value, size_t size) {
  attempted_nodes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveRequest::add_attempted_nodes() {
  return attempted_nodes_.Add();
}
inline void RemoveRequest::add_attempted_nodes(const ::std::string& value) {
  attempted_nodes_.Add()->assign(value);
}
inline void RemoveRequest::add_attempted_nodes(const char* value) {
  attempted_nodes_.Add()->assign(value);
}
inline void RemoveRequest::add_attempted_nodes(const void* value, size_t size) {
  attempted_nodes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RemoveRequest::attempted_nodes() const {
  return attempted_nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RemoveRequest::mutable_attempted_nodes() {
  return &attempted_nodes_;
}

// -------------------------------------------------------------------

// RemoveResponse

// required bool success = 1;
inline bool RemoveResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoveResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoveResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoveResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool RemoveResponse::success() const {
  return success_;
}
inline void RemoveResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required bytes peer_id = 2;
inline bool RemoveResponse::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoveResponse::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoveResponse::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoveResponse::clear_peer_id() {
  if (peer_id_ != &::google::protobuf::internal::GetEmptyString()) {
    peer_id_->clear();
  }
  clear_has_peer_id();
}
inline const ::std::string& RemoveResponse::peer_id() const {
  return *peer_id_;
}
inline void RemoveResponse::set_peer_id(const ::std::string& value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void RemoveResponse::set_peer_id(const char* value) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(value);
}
inline void RemoveResponse::set_peer_id(const void* value, size_t size) {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  peer_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveResponse::mutable_peer_id() {
  set_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    peer_id_ = new ::std::string;
  }
  return peer_id_;
}
inline ::std::string* RemoveResponse::release_peer_id() {
  clear_has_peer_id();
  if (peer_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = peer_id_;
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RemoveResponse::set_allocated_peer_id(::std::string* peer_id) {
  if (peer_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete peer_id_;
  }
  if (peer_id) {
    set_has_peer_id();
    peer_id_ = peer_id;
  } else {
    clear_has_peer_id();
    peer_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes original_request = 3;
inline bool RemoveResponse::has_original_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoveResponse::set_has_original_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoveResponse::clear_has_original_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoveResponse::clear_original_request() {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    original_request_->clear();
  }
  clear_has_original_request();
}
inline const ::std::string& RemoveResponse::original_request() const {
  return *original_request_;
}
inline void RemoveResponse::set_original_request(const ::std::string& value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void RemoveResponse::set_original_request(const char* value) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(value);
}
inline void RemoveResponse::set_original_request(const void* value, size_t size) {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  original_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveResponse::mutable_original_request() {
  set_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    original_request_ = new ::std::string;
  }
  return original_request_;
}
inline ::std::string* RemoveResponse::release_original_request() {
  clear_has_original_request();
  if (original_request_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = original_request_;
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void RemoveResponse::set_allocated_original_request(::std::string* original_request) {
  if (original_request_ != &::google::protobuf::internal::GetEmptyString()) {
    delete original_request_;
  }
  if (original_request) {
    set_has_original_request();
    original_request_ = original_request;
  } else {
    clear_has_original_request();
    original_request_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// NodeIdList_NodeId

// required bytes node_id = 1;
inline bool NodeIdList_NodeId::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeIdList_NodeId::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeIdList_NodeId::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeIdList_NodeId::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeIdList_NodeId::node_id() const {
  return *node_id_;
}
inline void NodeIdList_NodeId::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeIdList_NodeId::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeIdList_NodeId::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeIdList_NodeId::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeIdList_NodeId::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NodeIdList_NodeId::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// NodeIdList

// repeated .maidsafe.routing.protobuf.NodeIdList.NodeId node_id_list = 1;
inline int NodeIdList::node_id_list_size() const {
  return node_id_list_.size();
}
inline void NodeIdList::clear_node_id_list() {
  node_id_list_.Clear();
}
inline const ::maidsafe::routing::protobuf::NodeIdList_NodeId& NodeIdList::node_id_list(int index) const {
  return node_id_list_.Get(index);
}
inline ::maidsafe::routing::protobuf::NodeIdList_NodeId* NodeIdList::mutable_node_id_list(int index) {
  return node_id_list_.Mutable(index);
}
inline ::maidsafe::routing::protobuf::NodeIdList_NodeId* NodeIdList::add_node_id_list() {
  return node_id_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::NodeIdList_NodeId >&
NodeIdList::node_id_list() const {
  return node_id_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::NodeIdList_NodeId >*
NodeIdList::mutable_node_id_list() {
  return &node_id_list_;
}

// -------------------------------------------------------------------

// BasicNodeInfo

// required bytes node_id = 1;
inline bool BasicNodeInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasicNodeInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasicNodeInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasicNodeInfo::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& BasicNodeInfo::node_id() const {
  return *node_id_;
}
inline void BasicNodeInfo::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void BasicNodeInfo::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void BasicNodeInfo::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BasicNodeInfo::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* BasicNodeInfo::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void BasicNodeInfo::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 rank = 2;
inline bool BasicNodeInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasicNodeInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasicNodeInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasicNodeInfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 BasicNodeInfo::rank() const {
  return rank_;
}
inline void BasicNodeInfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// -------------------------------------------------------------------

// ClosestNodesUpdate

// required bytes node = 1;
inline bool ClosestNodesUpdate::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClosestNodesUpdate::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClosestNodesUpdate::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClosestNodesUpdate::clear_node() {
  if (node_ != &::google::protobuf::internal::GetEmptyString()) {
    node_->clear();
  }
  clear_has_node();
}
inline const ::std::string& ClosestNodesUpdate::node() const {
  return *node_;
}
inline void ClosestNodesUpdate::set_node(const ::std::string& value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyString()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void ClosestNodesUpdate::set_node(const char* value) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyString()) {
    node_ = new ::std::string;
  }
  node_->assign(value);
}
inline void ClosestNodesUpdate::set_node(const void* value, size_t size) {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyString()) {
    node_ = new ::std::string;
  }
  node_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClosestNodesUpdate::mutable_node() {
  set_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyString()) {
    node_ = new ::std::string;
  }
  return node_;
}
inline ::std::string* ClosestNodesUpdate::release_node() {
  clear_has_node();
  if (node_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_;
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClosestNodesUpdate::set_allocated_node(::std::string* node) {
  if (node_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_;
  }
  if (node) {
    set_has_node();
    node_ = node;
  } else {
    clear_has_node();
    node_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .maidsafe.routing.protobuf.BasicNodeInfo nodes_info = 2;
inline int ClosestNodesUpdate::nodes_info_size() const {
  return nodes_info_.size();
}
inline void ClosestNodesUpdate::clear_nodes_info() {
  nodes_info_.Clear();
}
inline const ::maidsafe::routing::protobuf::BasicNodeInfo& ClosestNodesUpdate::nodes_info(int index) const {
  return nodes_info_.Get(index);
}
inline ::maidsafe::routing::protobuf::BasicNodeInfo* ClosestNodesUpdate::mutable_nodes_info(int index) {
  return nodes_info_.Mutable(index);
}
inline ::maidsafe::routing::protobuf::BasicNodeInfo* ClosestNodesUpdate::add_nodes_info() {
  return nodes_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::BasicNodeInfo >&
ClosestNodesUpdate::nodes_info() const {
  return nodes_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::routing::protobuf::BasicNodeInfo >*
ClosestNodesUpdate::mutable_nodes_info() {
  return &nodes_info_;
}

// -------------------------------------------------------------------

// InformClientOfhNewCloseNode

// required bytes node_id = 1;
inline bool InformClientOfhNewCloseNode::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InformClientOfhNewCloseNode::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InformClientOfhNewCloseNode::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InformClientOfhNewCloseNode::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& InformClientOfhNewCloseNode::node_id() const {
  return *node_id_;
}
inline void InformClientOfhNewCloseNode::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void InformClientOfhNewCloseNode::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void InformClientOfhNewCloseNode::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InformClientOfhNewCloseNode::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* InformClientOfhNewCloseNode::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void InformClientOfhNewCloseNode::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GetGroup

// required bytes node_id = 1;
inline bool GetGroup::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroup::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroup::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroup::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& GetGroup::node_id() const {
  return *node_id_;
}
inline void GetGroup::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void GetGroup::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void GetGroup::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetGroup::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* GetGroup::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetGroup::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated bytes group_nodes_id = 2;
inline int GetGroup::group_nodes_id_size() const {
  return group_nodes_id_.size();
}
inline void GetGroup::clear_group_nodes_id() {
  group_nodes_id_.Clear();
}
inline const ::std::string& GetGroup::group_nodes_id(int index) const {
  return group_nodes_id_.Get(index);
}
inline ::std::string* GetGroup::mutable_group_nodes_id(int index) {
  return group_nodes_id_.Mutable(index);
}
inline void GetGroup::set_group_nodes_id(int index, const ::std::string& value) {
  group_nodes_id_.Mutable(index)->assign(value);
}
inline void GetGroup::set_group_nodes_id(int index, const char* value) {
  group_nodes_id_.Mutable(index)->assign(value);
}
inline void GetGroup::set_group_nodes_id(int index, const void* value, size_t size) {
  group_nodes_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetGroup::add_group_nodes_id() {
  return group_nodes_id_.Add();
}
inline void GetGroup::add_group_nodes_id(const ::std::string& value) {
  group_nodes_id_.Add()->assign(value);
}
inline void GetGroup::add_group_nodes_id(const char* value) {
  group_nodes_id_.Add()->assign(value);
}
inline void GetGroup::add_group_nodes_id(const void* value, size_t size) {
  group_nodes_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetGroup::group_nodes_id() const {
  return group_nodes_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetGroup::mutable_group_nodes_id() {
  return &group_nodes_id_;
}

// -------------------------------------------------------------------

// NodeInfo

// required bytes node_id = 1;
inline bool NodeInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInfo::clear_node_id() {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    node_id_->clear();
  }
  clear_has_node_id();
}
inline const ::std::string& NodeInfo::node_id() const {
  return *node_id_;
}
inline void NodeInfo::set_node_id(const ::std::string& value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeInfo::set_node_id(const char* value) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(value);
}
inline void NodeInfo::set_node_id(const void* value, size_t size) {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  node_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeInfo::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    node_id_ = new ::std::string;
  }
  return node_id_;
}
inline ::std::string* NodeInfo::release_node_id() {
  clear_has_node_id();
  if (node_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = node_id_;
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NodeInfo::set_allocated_node_id(::std::string* node_id) {
  if (node_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete node_id_;
  }
  if (node_id) {
    set_has_node_id();
    node_id_ = node_id;
  } else {
    clear_has_node_id();
    node_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int32 rank = 2;
inline bool NodeInfo::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInfo::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 NodeInfo::rank() const {
  return rank_;
}
inline void NodeInfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// repeated int32 dimension_list = 3;
inline int NodeInfo::dimension_list_size() const {
  return dimension_list_.size();
}
inline void NodeInfo::clear_dimension_list() {
  dimension_list_.Clear();
}
inline ::google::protobuf::int32 NodeInfo::dimension_list(int index) const {
  return dimension_list_.Get(index);
}
inline void NodeInfo::set_dimension_list(int index, ::google::protobuf::int32 value) {
  dimension_list_.Set(index, value);
}
inline void NodeInfo::add_dimension_list(::google::protobuf::int32 value) {
  dimension_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NodeInfo::dimension_list() const {
  return dimension_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NodeInfo::mutable_dimension_list() {
  return &dimension_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace routing
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_maidsafe_2frouting_2frouting_2eproto__INCLUDED
