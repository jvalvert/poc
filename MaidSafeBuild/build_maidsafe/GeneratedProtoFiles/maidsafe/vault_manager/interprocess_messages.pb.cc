// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/vault_manager/interprocess_messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "maidsafe/vault_manager/interprocess_messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace vault_manager {
namespace protobuf {

void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto() {
  delete WrapperMessage::default_instance_;
  delete Challenge::default_instance_;
  delete ChallengeResponse::default_instance_;
  delete PublicPmidList::default_instance_;
  delete PublicPmidList_PublicPmid::default_instance_;
  delete StartVaultRequest::default_instance_;
  delete TakeOwnershipRequest::default_instance_;
  delete VaultRunningResponse::default_instance_;
  delete VaultRunningResponse_VaultKeys::default_instance_;
  delete VaultStarted::default_instance_;
  delete VaultStartedResponse::default_instance_;
  delete MaxDiskUsageUpdate::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  WrapperMessage::default_instance_ = new WrapperMessage();
  Challenge::default_instance_ = new Challenge();
  ChallengeResponse::default_instance_ = new ChallengeResponse();
  PublicPmidList::default_instance_ = new PublicPmidList();
  PublicPmidList_PublicPmid::default_instance_ = new PublicPmidList_PublicPmid();
  StartVaultRequest::default_instance_ = new StartVaultRequest();
  TakeOwnershipRequest::default_instance_ = new TakeOwnershipRequest();
  VaultRunningResponse::default_instance_ = new VaultRunningResponse();
  VaultRunningResponse_VaultKeys::default_instance_ = new VaultRunningResponse_VaultKeys();
  VaultStarted::default_instance_ = new VaultStarted();
  VaultStartedResponse::default_instance_ = new VaultStartedResponse();
  MaxDiskUsageUpdate::default_instance_ = new MaxDiskUsageUpdate();
  WrapperMessage::default_instance_->InitAsDefaultInstance();
  Challenge::default_instance_->InitAsDefaultInstance();
  ChallengeResponse::default_instance_->InitAsDefaultInstance();
  PublicPmidList::default_instance_->InitAsDefaultInstance();
  PublicPmidList_PublicPmid::default_instance_->InitAsDefaultInstance();
  StartVaultRequest::default_instance_->InitAsDefaultInstance();
  TakeOwnershipRequest::default_instance_->InitAsDefaultInstance();
  VaultRunningResponse::default_instance_->InitAsDefaultInstance();
  VaultRunningResponse_VaultKeys::default_instance_->InitAsDefaultInstance();
  VaultStarted::default_instance_->InitAsDefaultInstance();
  VaultStartedResponse::default_instance_->InitAsDefaultInstance();
  MaxDiskUsageUpdate::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_once_);
void protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_once_,
                 &protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto {
  StaticDescriptorInitializer_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto() {
    protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  }
} static_descriptor_initializer_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
const int WrapperMessage::kTypeFieldNumber;
const int WrapperMessage::kPayloadFieldNumber;
const int WrapperMessage::kMessageSignatureFieldNumber;
#endif  // !_MSC_VER

WrapperMessage::WrapperMessage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void WrapperMessage::InitAsDefaultInstance() {
}

WrapperMessage::WrapperMessage(const WrapperMessage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void WrapperMessage::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  message_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WrapperMessage::~WrapperMessage() {
  SharedDtor();
}

void WrapperMessage::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::GetEmptyString()) {
    delete payload_;
  }
  if (message_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void WrapperMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WrapperMessage& WrapperMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

WrapperMessage* WrapperMessage::default_instance_ = NULL;

WrapperMessage* WrapperMessage::New() const {
  return new WrapperMessage;
}

void WrapperMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::GetEmptyString()) {
        payload_->clear();
      }
    }
    if (has_message_signature()) {
      if (message_signature_ != &::google::protobuf::internal::GetEmptyString()) {
        message_signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool WrapperMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        break;
      }

      // optional bytes payload = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message_signature;
        break;
      }

      // optional bytes message_signature = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WrapperMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional bytes payload = 2;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->payload(), output);
  }

  // optional bytes message_signature = 3;
  if (has_message_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->message_signature(), output);
  }

}

int WrapperMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional bytes payload = 2;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional bytes message_signature = 3;
    if (has_message_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message_signature());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WrapperMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WrapperMessage*>(&from));
}

void WrapperMessage::MergeFrom(const WrapperMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
    if (from.has_message_signature()) {
      set_message_signature(from.message_signature());
    }
  }
}

void WrapperMessage::CopyFrom(const WrapperMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WrapperMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WrapperMessage::Swap(WrapperMessage* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(payload_, other->payload_);
    std::swap(message_signature_, other->message_signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string WrapperMessage::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.WrapperMessage";
}


// ===================================================================

#ifndef _MSC_VER
const int Challenge::kPlaintextFieldNumber;
#endif  // !_MSC_VER

Challenge::Challenge()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Challenge::InitAsDefaultInstance() {
}

Challenge::Challenge(const Challenge& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Challenge::SharedCtor() {
  _cached_size_ = 0;
  plaintext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Challenge::~Challenge() {
  SharedDtor();
}

void Challenge::SharedDtor() {
  if (plaintext_ != &::google::protobuf::internal::GetEmptyString()) {
    delete plaintext_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Challenge::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Challenge& Challenge::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

Challenge* Challenge::default_instance_ = NULL;

Challenge* Challenge::New() const {
  return new Challenge;
}

void Challenge::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_plaintext()) {
      if (plaintext_ != &::google::protobuf::internal::GetEmptyString()) {
        plaintext_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Challenge::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes plaintext = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_plaintext()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Challenge::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes plaintext = 1;
  if (has_plaintext()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->plaintext(), output);
  }

}

int Challenge::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes plaintext = 1;
    if (has_plaintext()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->plaintext());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Challenge::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Challenge*>(&from));
}

void Challenge::MergeFrom(const Challenge& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_plaintext()) {
      set_plaintext(from.plaintext());
    }
  }
}

void Challenge::CopyFrom(const Challenge& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Challenge::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Challenge::Swap(Challenge* other) {
  if (other != this) {
    std::swap(plaintext_, other->plaintext_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Challenge::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.Challenge";
}


// ===================================================================

#ifndef _MSC_VER
const int ChallengeResponse::kPublicMaidNameFieldNumber;
const int ChallengeResponse::kPublicMaidValueFieldNumber;
const int ChallengeResponse::kSignatureFieldNumber;
#endif  // !_MSC_VER

ChallengeResponse::ChallengeResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ChallengeResponse::InitAsDefaultInstance() {
}

ChallengeResponse::ChallengeResponse(const ChallengeResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ChallengeResponse::SharedCtor() {
  _cached_size_ = 0;
  public_maid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  public_maid_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChallengeResponse::~ChallengeResponse() {
  SharedDtor();
}

void ChallengeResponse::SharedDtor() {
  if (public_maid_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_maid_name_;
  }
  if (public_maid_value_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_maid_value_;
  }
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete signature_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChallengeResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChallengeResponse& ChallengeResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

ChallengeResponse* ChallengeResponse::default_instance_ = NULL;

ChallengeResponse* ChallengeResponse::New() const {
  return new ChallengeResponse;
}

void ChallengeResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_public_maid_name()) {
      if (public_maid_name_ != &::google::protobuf::internal::GetEmptyString()) {
        public_maid_name_->clear();
      }
    }
    if (has_public_maid_value()) {
      if (public_maid_value_ != &::google::protobuf::internal::GetEmptyString()) {
        public_maid_value_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ChallengeResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes public_maid_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_maid_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_public_maid_value;
        break;
      }

      // required bytes public_maid_value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_maid_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_maid_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_signature;
        break;
      }

      // required bytes signature = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChallengeResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes public_maid_name = 1;
  if (has_public_maid_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->public_maid_name(), output);
  }

  // required bytes public_maid_value = 2;
  if (has_public_maid_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->public_maid_value(), output);
  }

  // required bytes signature = 3;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->signature(), output);
  }

}

int ChallengeResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes public_maid_name = 1;
    if (has_public_maid_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_maid_name());
    }

    // required bytes public_maid_value = 2;
    if (has_public_maid_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_maid_value());
    }

    // required bytes signature = 3;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChallengeResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChallengeResponse*>(&from));
}

void ChallengeResponse::MergeFrom(const ChallengeResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_maid_name()) {
      set_public_maid_name(from.public_maid_name());
    }
    if (from.has_public_maid_value()) {
      set_public_maid_value(from.public_maid_value());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
}

void ChallengeResponse::CopyFrom(const ChallengeResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChallengeResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ChallengeResponse::Swap(ChallengeResponse* other) {
  if (other != this) {
    std::swap(public_maid_name_, other->public_maid_name_);
    std::swap(public_maid_value_, other->public_maid_value_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ChallengeResponse::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.ChallengeResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int PublicPmidList_PublicPmid::kPublicPmidNameFieldNumber;
const int PublicPmidList_PublicPmid::kPublicPmidFieldNumber;
#endif  // !_MSC_VER

PublicPmidList_PublicPmid::PublicPmidList_PublicPmid()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PublicPmidList_PublicPmid::InitAsDefaultInstance() {
}

PublicPmidList_PublicPmid::PublicPmidList_PublicPmid(const PublicPmidList_PublicPmid& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PublicPmidList_PublicPmid::SharedCtor() {
  _cached_size_ = 0;
  public_pmid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  public_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PublicPmidList_PublicPmid::~PublicPmidList_PublicPmid() {
  SharedDtor();
}

void PublicPmidList_PublicPmid::SharedDtor() {
  if (public_pmid_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_pmid_name_;
  }
  if (public_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_pmid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PublicPmidList_PublicPmid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PublicPmidList_PublicPmid& PublicPmidList_PublicPmid::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

PublicPmidList_PublicPmid* PublicPmidList_PublicPmid::default_instance_ = NULL;

PublicPmidList_PublicPmid* PublicPmidList_PublicPmid::New() const {
  return new PublicPmidList_PublicPmid;
}

void PublicPmidList_PublicPmid::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_public_pmid_name()) {
      if (public_pmid_name_ != &::google::protobuf::internal::GetEmptyString()) {
        public_pmid_name_->clear();
      }
    }
    if (has_public_pmid()) {
      if (public_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
        public_pmid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PublicPmidList_PublicPmid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes public_pmid_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_pmid_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_public_pmid;
        break;
      }

      // required bytes public_pmid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_pmid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_pmid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PublicPmidList_PublicPmid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes public_pmid_name = 1;
  if (has_public_pmid_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->public_pmid_name(), output);
  }

  // required bytes public_pmid = 2;
  if (has_public_pmid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->public_pmid(), output);
  }

}

int PublicPmidList_PublicPmid::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes public_pmid_name = 1;
    if (has_public_pmid_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_pmid_name());
    }

    // required bytes public_pmid = 2;
    if (has_public_pmid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_pmid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicPmidList_PublicPmid::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PublicPmidList_PublicPmid*>(&from));
}

void PublicPmidList_PublicPmid::MergeFrom(const PublicPmidList_PublicPmid& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_pmid_name()) {
      set_public_pmid_name(from.public_pmid_name());
    }
    if (from.has_public_pmid()) {
      set_public_pmid(from.public_pmid());
    }
  }
}

void PublicPmidList_PublicPmid::CopyFrom(const PublicPmidList_PublicPmid& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicPmidList_PublicPmid::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PublicPmidList_PublicPmid::Swap(PublicPmidList_PublicPmid* other) {
  if (other != this) {
    std::swap(public_pmid_name_, other->public_pmid_name_);
    std::swap(public_pmid_, other->public_pmid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PublicPmidList_PublicPmid::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int PublicPmidList::kPublicPmidsFieldNumber;
#endif  // !_MSC_VER

PublicPmidList::PublicPmidList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PublicPmidList::InitAsDefaultInstance() {
}

PublicPmidList::PublicPmidList(const PublicPmidList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PublicPmidList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PublicPmidList::~PublicPmidList() {
  SharedDtor();
}

void PublicPmidList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PublicPmidList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PublicPmidList& PublicPmidList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

PublicPmidList* PublicPmidList::default_instance_ = NULL;

PublicPmidList* PublicPmidList::New() const {
  return new PublicPmidList;
}

void PublicPmidList::Clear() {
  public_pmids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PublicPmidList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid public_pmids = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_pmids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_public_pmids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_public_pmids;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PublicPmidList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid public_pmids = 1;
  for (int i = 0; i < this->public_pmids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->public_pmids(i), output);
  }

}

int PublicPmidList::ByteSize() const {
  int total_size = 0;

  // repeated .maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid public_pmids = 1;
  total_size += 1 * this->public_pmids_size();
  for (int i = 0; i < this->public_pmids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->public_pmids(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicPmidList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PublicPmidList*>(&from));
}

void PublicPmidList::MergeFrom(const PublicPmidList& from) {
  GOOGLE_CHECK_NE(&from, this);
  public_pmids_.MergeFrom(from.public_pmids_);
}

void PublicPmidList::CopyFrom(const PublicPmidList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicPmidList::IsInitialized() const {

  for (int i = 0; i < public_pmids_size(); i++) {
    if (!this->public_pmids(i).IsInitialized()) return false;
  }
  return true;
}

void PublicPmidList::Swap(PublicPmidList* other) {
  if (other != this) {
    public_pmids_.Swap(&other->public_pmids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PublicPmidList::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.PublicPmidList";
}


// ===================================================================

#ifndef _MSC_VER
const int StartVaultRequest::kLabelFieldNumber;
const int StartVaultRequest::kVaultDirFieldNumber;
const int StartVaultRequest::kMaxDiskUsageFieldNumber;
const int StartVaultRequest::kVlogSessionIdFieldNumber;
const int StartVaultRequest::kSendHostnameToVisualiserServerFieldNumber;
const int StartVaultRequest::kPmidListIndexFieldNumber;
#endif  // !_MSC_VER

StartVaultRequest::StartVaultRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartVaultRequest::InitAsDefaultInstance() {
}

StartVaultRequest::StartVaultRequest(const StartVaultRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartVaultRequest::SharedCtor() {
  _cached_size_ = 0;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  vlog_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  send_hostname_to_visualiser_server_ = false;
  pmid_list_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartVaultRequest::~StartVaultRequest() {
  SharedDtor();
}

void StartVaultRequest::SharedDtor() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vault_dir_;
  }
  if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vlog_session_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartVaultRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartVaultRequest& StartVaultRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

StartVaultRequest* StartVaultRequest::default_instance_ = NULL;

StartVaultRequest* StartVaultRequest::New() const {
  return new StartVaultRequest;
}

void StartVaultRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::GetEmptyString()) {
        label_->clear();
      }
    }
    if (has_vault_dir()) {
      if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
        vault_dir_->clear();
      }
    }
    max_disk_usage_ = GOOGLE_ULONGLONG(0);
    if (has_vlog_session_id()) {
      if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
        vlog_session_id_->clear();
      }
    }
    send_hostname_to_visualiser_server_ = false;
    pmid_list_index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartVaultRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes label = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_vault_dir;
        break;
      }

      // optional bytes vault_dir = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vault_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vault_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_max_disk_usage;
        break;
      }

      // required uint64 max_disk_usage = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_disk_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_disk_usage_)));
          set_has_max_disk_usage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_vlog_session_id;
        break;
      }

      // optional bytes vlog_session_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vlog_session_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vlog_session_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_send_hostname_to_visualiser_server;
        break;
      }

      // optional bool send_hostname_to_visualiser_server = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_send_hostname_to_visualiser_server:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &send_hostname_to_visualiser_server_)));
          set_has_send_hostname_to_visualiser_server();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_pmid_list_index;
        break;
      }

      // optional int32 pmid_list_index = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pmid_list_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pmid_list_index_)));
          set_has_pmid_list_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartVaultRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes label = 1;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->label(), output);
  }

  // optional bytes vault_dir = 2;
  if (has_vault_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->vault_dir(), output);
  }

  // required uint64 max_disk_usage = 3;
  if (has_max_disk_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->max_disk_usage(), output);
  }

  // optional bytes vlog_session_id = 4;
  if (has_vlog_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->vlog_session_id(), output);
  }

  // optional bool send_hostname_to_visualiser_server = 5;
  if (has_send_hostname_to_visualiser_server()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->send_hostname_to_visualiser_server(), output);
  }

  // optional int32 pmid_list_index = 6;
  if (has_pmid_list_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->pmid_list_index(), output);
  }

}

int StartVaultRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes label = 1;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->label());
    }

    // optional bytes vault_dir = 2;
    if (has_vault_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vault_dir());
    }

    // required uint64 max_disk_usage = 3;
    if (has_max_disk_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_disk_usage());
    }

    // optional bytes vlog_session_id = 4;
    if (has_vlog_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vlog_session_id());
    }

    // optional bool send_hostname_to_visualiser_server = 5;
    if (has_send_hostname_to_visualiser_server()) {
      total_size += 1 + 1;
    }

    // optional int32 pmid_list_index = 6;
    if (has_pmid_list_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pmid_list_index());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartVaultRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartVaultRequest*>(&from));
}

void StartVaultRequest::MergeFrom(const StartVaultRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_vault_dir()) {
      set_vault_dir(from.vault_dir());
    }
    if (from.has_max_disk_usage()) {
      set_max_disk_usage(from.max_disk_usage());
    }
    if (from.has_vlog_session_id()) {
      set_vlog_session_id(from.vlog_session_id());
    }
    if (from.has_send_hostname_to_visualiser_server()) {
      set_send_hostname_to_visualiser_server(from.send_hostname_to_visualiser_server());
    }
    if (from.has_pmid_list_index()) {
      set_pmid_list_index(from.pmid_list_index());
    }
  }
}

void StartVaultRequest::CopyFrom(const StartVaultRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartVaultRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;

  return true;
}

void StartVaultRequest::Swap(StartVaultRequest* other) {
  if (other != this) {
    std::swap(label_, other->label_);
    std::swap(vault_dir_, other->vault_dir_);
    std::swap(max_disk_usage_, other->max_disk_usage_);
    std::swap(vlog_session_id_, other->vlog_session_id_);
    std::swap(send_hostname_to_visualiser_server_, other->send_hostname_to_visualiser_server_);
    std::swap(pmid_list_index_, other->pmid_list_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartVaultRequest::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.StartVaultRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int TakeOwnershipRequest::kLabelFieldNumber;
const int TakeOwnershipRequest::kVaultDirFieldNumber;
const int TakeOwnershipRequest::kMaxDiskUsageFieldNumber;
#endif  // !_MSC_VER

TakeOwnershipRequest::TakeOwnershipRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TakeOwnershipRequest::InitAsDefaultInstance() {
}

TakeOwnershipRequest::TakeOwnershipRequest(const TakeOwnershipRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TakeOwnershipRequest::SharedCtor() {
  _cached_size_ = 0;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TakeOwnershipRequest::~TakeOwnershipRequest() {
  SharedDtor();
}

void TakeOwnershipRequest::SharedDtor() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vault_dir_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TakeOwnershipRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TakeOwnershipRequest& TakeOwnershipRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

TakeOwnershipRequest* TakeOwnershipRequest::default_instance_ = NULL;

TakeOwnershipRequest* TakeOwnershipRequest::New() const {
  return new TakeOwnershipRequest;
}

void TakeOwnershipRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::GetEmptyString()) {
        label_->clear();
      }
    }
    if (has_vault_dir()) {
      if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
        vault_dir_->clear();
      }
    }
    max_disk_usage_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TakeOwnershipRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes label = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_vault_dir;
        break;
      }

      // required bytes vault_dir = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vault_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vault_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_max_disk_usage;
        break;
      }

      // required uint64 max_disk_usage = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_disk_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_disk_usage_)));
          set_has_max_disk_usage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TakeOwnershipRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes label = 1;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->label(), output);
  }

  // required bytes vault_dir = 2;
  if (has_vault_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->vault_dir(), output);
  }

  // required uint64 max_disk_usage = 3;
  if (has_max_disk_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->max_disk_usage(), output);
  }

}

int TakeOwnershipRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes label = 1;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->label());
    }

    // required bytes vault_dir = 2;
    if (has_vault_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vault_dir());
    }

    // required uint64 max_disk_usage = 3;
    if (has_max_disk_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_disk_usage());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TakeOwnershipRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TakeOwnershipRequest*>(&from));
}

void TakeOwnershipRequest::MergeFrom(const TakeOwnershipRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_vault_dir()) {
      set_vault_dir(from.vault_dir());
    }
    if (from.has_max_disk_usage()) {
      set_max_disk_usage(from.max_disk_usage());
    }
  }
}

void TakeOwnershipRequest::CopyFrom(const TakeOwnershipRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeOwnershipRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void TakeOwnershipRequest::Swap(TakeOwnershipRequest* other) {
  if (other != this) {
    std::swap(label_, other->label_);
    std::swap(vault_dir_, other->vault_dir_);
    std::swap(max_disk_usage_, other->max_disk_usage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TakeOwnershipRequest::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.TakeOwnershipRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int VaultRunningResponse_VaultKeys::kAES256KeyFieldNumber;
const int VaultRunningResponse_VaultKeys::kAES256IVFieldNumber;
const int VaultRunningResponse_VaultKeys::kEncryptedAnpmidFieldNumber;
const int VaultRunningResponse_VaultKeys::kEncryptedPmidFieldNumber;
#endif  // !_MSC_VER

VaultRunningResponse_VaultKeys::VaultRunningResponse_VaultKeys()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VaultRunningResponse_VaultKeys::InitAsDefaultInstance() {
}

VaultRunningResponse_VaultKeys::VaultRunningResponse_VaultKeys(const VaultRunningResponse_VaultKeys& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VaultRunningResponse_VaultKeys::SharedCtor() {
  _cached_size_ = 0;
  aes256key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  aes256iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  encrypted_anpmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  encrypted_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VaultRunningResponse_VaultKeys::~VaultRunningResponse_VaultKeys() {
  SharedDtor();
}

void VaultRunningResponse_VaultKeys::SharedDtor() {
  if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256key_;
  }
  if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256iv_;
  }
  if (encrypted_anpmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encrypted_anpmid_;
  }
  if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encrypted_pmid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VaultRunningResponse_VaultKeys::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VaultRunningResponse_VaultKeys& VaultRunningResponse_VaultKeys::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

VaultRunningResponse_VaultKeys* VaultRunningResponse_VaultKeys::default_instance_ = NULL;

VaultRunningResponse_VaultKeys* VaultRunningResponse_VaultKeys::New() const {
  return new VaultRunningResponse_VaultKeys;
}

void VaultRunningResponse_VaultKeys::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_aes256key()) {
      if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
        aes256key_->clear();
      }
    }
    if (has_aes256iv()) {
      if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
        aes256iv_->clear();
      }
    }
    if (has_encrypted_anpmid()) {
      if (encrypted_anpmid_ != &::google::protobuf::internal::GetEmptyString()) {
        encrypted_anpmid_->clear();
      }
    }
    if (has_encrypted_pmid()) {
      if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
        encrypted_pmid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VaultRunningResponse_VaultKeys::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes AES256Key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes256key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_AES256IV;
        break;
      }

      // required bytes AES256IV = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_AES256IV:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes256iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_encrypted_anpmid;
        break;
      }

      // required bytes encrypted_anpmid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_anpmid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_anpmid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_encrypted_pmid;
        break;
      }

      // required bytes encrypted_pmid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_pmid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_pmid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VaultRunningResponse_VaultKeys::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes AES256Key = 1;
  if (has_aes256key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->aes256key(), output);
  }

  // required bytes AES256IV = 2;
  if (has_aes256iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->aes256iv(), output);
  }

  // required bytes encrypted_anpmid = 3;
  if (has_encrypted_anpmid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->encrypted_anpmid(), output);
  }

  // required bytes encrypted_pmid = 4;
  if (has_encrypted_pmid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->encrypted_pmid(), output);
  }

}

int VaultRunningResponse_VaultKeys::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes AES256Key = 1;
    if (has_aes256key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes256key());
    }

    // required bytes AES256IV = 2;
    if (has_aes256iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes256iv());
    }

    // required bytes encrypted_anpmid = 3;
    if (has_encrypted_anpmid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_anpmid());
    }

    // required bytes encrypted_pmid = 4;
    if (has_encrypted_pmid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_pmid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VaultRunningResponse_VaultKeys::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VaultRunningResponse_VaultKeys*>(&from));
}

void VaultRunningResponse_VaultKeys::MergeFrom(const VaultRunningResponse_VaultKeys& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aes256key()) {
      set_aes256key(from.aes256key());
    }
    if (from.has_aes256iv()) {
      set_aes256iv(from.aes256iv());
    }
    if (from.has_encrypted_anpmid()) {
      set_encrypted_anpmid(from.encrypted_anpmid());
    }
    if (from.has_encrypted_pmid()) {
      set_encrypted_pmid(from.encrypted_pmid());
    }
  }
}

void VaultRunningResponse_VaultKeys::CopyFrom(const VaultRunningResponse_VaultKeys& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VaultRunningResponse_VaultKeys::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void VaultRunningResponse_VaultKeys::Swap(VaultRunningResponse_VaultKeys* other) {
  if (other != this) {
    std::swap(aes256key_, other->aes256key_);
    std::swap(aes256iv_, other->aes256iv_);
    std::swap(encrypted_anpmid_, other->encrypted_anpmid_);
    std::swap(encrypted_pmid_, other->encrypted_pmid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VaultRunningResponse_VaultKeys::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int VaultRunningResponse::kLabelFieldNumber;
const int VaultRunningResponse::kSerialisedMaidsafeErrorFieldNumber;
const int VaultRunningResponse::kVaultKeysFieldNumber;
#endif  // !_MSC_VER

VaultRunningResponse::VaultRunningResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VaultRunningResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  vault_keys_ = const_cast< ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys*>(
      ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys::internal_default_instance());
#else
  vault_keys_ = const_cast< ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys*>(&::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys::default_instance());
#endif
}

VaultRunningResponse::VaultRunningResponse(const VaultRunningResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VaultRunningResponse::SharedCtor() {
  _cached_size_ = 0;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_maidsafe_error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  vault_keys_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VaultRunningResponse::~VaultRunningResponse() {
  SharedDtor();
}

void VaultRunningResponse::SharedDtor() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (serialised_maidsafe_error_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_maidsafe_error_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete vault_keys_;
  }
}

void VaultRunningResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VaultRunningResponse& VaultRunningResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

VaultRunningResponse* VaultRunningResponse::default_instance_ = NULL;

VaultRunningResponse* VaultRunningResponse::New() const {
  return new VaultRunningResponse;
}

void VaultRunningResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::GetEmptyString()) {
        label_->clear();
      }
    }
    if (has_serialised_maidsafe_error()) {
      if (serialised_maidsafe_error_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_maidsafe_error_->clear();
      }
    }
    if (has_vault_keys()) {
      if (vault_keys_ != NULL) vault_keys_->::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VaultRunningResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes label = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_label()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serialised_maidsafe_error;
        break;
      }

      // optional bytes serialised_maidsafe_error = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_maidsafe_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_maidsafe_error()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_vault_keys;
        break;
      }

      // optional .maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys vault_keys = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vault_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vault_keys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VaultRunningResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes label = 1;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->label(), output);
  }

  // optional bytes serialised_maidsafe_error = 2;
  if (has_serialised_maidsafe_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->serialised_maidsafe_error(), output);
  }

  // optional .maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys vault_keys = 3;
  if (has_vault_keys()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->vault_keys(), output);
  }

}

int VaultRunningResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes label = 1;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->label());
    }

    // optional bytes serialised_maidsafe_error = 2;
    if (has_serialised_maidsafe_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_maidsafe_error());
    }

    // optional .maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys vault_keys = 3;
    if (has_vault_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->vault_keys());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VaultRunningResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VaultRunningResponse*>(&from));
}

void VaultRunningResponse::MergeFrom(const VaultRunningResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_serialised_maidsafe_error()) {
      set_serialised_maidsafe_error(from.serialised_maidsafe_error());
    }
    if (from.has_vault_keys()) {
      mutable_vault_keys()->::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys::MergeFrom(from.vault_keys());
    }
  }
}

void VaultRunningResponse::CopyFrom(const VaultRunningResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VaultRunningResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_vault_keys()) {
    if (!this->vault_keys().IsInitialized()) return false;
  }
  return true;
}

void VaultRunningResponse::Swap(VaultRunningResponse* other) {
  if (other != this) {
    std::swap(label_, other->label_);
    std::swap(serialised_maidsafe_error_, other->serialised_maidsafe_error_);
    std::swap(vault_keys_, other->vault_keys_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VaultRunningResponse::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.VaultRunningResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int VaultStarted::kProcessIdFieldNumber;
#endif  // !_MSC_VER

VaultStarted::VaultStarted()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VaultStarted::InitAsDefaultInstance() {
}

VaultStarted::VaultStarted(const VaultStarted& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VaultStarted::SharedCtor() {
  _cached_size_ = 0;
  process_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VaultStarted::~VaultStarted() {
  SharedDtor();
}

void VaultStarted::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VaultStarted::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VaultStarted& VaultStarted::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

VaultStarted* VaultStarted::default_instance_ = NULL;

VaultStarted* VaultStarted::New() const {
  return new VaultStarted;
}

void VaultStarted::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    process_id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VaultStarted::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 process_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &process_id_)));
          set_has_process_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VaultStarted::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 process_id = 1;
  if (has_process_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->process_id(), output);
  }

}

int VaultStarted::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 process_id = 1;
    if (has_process_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->process_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VaultStarted::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VaultStarted*>(&from));
}

void VaultStarted::MergeFrom(const VaultStarted& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_process_id()) {
      set_process_id(from.process_id());
    }
  }
}

void VaultStarted::CopyFrom(const VaultStarted& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VaultStarted::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void VaultStarted::Swap(VaultStarted* other) {
  if (other != this) {
    std::swap(process_id_, other->process_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VaultStarted::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.VaultStarted";
}


// ===================================================================

#ifndef _MSC_VER
const int VaultStartedResponse::kAES256KeyFieldNumber;
const int VaultStartedResponse::kAES256IVFieldNumber;
const int VaultStartedResponse::kEncryptedPmidFieldNumber;
const int VaultStartedResponse::kVaultDirFieldNumber;
const int VaultStartedResponse::kMaxDiskUsageFieldNumber;
const int VaultStartedResponse::kVlogSessionIdFieldNumber;
const int VaultStartedResponse::kSerialisedPublicPmidsFieldNumber;
const int VaultStartedResponse::kSendHostnameToVisualiserServerFieldNumber;
#endif  // !_MSC_VER

VaultStartedResponse::VaultStartedResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void VaultStartedResponse::InitAsDefaultInstance() {
}

VaultStartedResponse::VaultStartedResponse(const VaultStartedResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void VaultStartedResponse::SharedCtor() {
  _cached_size_ = 0;
  aes256key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  aes256iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  encrypted_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  vlog_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  serialised_public_pmids_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  send_hostname_to_visualiser_server_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VaultStartedResponse::~VaultStartedResponse() {
  SharedDtor();
}

void VaultStartedResponse::SharedDtor() {
  if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256key_;
  }
  if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256iv_;
  }
  if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encrypted_pmid_;
  }
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vault_dir_;
  }
  if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vlog_session_id_;
  }
  if (serialised_public_pmids_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_public_pmids_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void VaultStartedResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VaultStartedResponse& VaultStartedResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

VaultStartedResponse* VaultStartedResponse::default_instance_ = NULL;

VaultStartedResponse* VaultStartedResponse::New() const {
  return new VaultStartedResponse;
}

void VaultStartedResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_aes256key()) {
      if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
        aes256key_->clear();
      }
    }
    if (has_aes256iv()) {
      if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
        aes256iv_->clear();
      }
    }
    if (has_encrypted_pmid()) {
      if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
        encrypted_pmid_->clear();
      }
    }
    if (has_vault_dir()) {
      if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
        vault_dir_->clear();
      }
    }
    max_disk_usage_ = GOOGLE_ULONGLONG(0);
    if (has_vlog_session_id()) {
      if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
        vlog_session_id_->clear();
      }
    }
    if (has_serialised_public_pmids()) {
      if (serialised_public_pmids_ != &::google::protobuf::internal::GetEmptyString()) {
        serialised_public_pmids_->clear();
      }
    }
    send_hostname_to_visualiser_server_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool VaultStartedResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes AES256Key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes256key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_AES256IV;
        break;
      }

      // required bytes AES256IV = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_AES256IV:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_aes256iv()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_encrypted_pmid;
        break;
      }

      // required bytes encrypted_pmid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encrypted_pmid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_encrypted_pmid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_vault_dir;
        break;
      }

      // required bytes vault_dir = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vault_dir:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vault_dir()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_max_disk_usage;
        break;
      }

      // required uint64 max_disk_usage = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_disk_usage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_disk_usage_)));
          set_has_max_disk_usage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_vlog_session_id;
        break;
      }

      // optional bytes vlog_session_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_vlog_session_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_vlog_session_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_serialised_public_pmids;
        break;
      }

      // optional bytes serialised_public_pmids = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialised_public_pmids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialised_public_pmids()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_send_hostname_to_visualiser_server;
        break;
      }

      // optional bool send_hostname_to_visualiser_server = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_send_hostname_to_visualiser_server:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &send_hostname_to_visualiser_server_)));
          set_has_send_hostname_to_visualiser_server();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VaultStartedResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes AES256Key = 1;
  if (has_aes256key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->aes256key(), output);
  }

  // required bytes AES256IV = 2;
  if (has_aes256iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->aes256iv(), output);
  }

  // required bytes encrypted_pmid = 3;
  if (has_encrypted_pmid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->encrypted_pmid(), output);
  }

  // required bytes vault_dir = 4;
  if (has_vault_dir()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->vault_dir(), output);
  }

  // required uint64 max_disk_usage = 5;
  if (has_max_disk_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->max_disk_usage(), output);
  }

  // optional bytes vlog_session_id = 6;
  if (has_vlog_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->vlog_session_id(), output);
  }

  // optional bytes serialised_public_pmids = 7;
  if (has_serialised_public_pmids()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->serialised_public_pmids(), output);
  }

  // optional bool send_hostname_to_visualiser_server = 8;
  if (has_send_hostname_to_visualiser_server()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->send_hostname_to_visualiser_server(), output);
  }

}

int VaultStartedResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes AES256Key = 1;
    if (has_aes256key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes256key());
    }

    // required bytes AES256IV = 2;
    if (has_aes256iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->aes256iv());
    }

    // required bytes encrypted_pmid = 3;
    if (has_encrypted_pmid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->encrypted_pmid());
    }

    // required bytes vault_dir = 4;
    if (has_vault_dir()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vault_dir());
    }

    // required uint64 max_disk_usage = 5;
    if (has_max_disk_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_disk_usage());
    }

    // optional bytes vlog_session_id = 6;
    if (has_vlog_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->vlog_session_id());
    }

    // optional bytes serialised_public_pmids = 7;
    if (has_serialised_public_pmids()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialised_public_pmids());
    }

    // optional bool send_hostname_to_visualiser_server = 8;
    if (has_send_hostname_to_visualiser_server()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VaultStartedResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VaultStartedResponse*>(&from));
}

void VaultStartedResponse::MergeFrom(const VaultStartedResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_aes256key()) {
      set_aes256key(from.aes256key());
    }
    if (from.has_aes256iv()) {
      set_aes256iv(from.aes256iv());
    }
    if (from.has_encrypted_pmid()) {
      set_encrypted_pmid(from.encrypted_pmid());
    }
    if (from.has_vault_dir()) {
      set_vault_dir(from.vault_dir());
    }
    if (from.has_max_disk_usage()) {
      set_max_disk_usage(from.max_disk_usage());
    }
    if (from.has_vlog_session_id()) {
      set_vlog_session_id(from.vlog_session_id());
    }
    if (from.has_serialised_public_pmids()) {
      set_serialised_public_pmids(from.serialised_public_pmids());
    }
    if (from.has_send_hostname_to_visualiser_server()) {
      set_send_hostname_to_visualiser_server(from.send_hostname_to_visualiser_server());
    }
  }
}

void VaultStartedResponse::CopyFrom(const VaultStartedResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VaultStartedResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void VaultStartedResponse::Swap(VaultStartedResponse* other) {
  if (other != this) {
    std::swap(aes256key_, other->aes256key_);
    std::swap(aes256iv_, other->aes256iv_);
    std::swap(encrypted_pmid_, other->encrypted_pmid_);
    std::swap(vault_dir_, other->vault_dir_);
    std::swap(max_disk_usage_, other->max_disk_usage_);
    std::swap(vlog_session_id_, other->vlog_session_id_);
    std::swap(serialised_public_pmids_, other->serialised_public_pmids_);
    std::swap(send_hostname_to_visualiser_server_, other->send_hostname_to_visualiser_server_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string VaultStartedResponse::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.VaultStartedResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int MaxDiskUsageUpdate::kMaxDiskUsageFieldNumber;
#endif  // !_MSC_VER

MaxDiskUsageUpdate::MaxDiskUsageUpdate()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MaxDiskUsageUpdate::InitAsDefaultInstance() {
}

MaxDiskUsageUpdate::MaxDiskUsageUpdate(const MaxDiskUsageUpdate& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MaxDiskUsageUpdate::SharedCtor() {
  _cached_size_ = 0;
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MaxDiskUsageUpdate::~MaxDiskUsageUpdate() {
  SharedDtor();
}

void MaxDiskUsageUpdate::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MaxDiskUsageUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MaxDiskUsageUpdate& MaxDiskUsageUpdate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
#endif
  return *default_instance_;
}

MaxDiskUsageUpdate* MaxDiskUsageUpdate::default_instance_ = NULL;

MaxDiskUsageUpdate* MaxDiskUsageUpdate::New() const {
  return new MaxDiskUsageUpdate;
}

void MaxDiskUsageUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    max_disk_usage_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MaxDiskUsageUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 max_disk_usage = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_disk_usage_)));
          set_has_max_disk_usage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MaxDiskUsageUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 max_disk_usage = 1;
  if (has_max_disk_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->max_disk_usage(), output);
  }

}

int MaxDiskUsageUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 max_disk_usage = 1;
    if (has_max_disk_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_disk_usage());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MaxDiskUsageUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MaxDiskUsageUpdate*>(&from));
}

void MaxDiskUsageUpdate::MergeFrom(const MaxDiskUsageUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_disk_usage()) {
      set_max_disk_usage(from.max_disk_usage());
    }
  }
}

void MaxDiskUsageUpdate::CopyFrom(const MaxDiskUsageUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MaxDiskUsageUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MaxDiskUsageUpdate::Swap(MaxDiskUsageUpdate* other) {
  if (other != this) {
    std::swap(max_disk_usage_, other->max_disk_usage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MaxDiskUsageUpdate::GetTypeName() const {
  return "maidsafe.vault_manager.protobuf.MaxDiskUsageUpdate";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace vault_manager
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)
