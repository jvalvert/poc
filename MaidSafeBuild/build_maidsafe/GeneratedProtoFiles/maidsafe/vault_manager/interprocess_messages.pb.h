// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/vault_manager/interprocess_messages.proto

#ifndef PROTOBUF_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto__INCLUDED
#define PROTOBUF_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace vault_manager {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

class WrapperMessage;
class Challenge;
class ChallengeResponse;
class PublicPmidList;
class PublicPmidList_PublicPmid;
class StartVaultRequest;
class TakeOwnershipRequest;
class VaultRunningResponse;
class VaultRunningResponse_VaultKeys;
class VaultStarted;
class VaultStartedResponse;
class MaxDiskUsageUpdate;

// ===================================================================

class WrapperMessage : public ::google::protobuf::MessageLite {
 public:
  WrapperMessage();
  virtual ~WrapperMessage();

  WrapperMessage(const WrapperMessage& from);

  inline WrapperMessage& operator=(const WrapperMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const WrapperMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WrapperMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WrapperMessage* other);

  // implements Message ----------------------------------------------

  WrapperMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WrapperMessage& from);
  void MergeFrom(const WrapperMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // optional bytes message_signature = 3;
  inline bool has_message_signature() const;
  inline void clear_message_signature();
  static const int kMessageSignatureFieldNumber = 3;
  inline const ::std::string& message_signature() const;
  inline void set_message_signature(const ::std::string& value);
  inline void set_message_signature(const char* value);
  inline void set_message_signature(const void* value, size_t size);
  inline ::std::string* mutable_message_signature();
  inline ::std::string* release_message_signature();
  inline void set_allocated_message_signature(::std::string* message_signature);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.WrapperMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_message_signature();
  inline void clear_has_message_signature();

  ::std::string* payload_;
  ::std::string* message_signature_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static WrapperMessage* default_instance_;
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::MessageLite {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }

  static const Challenge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Challenge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Challenge* other);

  // implements Message ----------------------------------------------

  Challenge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes plaintext = 1;
  inline bool has_plaintext() const;
  inline void clear_plaintext();
  static const int kPlaintextFieldNumber = 1;
  inline const ::std::string& plaintext() const;
  inline void set_plaintext(const ::std::string& value);
  inline void set_plaintext(const char* value);
  inline void set_plaintext(const void* value, size_t size);
  inline ::std::string* mutable_plaintext();
  inline ::std::string* release_plaintext();
  inline void set_allocated_plaintext(::std::string* plaintext);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.Challenge)
 private:
  inline void set_has_plaintext();
  inline void clear_has_plaintext();

  ::std::string* plaintext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static Challenge* default_instance_;
};
// -------------------------------------------------------------------

class ChallengeResponse : public ::google::protobuf::MessageLite {
 public:
  ChallengeResponse();
  virtual ~ChallengeResponse();

  ChallengeResponse(const ChallengeResponse& from);

  inline ChallengeResponse& operator=(const ChallengeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChallengeResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChallengeResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChallengeResponse* other);

  // implements Message ----------------------------------------------

  ChallengeResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChallengeResponse& from);
  void MergeFrom(const ChallengeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes public_maid_name = 1;
  inline bool has_public_maid_name() const;
  inline void clear_public_maid_name();
  static const int kPublicMaidNameFieldNumber = 1;
  inline const ::std::string& public_maid_name() const;
  inline void set_public_maid_name(const ::std::string& value);
  inline void set_public_maid_name(const char* value);
  inline void set_public_maid_name(const void* value, size_t size);
  inline ::std::string* mutable_public_maid_name();
  inline ::std::string* release_public_maid_name();
  inline void set_allocated_public_maid_name(::std::string* public_maid_name);

  // required bytes public_maid_value = 2;
  inline bool has_public_maid_value() const;
  inline void clear_public_maid_value();
  static const int kPublicMaidValueFieldNumber = 2;
  inline const ::std::string& public_maid_value() const;
  inline void set_public_maid_value(const ::std::string& value);
  inline void set_public_maid_value(const char* value);
  inline void set_public_maid_value(const void* value, size_t size);
  inline ::std::string* mutable_public_maid_value();
  inline ::std::string* release_public_maid_value();
  inline void set_allocated_public_maid_value(::std::string* public_maid_value);

  // required bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.ChallengeResponse)
 private:
  inline void set_has_public_maid_name();
  inline void clear_has_public_maid_name();
  inline void set_has_public_maid_value();
  inline void clear_has_public_maid_value();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::std::string* public_maid_name_;
  ::std::string* public_maid_value_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static ChallengeResponse* default_instance_;
};
// -------------------------------------------------------------------

class PublicPmidList_PublicPmid : public ::google::protobuf::MessageLite {
 public:
  PublicPmidList_PublicPmid();
  virtual ~PublicPmidList_PublicPmid();

  PublicPmidList_PublicPmid(const PublicPmidList_PublicPmid& from);

  inline PublicPmidList_PublicPmid& operator=(const PublicPmidList_PublicPmid& from) {
    CopyFrom(from);
    return *this;
  }

  static const PublicPmidList_PublicPmid& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PublicPmidList_PublicPmid* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PublicPmidList_PublicPmid* other);

  // implements Message ----------------------------------------------

  PublicPmidList_PublicPmid* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PublicPmidList_PublicPmid& from);
  void MergeFrom(const PublicPmidList_PublicPmid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes public_pmid_name = 1;
  inline bool has_public_pmid_name() const;
  inline void clear_public_pmid_name();
  static const int kPublicPmidNameFieldNumber = 1;
  inline const ::std::string& public_pmid_name() const;
  inline void set_public_pmid_name(const ::std::string& value);
  inline void set_public_pmid_name(const char* value);
  inline void set_public_pmid_name(const void* value, size_t size);
  inline ::std::string* mutable_public_pmid_name();
  inline ::std::string* release_public_pmid_name();
  inline void set_allocated_public_pmid_name(::std::string* public_pmid_name);

  // required bytes public_pmid = 2;
  inline bool has_public_pmid() const;
  inline void clear_public_pmid();
  static const int kPublicPmidFieldNumber = 2;
  inline const ::std::string& public_pmid() const;
  inline void set_public_pmid(const ::std::string& value);
  inline void set_public_pmid(const char* value);
  inline void set_public_pmid(const void* value, size_t size);
  inline ::std::string* mutable_public_pmid();
  inline ::std::string* release_public_pmid();
  inline void set_allocated_public_pmid(::std::string* public_pmid);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid)
 private:
  inline void set_has_public_pmid_name();
  inline void clear_has_public_pmid_name();
  inline void set_has_public_pmid();
  inline void clear_has_public_pmid();

  ::std::string* public_pmid_name_;
  ::std::string* public_pmid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static PublicPmidList_PublicPmid* default_instance_;
};
// -------------------------------------------------------------------

class PublicPmidList : public ::google::protobuf::MessageLite {
 public:
  PublicPmidList();
  virtual ~PublicPmidList();

  PublicPmidList(const PublicPmidList& from);

  inline PublicPmidList& operator=(const PublicPmidList& from) {
    CopyFrom(from);
    return *this;
  }

  static const PublicPmidList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PublicPmidList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PublicPmidList* other);

  // implements Message ----------------------------------------------

  PublicPmidList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PublicPmidList& from);
  void MergeFrom(const PublicPmidList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef PublicPmidList_PublicPmid PublicPmid;

  // accessors -------------------------------------------------------

  // repeated .maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid public_pmids = 1;
  inline int public_pmids_size() const;
  inline void clear_public_pmids();
  static const int kPublicPmidsFieldNumber = 1;
  inline const ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid& public_pmids(int index) const;
  inline ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid* mutable_public_pmids(int index);
  inline ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid* add_public_pmids();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid >&
      public_pmids() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid >*
      mutable_public_pmids();

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.PublicPmidList)
 private:

  ::google::protobuf::RepeatedPtrField< ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid > public_pmids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static PublicPmidList* default_instance_;
};
// -------------------------------------------------------------------

class StartVaultRequest : public ::google::protobuf::MessageLite {
 public:
  StartVaultRequest();
  virtual ~StartVaultRequest();

  StartVaultRequest(const StartVaultRequest& from);

  inline StartVaultRequest& operator=(const StartVaultRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartVaultRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartVaultRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartVaultRequest* other);

  // implements Message ----------------------------------------------

  StartVaultRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartVaultRequest& from);
  void MergeFrom(const StartVaultRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const void* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bytes vault_dir = 2;
  inline bool has_vault_dir() const;
  inline void clear_vault_dir();
  static const int kVaultDirFieldNumber = 2;
  inline const ::std::string& vault_dir() const;
  inline void set_vault_dir(const ::std::string& value);
  inline void set_vault_dir(const char* value);
  inline void set_vault_dir(const void* value, size_t size);
  inline ::std::string* mutable_vault_dir();
  inline ::std::string* release_vault_dir();
  inline void set_allocated_vault_dir(::std::string* vault_dir);

  // required uint64 max_disk_usage = 3;
  inline bool has_max_disk_usage() const;
  inline void clear_max_disk_usage();
  static const int kMaxDiskUsageFieldNumber = 3;
  inline ::google::protobuf::uint64 max_disk_usage() const;
  inline void set_max_disk_usage(::google::protobuf::uint64 value);

  // optional bytes vlog_session_id = 4;
  inline bool has_vlog_session_id() const;
  inline void clear_vlog_session_id();
  static const int kVlogSessionIdFieldNumber = 4;
  inline const ::std::string& vlog_session_id() const;
  inline void set_vlog_session_id(const ::std::string& value);
  inline void set_vlog_session_id(const char* value);
  inline void set_vlog_session_id(const void* value, size_t size);
  inline ::std::string* mutable_vlog_session_id();
  inline ::std::string* release_vlog_session_id();
  inline void set_allocated_vlog_session_id(::std::string* vlog_session_id);

  // optional bool send_hostname_to_visualiser_server = 5;
  inline bool has_send_hostname_to_visualiser_server() const;
  inline void clear_send_hostname_to_visualiser_server();
  static const int kSendHostnameToVisualiserServerFieldNumber = 5;
  inline bool send_hostname_to_visualiser_server() const;
  inline void set_send_hostname_to_visualiser_server(bool value);

  // optional int32 pmid_list_index = 6;
  inline bool has_pmid_list_index() const;
  inline void clear_pmid_list_index();
  static const int kPmidListIndexFieldNumber = 6;
  inline ::google::protobuf::int32 pmid_list_index() const;
  inline void set_pmid_list_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.StartVaultRequest)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_vault_dir();
  inline void clear_has_vault_dir();
  inline void set_has_max_disk_usage();
  inline void clear_has_max_disk_usage();
  inline void set_has_vlog_session_id();
  inline void clear_has_vlog_session_id();
  inline void set_has_send_hostname_to_visualiser_server();
  inline void clear_has_send_hostname_to_visualiser_server();
  inline void set_has_pmid_list_index();
  inline void clear_has_pmid_list_index();

  ::std::string* label_;
  ::std::string* vault_dir_;
  ::google::protobuf::uint64 max_disk_usage_;
  ::std::string* vlog_session_id_;
  bool send_hostname_to_visualiser_server_;
  ::google::protobuf::int32 pmid_list_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static StartVaultRequest* default_instance_;
};
// -------------------------------------------------------------------

class TakeOwnershipRequest : public ::google::protobuf::MessageLite {
 public:
  TakeOwnershipRequest();
  virtual ~TakeOwnershipRequest();

  TakeOwnershipRequest(const TakeOwnershipRequest& from);

  inline TakeOwnershipRequest& operator=(const TakeOwnershipRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const TakeOwnershipRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TakeOwnershipRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TakeOwnershipRequest* other);

  // implements Message ----------------------------------------------

  TakeOwnershipRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TakeOwnershipRequest& from);
  void MergeFrom(const TakeOwnershipRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const void* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // required bytes vault_dir = 2;
  inline bool has_vault_dir() const;
  inline void clear_vault_dir();
  static const int kVaultDirFieldNumber = 2;
  inline const ::std::string& vault_dir() const;
  inline void set_vault_dir(const ::std::string& value);
  inline void set_vault_dir(const char* value);
  inline void set_vault_dir(const void* value, size_t size);
  inline ::std::string* mutable_vault_dir();
  inline ::std::string* release_vault_dir();
  inline void set_allocated_vault_dir(::std::string* vault_dir);

  // required uint64 max_disk_usage = 3;
  inline bool has_max_disk_usage() const;
  inline void clear_max_disk_usage();
  static const int kMaxDiskUsageFieldNumber = 3;
  inline ::google::protobuf::uint64 max_disk_usage() const;
  inline void set_max_disk_usage(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.TakeOwnershipRequest)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_vault_dir();
  inline void clear_has_vault_dir();
  inline void set_has_max_disk_usage();
  inline void clear_has_max_disk_usage();

  ::std::string* label_;
  ::std::string* vault_dir_;
  ::google::protobuf::uint64 max_disk_usage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static TakeOwnershipRequest* default_instance_;
};
// -------------------------------------------------------------------

class VaultRunningResponse_VaultKeys : public ::google::protobuf::MessageLite {
 public:
  VaultRunningResponse_VaultKeys();
  virtual ~VaultRunningResponse_VaultKeys();

  VaultRunningResponse_VaultKeys(const VaultRunningResponse_VaultKeys& from);

  inline VaultRunningResponse_VaultKeys& operator=(const VaultRunningResponse_VaultKeys& from) {
    CopyFrom(from);
    return *this;
  }

  static const VaultRunningResponse_VaultKeys& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VaultRunningResponse_VaultKeys* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VaultRunningResponse_VaultKeys* other);

  // implements Message ----------------------------------------------

  VaultRunningResponse_VaultKeys* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VaultRunningResponse_VaultKeys& from);
  void MergeFrom(const VaultRunningResponse_VaultKeys& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes AES256Key = 1;
  inline bool has_aes256key() const;
  inline void clear_aes256key();
  static const int kAES256KeyFieldNumber = 1;
  inline const ::std::string& aes256key() const;
  inline void set_aes256key(const ::std::string& value);
  inline void set_aes256key(const char* value);
  inline void set_aes256key(const void* value, size_t size);
  inline ::std::string* mutable_aes256key();
  inline ::std::string* release_aes256key();
  inline void set_allocated_aes256key(::std::string* aes256key);

  // required bytes AES256IV = 2;
  inline bool has_aes256iv() const;
  inline void clear_aes256iv();
  static const int kAES256IVFieldNumber = 2;
  inline const ::std::string& aes256iv() const;
  inline void set_aes256iv(const ::std::string& value);
  inline void set_aes256iv(const char* value);
  inline void set_aes256iv(const void* value, size_t size);
  inline ::std::string* mutable_aes256iv();
  inline ::std::string* release_aes256iv();
  inline void set_allocated_aes256iv(::std::string* aes256iv);

  // required bytes encrypted_anpmid = 3;
  inline bool has_encrypted_anpmid() const;
  inline void clear_encrypted_anpmid();
  static const int kEncryptedAnpmidFieldNumber = 3;
  inline const ::std::string& encrypted_anpmid() const;
  inline void set_encrypted_anpmid(const ::std::string& value);
  inline void set_encrypted_anpmid(const char* value);
  inline void set_encrypted_anpmid(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_anpmid();
  inline ::std::string* release_encrypted_anpmid();
  inline void set_allocated_encrypted_anpmid(::std::string* encrypted_anpmid);

  // required bytes encrypted_pmid = 4;
  inline bool has_encrypted_pmid() const;
  inline void clear_encrypted_pmid();
  static const int kEncryptedPmidFieldNumber = 4;
  inline const ::std::string& encrypted_pmid() const;
  inline void set_encrypted_pmid(const ::std::string& value);
  inline void set_encrypted_pmid(const char* value);
  inline void set_encrypted_pmid(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_pmid();
  inline ::std::string* release_encrypted_pmid();
  inline void set_allocated_encrypted_pmid(::std::string* encrypted_pmid);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys)
 private:
  inline void set_has_aes256key();
  inline void clear_has_aes256key();
  inline void set_has_aes256iv();
  inline void clear_has_aes256iv();
  inline void set_has_encrypted_anpmid();
  inline void clear_has_encrypted_anpmid();
  inline void set_has_encrypted_pmid();
  inline void clear_has_encrypted_pmid();

  ::std::string* aes256key_;
  ::std::string* aes256iv_;
  ::std::string* encrypted_anpmid_;
  ::std::string* encrypted_pmid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static VaultRunningResponse_VaultKeys* default_instance_;
};
// -------------------------------------------------------------------

class VaultRunningResponse : public ::google::protobuf::MessageLite {
 public:
  VaultRunningResponse();
  virtual ~VaultRunningResponse();

  VaultRunningResponse(const VaultRunningResponse& from);

  inline VaultRunningResponse& operator=(const VaultRunningResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const VaultRunningResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VaultRunningResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VaultRunningResponse* other);

  // implements Message ----------------------------------------------

  VaultRunningResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VaultRunningResponse& from);
  void MergeFrom(const VaultRunningResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef VaultRunningResponse_VaultKeys VaultKeys;

  // accessors -------------------------------------------------------

  // required bytes label = 1;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 1;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const void* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bytes serialised_maidsafe_error = 2;
  inline bool has_serialised_maidsafe_error() const;
  inline void clear_serialised_maidsafe_error();
  static const int kSerialisedMaidsafeErrorFieldNumber = 2;
  inline const ::std::string& serialised_maidsafe_error() const;
  inline void set_serialised_maidsafe_error(const ::std::string& value);
  inline void set_serialised_maidsafe_error(const char* value);
  inline void set_serialised_maidsafe_error(const void* value, size_t size);
  inline ::std::string* mutable_serialised_maidsafe_error();
  inline ::std::string* release_serialised_maidsafe_error();
  inline void set_allocated_serialised_maidsafe_error(::std::string* serialised_maidsafe_error);

  // optional .maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys vault_keys = 3;
  inline bool has_vault_keys() const;
  inline void clear_vault_keys();
  static const int kVaultKeysFieldNumber = 3;
  inline const ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys& vault_keys() const;
  inline ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* mutable_vault_keys();
  inline ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* release_vault_keys();
  inline void set_allocated_vault_keys(::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* vault_keys);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.VaultRunningResponse)
 private:
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_serialised_maidsafe_error();
  inline void clear_has_serialised_maidsafe_error();
  inline void set_has_vault_keys();
  inline void clear_has_vault_keys();

  ::std::string* label_;
  ::std::string* serialised_maidsafe_error_;
  ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* vault_keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static VaultRunningResponse* default_instance_;
};
// -------------------------------------------------------------------

class VaultStarted : public ::google::protobuf::MessageLite {
 public:
  VaultStarted();
  virtual ~VaultStarted();

  VaultStarted(const VaultStarted& from);

  inline VaultStarted& operator=(const VaultStarted& from) {
    CopyFrom(from);
    return *this;
  }

  static const VaultStarted& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VaultStarted* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VaultStarted* other);

  // implements Message ----------------------------------------------

  VaultStarted* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VaultStarted& from);
  void MergeFrom(const VaultStarted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 process_id = 1;
  inline bool has_process_id() const;
  inline void clear_process_id();
  static const int kProcessIdFieldNumber = 1;
  inline ::google::protobuf::uint64 process_id() const;
  inline void set_process_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.VaultStarted)
 private:
  inline void set_has_process_id();
  inline void clear_has_process_id();

  ::google::protobuf::uint64 process_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static VaultStarted* default_instance_;
};
// -------------------------------------------------------------------

class VaultStartedResponse : public ::google::protobuf::MessageLite {
 public:
  VaultStartedResponse();
  virtual ~VaultStartedResponse();

  VaultStartedResponse(const VaultStartedResponse& from);

  inline VaultStartedResponse& operator=(const VaultStartedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const VaultStartedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VaultStartedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VaultStartedResponse* other);

  // implements Message ----------------------------------------------

  VaultStartedResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VaultStartedResponse& from);
  void MergeFrom(const VaultStartedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes AES256Key = 1;
  inline bool has_aes256key() const;
  inline void clear_aes256key();
  static const int kAES256KeyFieldNumber = 1;
  inline const ::std::string& aes256key() const;
  inline void set_aes256key(const ::std::string& value);
  inline void set_aes256key(const char* value);
  inline void set_aes256key(const void* value, size_t size);
  inline ::std::string* mutable_aes256key();
  inline ::std::string* release_aes256key();
  inline void set_allocated_aes256key(::std::string* aes256key);

  // required bytes AES256IV = 2;
  inline bool has_aes256iv() const;
  inline void clear_aes256iv();
  static const int kAES256IVFieldNumber = 2;
  inline const ::std::string& aes256iv() const;
  inline void set_aes256iv(const ::std::string& value);
  inline void set_aes256iv(const char* value);
  inline void set_aes256iv(const void* value, size_t size);
  inline ::std::string* mutable_aes256iv();
  inline ::std::string* release_aes256iv();
  inline void set_allocated_aes256iv(::std::string* aes256iv);

  // required bytes encrypted_pmid = 3;
  inline bool has_encrypted_pmid() const;
  inline void clear_encrypted_pmid();
  static const int kEncryptedPmidFieldNumber = 3;
  inline const ::std::string& encrypted_pmid() const;
  inline void set_encrypted_pmid(const ::std::string& value);
  inline void set_encrypted_pmid(const char* value);
  inline void set_encrypted_pmid(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_pmid();
  inline ::std::string* release_encrypted_pmid();
  inline void set_allocated_encrypted_pmid(::std::string* encrypted_pmid);

  // required bytes vault_dir = 4;
  inline bool has_vault_dir() const;
  inline void clear_vault_dir();
  static const int kVaultDirFieldNumber = 4;
  inline const ::std::string& vault_dir() const;
  inline void set_vault_dir(const ::std::string& value);
  inline void set_vault_dir(const char* value);
  inline void set_vault_dir(const void* value, size_t size);
  inline ::std::string* mutable_vault_dir();
  inline ::std::string* release_vault_dir();
  inline void set_allocated_vault_dir(::std::string* vault_dir);

  // required uint64 max_disk_usage = 5;
  inline bool has_max_disk_usage() const;
  inline void clear_max_disk_usage();
  static const int kMaxDiskUsageFieldNumber = 5;
  inline ::google::protobuf::uint64 max_disk_usage() const;
  inline void set_max_disk_usage(::google::protobuf::uint64 value);

  // optional bytes vlog_session_id = 6;
  inline bool has_vlog_session_id() const;
  inline void clear_vlog_session_id();
  static const int kVlogSessionIdFieldNumber = 6;
  inline const ::std::string& vlog_session_id() const;
  inline void set_vlog_session_id(const ::std::string& value);
  inline void set_vlog_session_id(const char* value);
  inline void set_vlog_session_id(const void* value, size_t size);
  inline ::std::string* mutable_vlog_session_id();
  inline ::std::string* release_vlog_session_id();
  inline void set_allocated_vlog_session_id(::std::string* vlog_session_id);

  // optional bytes serialised_public_pmids = 7;
  inline bool has_serialised_public_pmids() const;
  inline void clear_serialised_public_pmids();
  static const int kSerialisedPublicPmidsFieldNumber = 7;
  inline const ::std::string& serialised_public_pmids() const;
  inline void set_serialised_public_pmids(const ::std::string& value);
  inline void set_serialised_public_pmids(const char* value);
  inline void set_serialised_public_pmids(const void* value, size_t size);
  inline ::std::string* mutable_serialised_public_pmids();
  inline ::std::string* release_serialised_public_pmids();
  inline void set_allocated_serialised_public_pmids(::std::string* serialised_public_pmids);

  // optional bool send_hostname_to_visualiser_server = 8;
  inline bool has_send_hostname_to_visualiser_server() const;
  inline void clear_send_hostname_to_visualiser_server();
  static const int kSendHostnameToVisualiserServerFieldNumber = 8;
  inline bool send_hostname_to_visualiser_server() const;
  inline void set_send_hostname_to_visualiser_server(bool value);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.VaultStartedResponse)
 private:
  inline void set_has_aes256key();
  inline void clear_has_aes256key();
  inline void set_has_aes256iv();
  inline void clear_has_aes256iv();
  inline void set_has_encrypted_pmid();
  inline void clear_has_encrypted_pmid();
  inline void set_has_vault_dir();
  inline void clear_has_vault_dir();
  inline void set_has_max_disk_usage();
  inline void clear_has_max_disk_usage();
  inline void set_has_vlog_session_id();
  inline void clear_has_vlog_session_id();
  inline void set_has_serialised_public_pmids();
  inline void clear_has_serialised_public_pmids();
  inline void set_has_send_hostname_to_visualiser_server();
  inline void clear_has_send_hostname_to_visualiser_server();

  ::std::string* aes256key_;
  ::std::string* aes256iv_;
  ::std::string* encrypted_pmid_;
  ::std::string* vault_dir_;
  ::google::protobuf::uint64 max_disk_usage_;
  ::std::string* vlog_session_id_;
  ::std::string* serialised_public_pmids_;
  bool send_hostname_to_visualiser_server_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static VaultStartedResponse* default_instance_;
};
// -------------------------------------------------------------------

class MaxDiskUsageUpdate : public ::google::protobuf::MessageLite {
 public:
  MaxDiskUsageUpdate();
  virtual ~MaxDiskUsageUpdate();

  MaxDiskUsageUpdate(const MaxDiskUsageUpdate& from);

  inline MaxDiskUsageUpdate& operator=(const MaxDiskUsageUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const MaxDiskUsageUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MaxDiskUsageUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MaxDiskUsageUpdate* other);

  // implements Message ----------------------------------------------

  MaxDiskUsageUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MaxDiskUsageUpdate& from);
  void MergeFrom(const MaxDiskUsageUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 max_disk_usage = 1;
  inline bool has_max_disk_usage() const;
  inline void clear_max_disk_usage();
  static const int kMaxDiskUsageFieldNumber = 1;
  inline ::google::protobuf::uint64 max_disk_usage() const;
  inline void set_max_disk_usage(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:maidsafe.vault_manager.protobuf.MaxDiskUsageUpdate)
 private:
  inline void set_has_max_disk_usage();
  inline void clear_has_max_disk_usage();

  ::google::protobuf::uint64 max_disk_usage_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto();

  void InitAsDefaultInstance();
  static MaxDiskUsageUpdate* default_instance_;
};
// ===================================================================


// ===================================================================

// WrapperMessage

// required int32 type = 1;
inline bool WrapperMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WrapperMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WrapperMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WrapperMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 WrapperMessage::type() const {
  return type_;
}
inline void WrapperMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bytes payload = 2;
inline bool WrapperMessage::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WrapperMessage::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WrapperMessage::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WrapperMessage::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyString()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& WrapperMessage::payload() const {
  return *payload_;
}
inline void WrapperMessage::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyString()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void WrapperMessage::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyString()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void WrapperMessage::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyString()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WrapperMessage::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyString()) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* WrapperMessage::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void WrapperMessage::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyString()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes message_signature = 3;
inline bool WrapperMessage::has_message_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WrapperMessage::set_has_message_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WrapperMessage::clear_has_message_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WrapperMessage::clear_message_signature() {
  if (message_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    message_signature_->clear();
  }
  clear_has_message_signature();
}
inline const ::std::string& WrapperMessage::message_signature() const {
  return *message_signature_;
}
inline void WrapperMessage::set_message_signature(const ::std::string& value) {
  set_has_message_signature();
  if (message_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    message_signature_ = new ::std::string;
  }
  message_signature_->assign(value);
}
inline void WrapperMessage::set_message_signature(const char* value) {
  set_has_message_signature();
  if (message_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    message_signature_ = new ::std::string;
  }
  message_signature_->assign(value);
}
inline void WrapperMessage::set_message_signature(const void* value, size_t size) {
  set_has_message_signature();
  if (message_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    message_signature_ = new ::std::string;
  }
  message_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WrapperMessage::mutable_message_signature() {
  set_has_message_signature();
  if (message_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    message_signature_ = new ::std::string;
  }
  return message_signature_;
}
inline ::std::string* WrapperMessage::release_message_signature() {
  clear_has_message_signature();
  if (message_signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = message_signature_;
    message_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void WrapperMessage::set_allocated_message_signature(::std::string* message_signature) {
  if (message_signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete message_signature_;
  }
  if (message_signature) {
    set_has_message_signature();
    message_signature_ = message_signature;
  } else {
    clear_has_message_signature();
    message_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Challenge

// required bytes plaintext = 1;
inline bool Challenge::has_plaintext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Challenge::set_has_plaintext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Challenge::clear_has_plaintext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Challenge::clear_plaintext() {
  if (plaintext_ != &::google::protobuf::internal::GetEmptyString()) {
    plaintext_->clear();
  }
  clear_has_plaintext();
}
inline const ::std::string& Challenge::plaintext() const {
  return *plaintext_;
}
inline void Challenge::set_plaintext(const ::std::string& value) {
  set_has_plaintext();
  if (plaintext_ == &::google::protobuf::internal::GetEmptyString()) {
    plaintext_ = new ::std::string;
  }
  plaintext_->assign(value);
}
inline void Challenge::set_plaintext(const char* value) {
  set_has_plaintext();
  if (plaintext_ == &::google::protobuf::internal::GetEmptyString()) {
    plaintext_ = new ::std::string;
  }
  plaintext_->assign(value);
}
inline void Challenge::set_plaintext(const void* value, size_t size) {
  set_has_plaintext();
  if (plaintext_ == &::google::protobuf::internal::GetEmptyString()) {
    plaintext_ = new ::std::string;
  }
  plaintext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Challenge::mutable_plaintext() {
  set_has_plaintext();
  if (plaintext_ == &::google::protobuf::internal::GetEmptyString()) {
    plaintext_ = new ::std::string;
  }
  return plaintext_;
}
inline ::std::string* Challenge::release_plaintext() {
  clear_has_plaintext();
  if (plaintext_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = plaintext_;
    plaintext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Challenge::set_allocated_plaintext(::std::string* plaintext) {
  if (plaintext_ != &::google::protobuf::internal::GetEmptyString()) {
    delete plaintext_;
  }
  if (plaintext) {
    set_has_plaintext();
    plaintext_ = plaintext;
  } else {
    clear_has_plaintext();
    plaintext_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ChallengeResponse

// required bytes public_maid_name = 1;
inline bool ChallengeResponse::has_public_maid_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeResponse::set_has_public_maid_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeResponse::clear_has_public_maid_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeResponse::clear_public_maid_name() {
  if (public_maid_name_ != &::google::protobuf::internal::GetEmptyString()) {
    public_maid_name_->clear();
  }
  clear_has_public_maid_name();
}
inline const ::std::string& ChallengeResponse::public_maid_name() const {
  return *public_maid_name_;
}
inline void ChallengeResponse::set_public_maid_name(const ::std::string& value) {
  set_has_public_maid_name();
  if (public_maid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_name_ = new ::std::string;
  }
  public_maid_name_->assign(value);
}
inline void ChallengeResponse::set_public_maid_name(const char* value) {
  set_has_public_maid_name();
  if (public_maid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_name_ = new ::std::string;
  }
  public_maid_name_->assign(value);
}
inline void ChallengeResponse::set_public_maid_name(const void* value, size_t size) {
  set_has_public_maid_name();
  if (public_maid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_name_ = new ::std::string;
  }
  public_maid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChallengeResponse::mutable_public_maid_name() {
  set_has_public_maid_name();
  if (public_maid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_name_ = new ::std::string;
  }
  return public_maid_name_;
}
inline ::std::string* ChallengeResponse::release_public_maid_name() {
  clear_has_public_maid_name();
  if (public_maid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = public_maid_name_;
    public_maid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ChallengeResponse::set_allocated_public_maid_name(::std::string* public_maid_name) {
  if (public_maid_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_maid_name_;
  }
  if (public_maid_name) {
    set_has_public_maid_name();
    public_maid_name_ = public_maid_name;
  } else {
    clear_has_public_maid_name();
    public_maid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes public_maid_value = 2;
inline bool ChallengeResponse::has_public_maid_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeResponse::set_has_public_maid_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeResponse::clear_has_public_maid_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeResponse::clear_public_maid_value() {
  if (public_maid_value_ != &::google::protobuf::internal::GetEmptyString()) {
    public_maid_value_->clear();
  }
  clear_has_public_maid_value();
}
inline const ::std::string& ChallengeResponse::public_maid_value() const {
  return *public_maid_value_;
}
inline void ChallengeResponse::set_public_maid_value(const ::std::string& value) {
  set_has_public_maid_value();
  if (public_maid_value_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_value_ = new ::std::string;
  }
  public_maid_value_->assign(value);
}
inline void ChallengeResponse::set_public_maid_value(const char* value) {
  set_has_public_maid_value();
  if (public_maid_value_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_value_ = new ::std::string;
  }
  public_maid_value_->assign(value);
}
inline void ChallengeResponse::set_public_maid_value(const void* value, size_t size) {
  set_has_public_maid_value();
  if (public_maid_value_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_value_ = new ::std::string;
  }
  public_maid_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChallengeResponse::mutable_public_maid_value() {
  set_has_public_maid_value();
  if (public_maid_value_ == &::google::protobuf::internal::GetEmptyString()) {
    public_maid_value_ = new ::std::string;
  }
  return public_maid_value_;
}
inline ::std::string* ChallengeResponse::release_public_maid_value() {
  clear_has_public_maid_value();
  if (public_maid_value_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = public_maid_value_;
    public_maid_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ChallengeResponse::set_allocated_public_maid_value(::std::string* public_maid_value) {
  if (public_maid_value_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_maid_value_;
  }
  if (public_maid_value) {
    set_has_public_maid_value();
    public_maid_value_ = public_maid_value;
  } else {
    clear_has_public_maid_value();
    public_maid_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes signature = 3;
inline bool ChallengeResponse::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChallengeResponse::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChallengeResponse::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChallengeResponse::clear_signature() {
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& ChallengeResponse::signature() const {
  return *signature_;
}
inline void ChallengeResponse::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void ChallengeResponse::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void ChallengeResponse::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChallengeResponse::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* ChallengeResponse::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ChallengeResponse::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::GetEmptyString()) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// PublicPmidList_PublicPmid

// required bytes public_pmid_name = 1;
inline bool PublicPmidList_PublicPmid::has_public_pmid_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicPmidList_PublicPmid::set_has_public_pmid_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicPmidList_PublicPmid::clear_has_public_pmid_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicPmidList_PublicPmid::clear_public_pmid_name() {
  if (public_pmid_name_ != &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_name_->clear();
  }
  clear_has_public_pmid_name();
}
inline const ::std::string& PublicPmidList_PublicPmid::public_pmid_name() const {
  return *public_pmid_name_;
}
inline void PublicPmidList_PublicPmid::set_public_pmid_name(const ::std::string& value) {
  set_has_public_pmid_name();
  if (public_pmid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_name_ = new ::std::string;
  }
  public_pmid_name_->assign(value);
}
inline void PublicPmidList_PublicPmid::set_public_pmid_name(const char* value) {
  set_has_public_pmid_name();
  if (public_pmid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_name_ = new ::std::string;
  }
  public_pmid_name_->assign(value);
}
inline void PublicPmidList_PublicPmid::set_public_pmid_name(const void* value, size_t size) {
  set_has_public_pmid_name();
  if (public_pmid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_name_ = new ::std::string;
  }
  public_pmid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicPmidList_PublicPmid::mutable_public_pmid_name() {
  set_has_public_pmid_name();
  if (public_pmid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_name_ = new ::std::string;
  }
  return public_pmid_name_;
}
inline ::std::string* PublicPmidList_PublicPmid::release_public_pmid_name() {
  clear_has_public_pmid_name();
  if (public_pmid_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = public_pmid_name_;
    public_pmid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PublicPmidList_PublicPmid::set_allocated_public_pmid_name(::std::string* public_pmid_name) {
  if (public_pmid_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_pmid_name_;
  }
  if (public_pmid_name) {
    set_has_public_pmid_name();
    public_pmid_name_ = public_pmid_name;
  } else {
    clear_has_public_pmid_name();
    public_pmid_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes public_pmid = 2;
inline bool PublicPmidList_PublicPmid::has_public_pmid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicPmidList_PublicPmid::set_has_public_pmid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicPmidList_PublicPmid::clear_has_public_pmid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicPmidList_PublicPmid::clear_public_pmid() {
  if (public_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_->clear();
  }
  clear_has_public_pmid();
}
inline const ::std::string& PublicPmidList_PublicPmid::public_pmid() const {
  return *public_pmid_;
}
inline void PublicPmidList_PublicPmid::set_public_pmid(const ::std::string& value) {
  set_has_public_pmid();
  if (public_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_ = new ::std::string;
  }
  public_pmid_->assign(value);
}
inline void PublicPmidList_PublicPmid::set_public_pmid(const char* value) {
  set_has_public_pmid();
  if (public_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_ = new ::std::string;
  }
  public_pmid_->assign(value);
}
inline void PublicPmidList_PublicPmid::set_public_pmid(const void* value, size_t size) {
  set_has_public_pmid();
  if (public_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_ = new ::std::string;
  }
  public_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicPmidList_PublicPmid::mutable_public_pmid() {
  set_has_public_pmid();
  if (public_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    public_pmid_ = new ::std::string;
  }
  return public_pmid_;
}
inline ::std::string* PublicPmidList_PublicPmid::release_public_pmid() {
  clear_has_public_pmid();
  if (public_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = public_pmid_;
    public_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void PublicPmidList_PublicPmid::set_allocated_public_pmid(::std::string* public_pmid) {
  if (public_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete public_pmid_;
  }
  if (public_pmid) {
    set_has_public_pmid();
    public_pmid_ = public_pmid;
  } else {
    clear_has_public_pmid();
    public_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// PublicPmidList

// repeated .maidsafe.vault_manager.protobuf.PublicPmidList.PublicPmid public_pmids = 1;
inline int PublicPmidList::public_pmids_size() const {
  return public_pmids_.size();
}
inline void PublicPmidList::clear_public_pmids() {
  public_pmids_.Clear();
}
inline const ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid& PublicPmidList::public_pmids(int index) const {
  return public_pmids_.Get(index);
}
inline ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid* PublicPmidList::mutable_public_pmids(int index) {
  return public_pmids_.Mutable(index);
}
inline ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid* PublicPmidList::add_public_pmids() {
  return public_pmids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid >&
PublicPmidList::public_pmids() const {
  return public_pmids_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::vault_manager::protobuf::PublicPmidList_PublicPmid >*
PublicPmidList::mutable_public_pmids() {
  return &public_pmids_;
}

// -------------------------------------------------------------------

// StartVaultRequest

// required bytes label = 1;
inline bool StartVaultRequest::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartVaultRequest::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartVaultRequest::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartVaultRequest::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& StartVaultRequest::label() const {
  return *label_;
}
inline void StartVaultRequest::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void StartVaultRequest::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void StartVaultRequest::set_label(const void* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartVaultRequest::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* StartVaultRequest::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void StartVaultRequest::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes vault_dir = 2;
inline bool StartVaultRequest::has_vault_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartVaultRequest::set_has_vault_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartVaultRequest::clear_has_vault_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartVaultRequest::clear_vault_dir() {
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_->clear();
  }
  clear_has_vault_dir();
}
inline const ::std::string& StartVaultRequest::vault_dir() const {
  return *vault_dir_;
}
inline void StartVaultRequest::set_vault_dir(const ::std::string& value) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(value);
}
inline void StartVaultRequest::set_vault_dir(const char* value) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(value);
}
inline void StartVaultRequest::set_vault_dir(const void* value, size_t size) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartVaultRequest::mutable_vault_dir() {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  return vault_dir_;
}
inline ::std::string* StartVaultRequest::release_vault_dir() {
  clear_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vault_dir_;
    vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void StartVaultRequest::set_allocated_vault_dir(::std::string* vault_dir) {
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vault_dir_;
  }
  if (vault_dir) {
    set_has_vault_dir();
    vault_dir_ = vault_dir;
  } else {
    clear_has_vault_dir();
    vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 max_disk_usage = 3;
inline bool StartVaultRequest::has_max_disk_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartVaultRequest::set_has_max_disk_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartVaultRequest::clear_has_max_disk_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartVaultRequest::clear_max_disk_usage() {
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_max_disk_usage();
}
inline ::google::protobuf::uint64 StartVaultRequest::max_disk_usage() const {
  return max_disk_usage_;
}
inline void StartVaultRequest::set_max_disk_usage(::google::protobuf::uint64 value) {
  set_has_max_disk_usage();
  max_disk_usage_ = value;
}

// optional bytes vlog_session_id = 4;
inline bool StartVaultRequest::has_vlog_session_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartVaultRequest::set_has_vlog_session_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartVaultRequest::clear_has_vlog_session_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartVaultRequest::clear_vlog_session_id() {
  if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_->clear();
  }
  clear_has_vlog_session_id();
}
inline const ::std::string& StartVaultRequest::vlog_session_id() const {
  return *vlog_session_id_;
}
inline void StartVaultRequest::set_vlog_session_id(const ::std::string& value) {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  vlog_session_id_->assign(value);
}
inline void StartVaultRequest::set_vlog_session_id(const char* value) {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  vlog_session_id_->assign(value);
}
inline void StartVaultRequest::set_vlog_session_id(const void* value, size_t size) {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  vlog_session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartVaultRequest::mutable_vlog_session_id() {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  return vlog_session_id_;
}
inline ::std::string* StartVaultRequest::release_vlog_session_id() {
  clear_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vlog_session_id_;
    vlog_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void StartVaultRequest::set_allocated_vlog_session_id(::std::string* vlog_session_id) {
  if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vlog_session_id_;
  }
  if (vlog_session_id) {
    set_has_vlog_session_id();
    vlog_session_id_ = vlog_session_id;
  } else {
    clear_has_vlog_session_id();
    vlog_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool send_hostname_to_visualiser_server = 5;
inline bool StartVaultRequest::has_send_hostname_to_visualiser_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartVaultRequest::set_has_send_hostname_to_visualiser_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartVaultRequest::clear_has_send_hostname_to_visualiser_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartVaultRequest::clear_send_hostname_to_visualiser_server() {
  send_hostname_to_visualiser_server_ = false;
  clear_has_send_hostname_to_visualiser_server();
}
inline bool StartVaultRequest::send_hostname_to_visualiser_server() const {
  return send_hostname_to_visualiser_server_;
}
inline void StartVaultRequest::set_send_hostname_to_visualiser_server(bool value) {
  set_has_send_hostname_to_visualiser_server();
  send_hostname_to_visualiser_server_ = value;
}

// optional int32 pmid_list_index = 6;
inline bool StartVaultRequest::has_pmid_list_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StartVaultRequest::set_has_pmid_list_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StartVaultRequest::clear_has_pmid_list_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StartVaultRequest::clear_pmid_list_index() {
  pmid_list_index_ = 0;
  clear_has_pmid_list_index();
}
inline ::google::protobuf::int32 StartVaultRequest::pmid_list_index() const {
  return pmid_list_index_;
}
inline void StartVaultRequest::set_pmid_list_index(::google::protobuf::int32 value) {
  set_has_pmid_list_index();
  pmid_list_index_ = value;
}

// -------------------------------------------------------------------

// TakeOwnershipRequest

// required bytes label = 1;
inline bool TakeOwnershipRequest::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TakeOwnershipRequest::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TakeOwnershipRequest::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TakeOwnershipRequest::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& TakeOwnershipRequest::label() const {
  return *label_;
}
inline void TakeOwnershipRequest::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void TakeOwnershipRequest::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void TakeOwnershipRequest::set_label(const void* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TakeOwnershipRequest::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* TakeOwnershipRequest::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TakeOwnershipRequest::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes vault_dir = 2;
inline bool TakeOwnershipRequest::has_vault_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TakeOwnershipRequest::set_has_vault_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TakeOwnershipRequest::clear_has_vault_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TakeOwnershipRequest::clear_vault_dir() {
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_->clear();
  }
  clear_has_vault_dir();
}
inline const ::std::string& TakeOwnershipRequest::vault_dir() const {
  return *vault_dir_;
}
inline void TakeOwnershipRequest::set_vault_dir(const ::std::string& value) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(value);
}
inline void TakeOwnershipRequest::set_vault_dir(const char* value) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(value);
}
inline void TakeOwnershipRequest::set_vault_dir(const void* value, size_t size) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TakeOwnershipRequest::mutable_vault_dir() {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  return vault_dir_;
}
inline ::std::string* TakeOwnershipRequest::release_vault_dir() {
  clear_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vault_dir_;
    vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TakeOwnershipRequest::set_allocated_vault_dir(::std::string* vault_dir) {
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vault_dir_;
  }
  if (vault_dir) {
    set_has_vault_dir();
    vault_dir_ = vault_dir;
  } else {
    clear_has_vault_dir();
    vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 max_disk_usage = 3;
inline bool TakeOwnershipRequest::has_max_disk_usage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TakeOwnershipRequest::set_has_max_disk_usage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TakeOwnershipRequest::clear_has_max_disk_usage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TakeOwnershipRequest::clear_max_disk_usage() {
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_max_disk_usage();
}
inline ::google::protobuf::uint64 TakeOwnershipRequest::max_disk_usage() const {
  return max_disk_usage_;
}
inline void TakeOwnershipRequest::set_max_disk_usage(::google::protobuf::uint64 value) {
  set_has_max_disk_usage();
  max_disk_usage_ = value;
}

// -------------------------------------------------------------------

// VaultRunningResponse_VaultKeys

// required bytes AES256Key = 1;
inline bool VaultRunningResponse_VaultKeys::has_aes256key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VaultRunningResponse_VaultKeys::set_has_aes256key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VaultRunningResponse_VaultKeys::clear_has_aes256key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VaultRunningResponse_VaultKeys::clear_aes256key() {
  if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
    aes256key_->clear();
  }
  clear_has_aes256key();
}
inline const ::std::string& VaultRunningResponse_VaultKeys::aes256key() const {
  return *aes256key_;
}
inline void VaultRunningResponse_VaultKeys::set_aes256key(const ::std::string& value) {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  aes256key_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_aes256key(const char* value) {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  aes256key_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_aes256key(const void* value, size_t size) {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  aes256key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultRunningResponse_VaultKeys::mutable_aes256key() {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  return aes256key_;
}
inline ::std::string* VaultRunningResponse_VaultKeys::release_aes256key() {
  clear_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = aes256key_;
    aes256key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultRunningResponse_VaultKeys::set_allocated_aes256key(::std::string* aes256key) {
  if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256key_;
  }
  if (aes256key) {
    set_has_aes256key();
    aes256key_ = aes256key;
  } else {
    clear_has_aes256key();
    aes256key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes AES256IV = 2;
inline bool VaultRunningResponse_VaultKeys::has_aes256iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VaultRunningResponse_VaultKeys::set_has_aes256iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VaultRunningResponse_VaultKeys::clear_has_aes256iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VaultRunningResponse_VaultKeys::clear_aes256iv() {
  if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_->clear();
  }
  clear_has_aes256iv();
}
inline const ::std::string& VaultRunningResponse_VaultKeys::aes256iv() const {
  return *aes256iv_;
}
inline void VaultRunningResponse_VaultKeys::set_aes256iv(const ::std::string& value) {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  aes256iv_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_aes256iv(const char* value) {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  aes256iv_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_aes256iv(const void* value, size_t size) {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  aes256iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultRunningResponse_VaultKeys::mutable_aes256iv() {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  return aes256iv_;
}
inline ::std::string* VaultRunningResponse_VaultKeys::release_aes256iv() {
  clear_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = aes256iv_;
    aes256iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultRunningResponse_VaultKeys::set_allocated_aes256iv(::std::string* aes256iv) {
  if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256iv_;
  }
  if (aes256iv) {
    set_has_aes256iv();
    aes256iv_ = aes256iv;
  } else {
    clear_has_aes256iv();
    aes256iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes encrypted_anpmid = 3;
inline bool VaultRunningResponse_VaultKeys::has_encrypted_anpmid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VaultRunningResponse_VaultKeys::set_has_encrypted_anpmid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VaultRunningResponse_VaultKeys::clear_has_encrypted_anpmid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VaultRunningResponse_VaultKeys::clear_encrypted_anpmid() {
  if (encrypted_anpmid_ != &::google::protobuf::internal::GetEmptyString()) {
    encrypted_anpmid_->clear();
  }
  clear_has_encrypted_anpmid();
}
inline const ::std::string& VaultRunningResponse_VaultKeys::encrypted_anpmid() const {
  return *encrypted_anpmid_;
}
inline void VaultRunningResponse_VaultKeys::set_encrypted_anpmid(const ::std::string& value) {
  set_has_encrypted_anpmid();
  if (encrypted_anpmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_anpmid_ = new ::std::string;
  }
  encrypted_anpmid_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_encrypted_anpmid(const char* value) {
  set_has_encrypted_anpmid();
  if (encrypted_anpmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_anpmid_ = new ::std::string;
  }
  encrypted_anpmid_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_encrypted_anpmid(const void* value, size_t size) {
  set_has_encrypted_anpmid();
  if (encrypted_anpmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_anpmid_ = new ::std::string;
  }
  encrypted_anpmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultRunningResponse_VaultKeys::mutable_encrypted_anpmid() {
  set_has_encrypted_anpmid();
  if (encrypted_anpmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_anpmid_ = new ::std::string;
  }
  return encrypted_anpmid_;
}
inline ::std::string* VaultRunningResponse_VaultKeys::release_encrypted_anpmid() {
  clear_has_encrypted_anpmid();
  if (encrypted_anpmid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_anpmid_;
    encrypted_anpmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultRunningResponse_VaultKeys::set_allocated_encrypted_anpmid(::std::string* encrypted_anpmid) {
  if (encrypted_anpmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encrypted_anpmid_;
  }
  if (encrypted_anpmid) {
    set_has_encrypted_anpmid();
    encrypted_anpmid_ = encrypted_anpmid;
  } else {
    clear_has_encrypted_anpmid();
    encrypted_anpmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes encrypted_pmid = 4;
inline bool VaultRunningResponse_VaultKeys::has_encrypted_pmid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VaultRunningResponse_VaultKeys::set_has_encrypted_pmid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VaultRunningResponse_VaultKeys::clear_has_encrypted_pmid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VaultRunningResponse_VaultKeys::clear_encrypted_pmid() {
  if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_->clear();
  }
  clear_has_encrypted_pmid();
}
inline const ::std::string& VaultRunningResponse_VaultKeys::encrypted_pmid() const {
  return *encrypted_pmid_;
}
inline void VaultRunningResponse_VaultKeys::set_encrypted_pmid(const ::std::string& value) {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  encrypted_pmid_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_encrypted_pmid(const char* value) {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  encrypted_pmid_->assign(value);
}
inline void VaultRunningResponse_VaultKeys::set_encrypted_pmid(const void* value, size_t size) {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  encrypted_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultRunningResponse_VaultKeys::mutable_encrypted_pmid() {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  return encrypted_pmid_;
}
inline ::std::string* VaultRunningResponse_VaultKeys::release_encrypted_pmid() {
  clear_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_pmid_;
    encrypted_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultRunningResponse_VaultKeys::set_allocated_encrypted_pmid(::std::string* encrypted_pmid) {
  if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encrypted_pmid_;
  }
  if (encrypted_pmid) {
    set_has_encrypted_pmid();
    encrypted_pmid_ = encrypted_pmid;
  } else {
    clear_has_encrypted_pmid();
    encrypted_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// VaultRunningResponse

// required bytes label = 1;
inline bool VaultRunningResponse::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VaultRunningResponse::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VaultRunningResponse::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VaultRunningResponse::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& VaultRunningResponse::label() const {
  return *label_;
}
inline void VaultRunningResponse::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void VaultRunningResponse::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void VaultRunningResponse::set_label(const void* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultRunningResponse::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* VaultRunningResponse::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultRunningResponse::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes serialised_maidsafe_error = 2;
inline bool VaultRunningResponse::has_serialised_maidsafe_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VaultRunningResponse::set_has_serialised_maidsafe_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VaultRunningResponse::clear_has_serialised_maidsafe_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VaultRunningResponse::clear_serialised_maidsafe_error() {
  if (serialised_maidsafe_error_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_maidsafe_error_->clear();
  }
  clear_has_serialised_maidsafe_error();
}
inline const ::std::string& VaultRunningResponse::serialised_maidsafe_error() const {
  return *serialised_maidsafe_error_;
}
inline void VaultRunningResponse::set_serialised_maidsafe_error(const ::std::string& value) {
  set_has_serialised_maidsafe_error();
  if (serialised_maidsafe_error_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_maidsafe_error_ = new ::std::string;
  }
  serialised_maidsafe_error_->assign(value);
}
inline void VaultRunningResponse::set_serialised_maidsafe_error(const char* value) {
  set_has_serialised_maidsafe_error();
  if (serialised_maidsafe_error_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_maidsafe_error_ = new ::std::string;
  }
  serialised_maidsafe_error_->assign(value);
}
inline void VaultRunningResponse::set_serialised_maidsafe_error(const void* value, size_t size) {
  set_has_serialised_maidsafe_error();
  if (serialised_maidsafe_error_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_maidsafe_error_ = new ::std::string;
  }
  serialised_maidsafe_error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultRunningResponse::mutable_serialised_maidsafe_error() {
  set_has_serialised_maidsafe_error();
  if (serialised_maidsafe_error_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_maidsafe_error_ = new ::std::string;
  }
  return serialised_maidsafe_error_;
}
inline ::std::string* VaultRunningResponse::release_serialised_maidsafe_error() {
  clear_has_serialised_maidsafe_error();
  if (serialised_maidsafe_error_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_maidsafe_error_;
    serialised_maidsafe_error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultRunningResponse::set_allocated_serialised_maidsafe_error(::std::string* serialised_maidsafe_error) {
  if (serialised_maidsafe_error_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_maidsafe_error_;
  }
  if (serialised_maidsafe_error) {
    set_has_serialised_maidsafe_error();
    serialised_maidsafe_error_ = serialised_maidsafe_error;
  } else {
    clear_has_serialised_maidsafe_error();
    serialised_maidsafe_error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .maidsafe.vault_manager.protobuf.VaultRunningResponse.VaultKeys vault_keys = 3;
inline bool VaultRunningResponse::has_vault_keys() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VaultRunningResponse::set_has_vault_keys() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VaultRunningResponse::clear_has_vault_keys() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VaultRunningResponse::clear_vault_keys() {
  if (vault_keys_ != NULL) vault_keys_->::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys::Clear();
  clear_has_vault_keys();
}
inline const ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys& VaultRunningResponse::vault_keys() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vault_keys_ != NULL ? *vault_keys_ : *default_instance().vault_keys_;
#else
  return vault_keys_ != NULL ? *vault_keys_ : *default_instance_->vault_keys_;
#endif
}
inline ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* VaultRunningResponse::mutable_vault_keys() {
  set_has_vault_keys();
  if (vault_keys_ == NULL) vault_keys_ = new ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys;
  return vault_keys_;
}
inline ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* VaultRunningResponse::release_vault_keys() {
  clear_has_vault_keys();
  ::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* temp = vault_keys_;
  vault_keys_ = NULL;
  return temp;
}
inline void VaultRunningResponse::set_allocated_vault_keys(::maidsafe::vault_manager::protobuf::VaultRunningResponse_VaultKeys* vault_keys) {
  delete vault_keys_;
  vault_keys_ = vault_keys;
  if (vault_keys) {
    set_has_vault_keys();
  } else {
    clear_has_vault_keys();
  }
}

// -------------------------------------------------------------------

// VaultStarted

// required uint64 process_id = 1;
inline bool VaultStarted::has_process_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VaultStarted::set_has_process_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VaultStarted::clear_has_process_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VaultStarted::clear_process_id() {
  process_id_ = GOOGLE_ULONGLONG(0);
  clear_has_process_id();
}
inline ::google::protobuf::uint64 VaultStarted::process_id() const {
  return process_id_;
}
inline void VaultStarted::set_process_id(::google::protobuf::uint64 value) {
  set_has_process_id();
  process_id_ = value;
}

// -------------------------------------------------------------------

// VaultStartedResponse

// required bytes AES256Key = 1;
inline bool VaultStartedResponse::has_aes256key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VaultStartedResponse::set_has_aes256key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VaultStartedResponse::clear_has_aes256key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VaultStartedResponse::clear_aes256key() {
  if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
    aes256key_->clear();
  }
  clear_has_aes256key();
}
inline const ::std::string& VaultStartedResponse::aes256key() const {
  return *aes256key_;
}
inline void VaultStartedResponse::set_aes256key(const ::std::string& value) {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  aes256key_->assign(value);
}
inline void VaultStartedResponse::set_aes256key(const char* value) {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  aes256key_->assign(value);
}
inline void VaultStartedResponse::set_aes256key(const void* value, size_t size) {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  aes256key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStartedResponse::mutable_aes256key() {
  set_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256key_ = new ::std::string;
  }
  return aes256key_;
}
inline ::std::string* VaultStartedResponse::release_aes256key() {
  clear_has_aes256key();
  if (aes256key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = aes256key_;
    aes256key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultStartedResponse::set_allocated_aes256key(::std::string* aes256key) {
  if (aes256key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256key_;
  }
  if (aes256key) {
    set_has_aes256key();
    aes256key_ = aes256key;
  } else {
    clear_has_aes256key();
    aes256key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes AES256IV = 2;
inline bool VaultStartedResponse::has_aes256iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VaultStartedResponse::set_has_aes256iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VaultStartedResponse::clear_has_aes256iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VaultStartedResponse::clear_aes256iv() {
  if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_->clear();
  }
  clear_has_aes256iv();
}
inline const ::std::string& VaultStartedResponse::aes256iv() const {
  return *aes256iv_;
}
inline void VaultStartedResponse::set_aes256iv(const ::std::string& value) {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  aes256iv_->assign(value);
}
inline void VaultStartedResponse::set_aes256iv(const char* value) {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  aes256iv_->assign(value);
}
inline void VaultStartedResponse::set_aes256iv(const void* value, size_t size) {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  aes256iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStartedResponse::mutable_aes256iv() {
  set_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    aes256iv_ = new ::std::string;
  }
  return aes256iv_;
}
inline ::std::string* VaultStartedResponse::release_aes256iv() {
  clear_has_aes256iv();
  if (aes256iv_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = aes256iv_;
    aes256iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultStartedResponse::set_allocated_aes256iv(::std::string* aes256iv) {
  if (aes256iv_ != &::google::protobuf::internal::GetEmptyString()) {
    delete aes256iv_;
  }
  if (aes256iv) {
    set_has_aes256iv();
    aes256iv_ = aes256iv;
  } else {
    clear_has_aes256iv();
    aes256iv_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes encrypted_pmid = 3;
inline bool VaultStartedResponse::has_encrypted_pmid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VaultStartedResponse::set_has_encrypted_pmid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VaultStartedResponse::clear_has_encrypted_pmid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VaultStartedResponse::clear_encrypted_pmid() {
  if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_->clear();
  }
  clear_has_encrypted_pmid();
}
inline const ::std::string& VaultStartedResponse::encrypted_pmid() const {
  return *encrypted_pmid_;
}
inline void VaultStartedResponse::set_encrypted_pmid(const ::std::string& value) {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  encrypted_pmid_->assign(value);
}
inline void VaultStartedResponse::set_encrypted_pmid(const char* value) {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  encrypted_pmid_->assign(value);
}
inline void VaultStartedResponse::set_encrypted_pmid(const void* value, size_t size) {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  encrypted_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStartedResponse::mutable_encrypted_pmid() {
  set_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    encrypted_pmid_ = new ::std::string;
  }
  return encrypted_pmid_;
}
inline ::std::string* VaultStartedResponse::release_encrypted_pmid() {
  clear_has_encrypted_pmid();
  if (encrypted_pmid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = encrypted_pmid_;
    encrypted_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultStartedResponse::set_allocated_encrypted_pmid(::std::string* encrypted_pmid) {
  if (encrypted_pmid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encrypted_pmid_;
  }
  if (encrypted_pmid) {
    set_has_encrypted_pmid();
    encrypted_pmid_ = encrypted_pmid;
  } else {
    clear_has_encrypted_pmid();
    encrypted_pmid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes vault_dir = 4;
inline bool VaultStartedResponse::has_vault_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VaultStartedResponse::set_has_vault_dir() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VaultStartedResponse::clear_has_vault_dir() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VaultStartedResponse::clear_vault_dir() {
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_->clear();
  }
  clear_has_vault_dir();
}
inline const ::std::string& VaultStartedResponse::vault_dir() const {
  return *vault_dir_;
}
inline void VaultStartedResponse::set_vault_dir(const ::std::string& value) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(value);
}
inline void VaultStartedResponse::set_vault_dir(const char* value) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(value);
}
inline void VaultStartedResponse::set_vault_dir(const void* value, size_t size) {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  vault_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStartedResponse::mutable_vault_dir() {
  set_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    vault_dir_ = new ::std::string;
  }
  return vault_dir_;
}
inline ::std::string* VaultStartedResponse::release_vault_dir() {
  clear_has_vault_dir();
  if (vault_dir_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vault_dir_;
    vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultStartedResponse::set_allocated_vault_dir(::std::string* vault_dir) {
  if (vault_dir_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vault_dir_;
  }
  if (vault_dir) {
    set_has_vault_dir();
    vault_dir_ = vault_dir;
  } else {
    clear_has_vault_dir();
    vault_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint64 max_disk_usage = 5;
inline bool VaultStartedResponse::has_max_disk_usage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VaultStartedResponse::set_has_max_disk_usage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VaultStartedResponse::clear_has_max_disk_usage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VaultStartedResponse::clear_max_disk_usage() {
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_max_disk_usage();
}
inline ::google::protobuf::uint64 VaultStartedResponse::max_disk_usage() const {
  return max_disk_usage_;
}
inline void VaultStartedResponse::set_max_disk_usage(::google::protobuf::uint64 value) {
  set_has_max_disk_usage();
  max_disk_usage_ = value;
}

// optional bytes vlog_session_id = 6;
inline bool VaultStartedResponse::has_vlog_session_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VaultStartedResponse::set_has_vlog_session_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VaultStartedResponse::clear_has_vlog_session_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VaultStartedResponse::clear_vlog_session_id() {
  if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_->clear();
  }
  clear_has_vlog_session_id();
}
inline const ::std::string& VaultStartedResponse::vlog_session_id() const {
  return *vlog_session_id_;
}
inline void VaultStartedResponse::set_vlog_session_id(const ::std::string& value) {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  vlog_session_id_->assign(value);
}
inline void VaultStartedResponse::set_vlog_session_id(const char* value) {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  vlog_session_id_->assign(value);
}
inline void VaultStartedResponse::set_vlog_session_id(const void* value, size_t size) {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  vlog_session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStartedResponse::mutable_vlog_session_id() {
  set_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    vlog_session_id_ = new ::std::string;
  }
  return vlog_session_id_;
}
inline ::std::string* VaultStartedResponse::release_vlog_session_id() {
  clear_has_vlog_session_id();
  if (vlog_session_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = vlog_session_id_;
    vlog_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultStartedResponse::set_allocated_vlog_session_id(::std::string* vlog_session_id) {
  if (vlog_session_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete vlog_session_id_;
  }
  if (vlog_session_id) {
    set_has_vlog_session_id();
    vlog_session_id_ = vlog_session_id;
  } else {
    clear_has_vlog_session_id();
    vlog_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes serialised_public_pmids = 7;
inline bool VaultStartedResponse::has_serialised_public_pmids() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VaultStartedResponse::set_has_serialised_public_pmids() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VaultStartedResponse::clear_has_serialised_public_pmids() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VaultStartedResponse::clear_serialised_public_pmids() {
  if (serialised_public_pmids_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_public_pmids_->clear();
  }
  clear_has_serialised_public_pmids();
}
inline const ::std::string& VaultStartedResponse::serialised_public_pmids() const {
  return *serialised_public_pmids_;
}
inline void VaultStartedResponse::set_serialised_public_pmids(const ::std::string& value) {
  set_has_serialised_public_pmids();
  if (serialised_public_pmids_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_public_pmids_ = new ::std::string;
  }
  serialised_public_pmids_->assign(value);
}
inline void VaultStartedResponse::set_serialised_public_pmids(const char* value) {
  set_has_serialised_public_pmids();
  if (serialised_public_pmids_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_public_pmids_ = new ::std::string;
  }
  serialised_public_pmids_->assign(value);
}
inline void VaultStartedResponse::set_serialised_public_pmids(const void* value, size_t size) {
  set_has_serialised_public_pmids();
  if (serialised_public_pmids_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_public_pmids_ = new ::std::string;
  }
  serialised_public_pmids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStartedResponse::mutable_serialised_public_pmids() {
  set_has_serialised_public_pmids();
  if (serialised_public_pmids_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_public_pmids_ = new ::std::string;
  }
  return serialised_public_pmids_;
}
inline ::std::string* VaultStartedResponse::release_serialised_public_pmids() {
  clear_has_serialised_public_pmids();
  if (serialised_public_pmids_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_public_pmids_;
    serialised_public_pmids_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void VaultStartedResponse::set_allocated_serialised_public_pmids(::std::string* serialised_public_pmids) {
  if (serialised_public_pmids_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_public_pmids_;
  }
  if (serialised_public_pmids) {
    set_has_serialised_public_pmids();
    serialised_public_pmids_ = serialised_public_pmids;
  } else {
    clear_has_serialised_public_pmids();
    serialised_public_pmids_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool send_hostname_to_visualiser_server = 8;
inline bool VaultStartedResponse::has_send_hostname_to_visualiser_server() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VaultStartedResponse::set_has_send_hostname_to_visualiser_server() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VaultStartedResponse::clear_has_send_hostname_to_visualiser_server() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VaultStartedResponse::clear_send_hostname_to_visualiser_server() {
  send_hostname_to_visualiser_server_ = false;
  clear_has_send_hostname_to_visualiser_server();
}
inline bool VaultStartedResponse::send_hostname_to_visualiser_server() const {
  return send_hostname_to_visualiser_server_;
}
inline void VaultStartedResponse::set_send_hostname_to_visualiser_server(bool value) {
  set_has_send_hostname_to_visualiser_server();
  send_hostname_to_visualiser_server_ = value;
}

// -------------------------------------------------------------------

// MaxDiskUsageUpdate

// required uint64 max_disk_usage = 1;
inline bool MaxDiskUsageUpdate::has_max_disk_usage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaxDiskUsageUpdate::set_has_max_disk_usage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaxDiskUsageUpdate::clear_has_max_disk_usage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaxDiskUsageUpdate::clear_max_disk_usage() {
  max_disk_usage_ = GOOGLE_ULONGLONG(0);
  clear_has_max_disk_usage();
}
inline ::google::protobuf::uint64 MaxDiskUsageUpdate::max_disk_usage() const {
  return max_disk_usage_;
}
inline void MaxDiskUsageUpdate::set_max_disk_usage(::google::protobuf::uint64 value) {
  set_has_max_disk_usage();
  max_disk_usage_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace vault_manager
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_maidsafe_2fvault_5fmanager_2finterprocess_5fmessages_2eproto__INCLUDED
