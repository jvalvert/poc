// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maidsafe/drive/proto_structs.proto

#ifndef PROTOBUF_maidsafe_2fdrive_2fproto_5fstructs_2eproto__INCLUDED
#define PROTOBUF_maidsafe_2fdrive_2fproto_5fstructs_2eproto__INCLUDED

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4127 4244 4267)
#endif

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace maidsafe {
namespace drive {
namespace detail {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
void protobuf_AssignDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
void protobuf_ShutdownFile_maidsafe_2fdrive_2fproto_5fstructs_2eproto();

class AttributesArchive;
class MetaData;
class Directory;

// ===================================================================

class AttributesArchive : public ::google::protobuf::MessageLite {
 public:
  AttributesArchive();
  virtual ~AttributesArchive();

  AttributesArchive(const AttributesArchive& from);

  inline AttributesArchive& operator=(const AttributesArchive& from) {
    CopyFrom(from);
    return *this;
  }

  static const AttributesArchive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttributesArchive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttributesArchive* other);

  // implements Message ----------------------------------------------

  AttributesArchive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttributesArchive& from);
  void MergeFrom(const AttributesArchive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 st_size = 1;
  inline bool has_st_size() const;
  inline void clear_st_size();
  static const int kStSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 st_size() const;
  inline void set_st_size(::google::protobuf::uint64 value);

  // required bytes creation_time = 2;
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 2;
  inline const ::std::string& creation_time() const;
  inline void set_creation_time(const ::std::string& value);
  inline void set_creation_time(const char* value);
  inline void set_creation_time(const void* value, size_t size);
  inline ::std::string* mutable_creation_time();
  inline ::std::string* release_creation_time();
  inline void set_allocated_creation_time(::std::string* creation_time);

  // required bytes last_access_time = 3;
  inline bool has_last_access_time() const;
  inline void clear_last_access_time();
  static const int kLastAccessTimeFieldNumber = 3;
  inline const ::std::string& last_access_time() const;
  inline void set_last_access_time(const ::std::string& value);
  inline void set_last_access_time(const char* value);
  inline void set_last_access_time(const void* value, size_t size);
  inline ::std::string* mutable_last_access_time();
  inline ::std::string* release_last_access_time();
  inline void set_allocated_last_access_time(::std::string* last_access_time);

  // required bytes last_write_time = 4;
  inline bool has_last_write_time() const;
  inline void clear_last_write_time();
  static const int kLastWriteTimeFieldNumber = 4;
  inline const ::std::string& last_write_time() const;
  inline void set_last_write_time(const ::std::string& value);
  inline void set_last_write_time(const char* value);
  inline void set_last_write_time(const void* value, size_t size);
  inline ::std::string* mutable_last_write_time();
  inline ::std::string* release_last_write_time();
  inline void set_allocated_last_write_time(::std::string* last_write_time);

  // required uint32 st_mode = 5;
  inline bool has_st_mode() const;
  inline void clear_st_mode();
  static const int kStModeFieldNumber = 5;
  inline ::google::protobuf::uint32 st_mode() const;
  inline void set_st_mode(::google::protobuf::uint32 value);

  // optional uint64 win_attributes = 6;
  inline bool has_win_attributes() const;
  inline void clear_win_attributes();
  static const int kWinAttributesFieldNumber = 6;
  inline ::google::protobuf::uint64 win_attributes() const;
  inline void set_win_attributes(::google::protobuf::uint64 value);

  // optional bytes link_to = 7;
  inline bool has_link_to() const;
  inline void clear_link_to();
  static const int kLinkToFieldNumber = 7;
  inline const ::std::string& link_to() const;
  inline void set_link_to(const ::std::string& value);
  inline void set_link_to(const char* value);
  inline void set_link_to(const void* value, size_t size);
  inline ::std::string* mutable_link_to();
  inline ::std::string* release_link_to();
  inline void set_allocated_link_to(::std::string* link_to);

  // optional uint32 st_dev = 8;
  inline bool has_st_dev() const;
  inline void clear_st_dev();
  static const int kStDevFieldNumber = 8;
  inline ::google::protobuf::uint32 st_dev() const;
  inline void set_st_dev(::google::protobuf::uint32 value);

  // optional uint32 st_ino = 9;
  inline bool has_st_ino() const;
  inline void clear_st_ino();
  static const int kStInoFieldNumber = 9;
  inline ::google::protobuf::uint32 st_ino() const;
  inline void set_st_ino(::google::protobuf::uint32 value);

  // optional uint32 st_nlink = 10;
  inline bool has_st_nlink() const;
  inline void clear_st_nlink();
  static const int kStNlinkFieldNumber = 10;
  inline ::google::protobuf::uint32 st_nlink() const;
  inline void set_st_nlink(::google::protobuf::uint32 value);

  // optional uint32 st_uid = 11;
  inline bool has_st_uid() const;
  inline void clear_st_uid();
  static const int kStUidFieldNumber = 11;
  inline ::google::protobuf::uint32 st_uid() const;
  inline void set_st_uid(::google::protobuf::uint32 value);

  // optional uint32 st_gid = 12;
  inline bool has_st_gid() const;
  inline void clear_st_gid();
  static const int kStGidFieldNumber = 12;
  inline ::google::protobuf::uint32 st_gid() const;
  inline void set_st_gid(::google::protobuf::uint32 value);

  // optional uint32 st_rdev = 13;
  inline bool has_st_rdev() const;
  inline void clear_st_rdev();
  static const int kStRdevFieldNumber = 13;
  inline ::google::protobuf::uint32 st_rdev() const;
  inline void set_st_rdev(::google::protobuf::uint32 value);

  // optional uint32 st_blksize = 14;
  inline bool has_st_blksize() const;
  inline void clear_st_blksize();
  static const int kStBlksizeFieldNumber = 14;
  inline ::google::protobuf::uint32 st_blksize() const;
  inline void set_st_blksize(::google::protobuf::uint32 value);

  // optional uint32 st_blocks = 15;
  inline bool has_st_blocks() const;
  inline void clear_st_blocks();
  static const int kStBlocksFieldNumber = 15;
  inline ::google::protobuf::uint32 st_blocks() const;
  inline void set_st_blocks(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:maidsafe.drive.detail.protobuf.AttributesArchive)
 private:
  inline void set_has_st_size();
  inline void clear_has_st_size();
  inline void set_has_creation_time();
  inline void clear_has_creation_time();
  inline void set_has_last_access_time();
  inline void clear_has_last_access_time();
  inline void set_has_last_write_time();
  inline void clear_has_last_write_time();
  inline void set_has_st_mode();
  inline void clear_has_st_mode();
  inline void set_has_win_attributes();
  inline void clear_has_win_attributes();
  inline void set_has_link_to();
  inline void clear_has_link_to();
  inline void set_has_st_dev();
  inline void clear_has_st_dev();
  inline void set_has_st_ino();
  inline void clear_has_st_ino();
  inline void set_has_st_nlink();
  inline void clear_has_st_nlink();
  inline void set_has_st_uid();
  inline void clear_has_st_uid();
  inline void set_has_st_gid();
  inline void clear_has_st_gid();
  inline void set_has_st_rdev();
  inline void clear_has_st_rdev();
  inline void set_has_st_blksize();
  inline void clear_has_st_blksize();
  inline void set_has_st_blocks();
  inline void clear_has_st_blocks();

  ::google::protobuf::uint64 st_size_;
  ::std::string* creation_time_;
  ::std::string* last_access_time_;
  ::std::string* last_write_time_;
  ::google::protobuf::uint64 win_attributes_;
  ::google::protobuf::uint32 st_mode_;
  ::google::protobuf::uint32 st_dev_;
  ::std::string* link_to_;
  ::google::protobuf::uint32 st_ino_;
  ::google::protobuf::uint32 st_nlink_;
  ::google::protobuf::uint32 st_uid_;
  ::google::protobuf::uint32 st_gid_;
  ::google::protobuf::uint32 st_rdev_;
  ::google::protobuf::uint32 st_blksize_;
  ::google::protobuf::uint32 st_blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fdrive_2fproto_5fstructs_2eproto();

  void InitAsDefaultInstance();
  static AttributesArchive* default_instance_;
};
// -------------------------------------------------------------------

class MetaData : public ::google::protobuf::MessageLite {
 public:
  MetaData();
  virtual ~MetaData();

  MetaData(const MetaData& from);

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }

  static const MetaData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MetaData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MetaData* other);

  // implements Message ----------------------------------------------

  MetaData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .maidsafe.drive.detail.protobuf.AttributesArchive attributes_archive = 2;
  inline bool has_attributes_archive() const;
  inline void clear_attributes_archive();
  static const int kAttributesArchiveFieldNumber = 2;
  inline const ::maidsafe::drive::detail::protobuf::AttributesArchive& attributes_archive() const;
  inline ::maidsafe::drive::detail::protobuf::AttributesArchive* mutable_attributes_archive();
  inline ::maidsafe::drive::detail::protobuf::AttributesArchive* release_attributes_archive();
  inline void set_allocated_attributes_archive(::maidsafe::drive::detail::protobuf::AttributesArchive* attributes_archive);

  // optional bytes serialised_data_map = 3;
  inline bool has_serialised_data_map() const;
  inline void clear_serialised_data_map();
  static const int kSerialisedDataMapFieldNumber = 3;
  inline const ::std::string& serialised_data_map() const;
  inline void set_serialised_data_map(const ::std::string& value);
  inline void set_serialised_data_map(const char* value);
  inline void set_serialised_data_map(const void* value, size_t size);
  inline ::std::string* mutable_serialised_data_map();
  inline ::std::string* release_serialised_data_map();
  inline void set_allocated_serialised_data_map(::std::string* serialised_data_map);

  // optional bytes directory_id = 4;
  inline bool has_directory_id() const;
  inline void clear_directory_id();
  static const int kDirectoryIdFieldNumber = 4;
  inline const ::std::string& directory_id() const;
  inline void set_directory_id(const ::std::string& value);
  inline void set_directory_id(const char* value);
  inline void set_directory_id(const void* value, size_t size);
  inline ::std::string* mutable_directory_id();
  inline ::std::string* release_directory_id();
  inline void set_allocated_directory_id(::std::string* directory_id);

  // @@protoc_insertion_point(class_scope:maidsafe.drive.detail.protobuf.MetaData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_attributes_archive();
  inline void clear_has_attributes_archive();
  inline void set_has_serialised_data_map();
  inline void clear_has_serialised_data_map();
  inline void set_has_directory_id();
  inline void clear_has_directory_id();

  ::std::string* name_;
  ::maidsafe::drive::detail::protobuf::AttributesArchive* attributes_archive_;
  ::std::string* serialised_data_map_;
  ::std::string* directory_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fdrive_2fproto_5fstructs_2eproto();

  void InitAsDefaultInstance();
  static MetaData* default_instance_;
};
// -------------------------------------------------------------------

class Directory : public ::google::protobuf::MessageLite {
 public:
  Directory();
  virtual ~Directory();

  Directory(const Directory& from);

  inline Directory& operator=(const Directory& from) {
    CopyFrom(from);
    return *this;
  }

  static const Directory& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Directory* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Directory* other);

  // implements Message ----------------------------------------------

  Directory* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Directory& from);
  void MergeFrom(const Directory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes directory_id = 1;
  inline bool has_directory_id() const;
  inline void clear_directory_id();
  static const int kDirectoryIdFieldNumber = 1;
  inline const ::std::string& directory_id() const;
  inline void set_directory_id(const ::std::string& value);
  inline void set_directory_id(const char* value);
  inline void set_directory_id(const void* value, size_t size);
  inline ::std::string* mutable_directory_id();
  inline ::std::string* release_directory_id();
  inline void set_allocated_directory_id(::std::string* directory_id);

  // required uint32 max_versions = 2;
  inline bool has_max_versions() const;
  inline void clear_max_versions();
  static const int kMaxVersionsFieldNumber = 2;
  inline ::google::protobuf::uint32 max_versions() const;
  inline void set_max_versions(::google::protobuf::uint32 value);

  // repeated .maidsafe.drive.detail.protobuf.MetaData children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::maidsafe::drive::detail::protobuf::MetaData& children(int index) const;
  inline ::maidsafe::drive::detail::protobuf::MetaData* mutable_children(int index);
  inline ::maidsafe::drive::detail::protobuf::MetaData* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::drive::detail::protobuf::MetaData >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::drive::detail::protobuf::MetaData >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:maidsafe.drive.detail.protobuf.Directory)
 private:
  inline void set_has_directory_id();
  inline void clear_has_directory_id();
  inline void set_has_max_versions();
  inline void clear_has_max_versions();

  ::std::string* directory_id_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::drive::detail::protobuf::MetaData > children_;
  ::google::protobuf::uint32 max_versions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
  #endif
  friend void protobuf_AssignDesc_maidsafe_2fdrive_2fproto_5fstructs_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_2fdrive_2fproto_5fstructs_2eproto();

  void InitAsDefaultInstance();
  static Directory* default_instance_;
};
// ===================================================================


// ===================================================================

// AttributesArchive

// required uint64 st_size = 1;
inline bool AttributesArchive::has_st_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttributesArchive::set_has_st_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttributesArchive::clear_has_st_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttributesArchive::clear_st_size() {
  st_size_ = GOOGLE_ULONGLONG(0);
  clear_has_st_size();
}
inline ::google::protobuf::uint64 AttributesArchive::st_size() const {
  return st_size_;
}
inline void AttributesArchive::set_st_size(::google::protobuf::uint64 value) {
  set_has_st_size();
  st_size_ = value;
}

// required bytes creation_time = 2;
inline bool AttributesArchive::has_creation_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttributesArchive::set_has_creation_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttributesArchive::clear_has_creation_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttributesArchive::clear_creation_time() {
  if (creation_time_ != &::google::protobuf::internal::GetEmptyString()) {
    creation_time_->clear();
  }
  clear_has_creation_time();
}
inline const ::std::string& AttributesArchive::creation_time() const {
  return *creation_time_;
}
inline void AttributesArchive::set_creation_time(const ::std::string& value) {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::GetEmptyString()) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(value);
}
inline void AttributesArchive::set_creation_time(const char* value) {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::GetEmptyString()) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(value);
}
inline void AttributesArchive::set_creation_time(const void* value, size_t size) {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::GetEmptyString()) {
    creation_time_ = new ::std::string;
  }
  creation_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AttributesArchive::mutable_creation_time() {
  set_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::GetEmptyString()) {
    creation_time_ = new ::std::string;
  }
  return creation_time_;
}
inline ::std::string* AttributesArchive::release_creation_time() {
  clear_has_creation_time();
  if (creation_time_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = creation_time_;
    creation_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void AttributesArchive::set_allocated_creation_time(::std::string* creation_time) {
  if (creation_time_ != &::google::protobuf::internal::GetEmptyString()) {
    delete creation_time_;
  }
  if (creation_time) {
    set_has_creation_time();
    creation_time_ = creation_time;
  } else {
    clear_has_creation_time();
    creation_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes last_access_time = 3;
inline bool AttributesArchive::has_last_access_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AttributesArchive::set_has_last_access_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AttributesArchive::clear_has_last_access_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AttributesArchive::clear_last_access_time() {
  if (last_access_time_ != &::google::protobuf::internal::GetEmptyString()) {
    last_access_time_->clear();
  }
  clear_has_last_access_time();
}
inline const ::std::string& AttributesArchive::last_access_time() const {
  return *last_access_time_;
}
inline void AttributesArchive::set_last_access_time(const ::std::string& value) {
  set_has_last_access_time();
  if (last_access_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_access_time_ = new ::std::string;
  }
  last_access_time_->assign(value);
}
inline void AttributesArchive::set_last_access_time(const char* value) {
  set_has_last_access_time();
  if (last_access_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_access_time_ = new ::std::string;
  }
  last_access_time_->assign(value);
}
inline void AttributesArchive::set_last_access_time(const void* value, size_t size) {
  set_has_last_access_time();
  if (last_access_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_access_time_ = new ::std::string;
  }
  last_access_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AttributesArchive::mutable_last_access_time() {
  set_has_last_access_time();
  if (last_access_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_access_time_ = new ::std::string;
  }
  return last_access_time_;
}
inline ::std::string* AttributesArchive::release_last_access_time() {
  clear_has_last_access_time();
  if (last_access_time_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = last_access_time_;
    last_access_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void AttributesArchive::set_allocated_last_access_time(::std::string* last_access_time) {
  if (last_access_time_ != &::google::protobuf::internal::GetEmptyString()) {
    delete last_access_time_;
  }
  if (last_access_time) {
    set_has_last_access_time();
    last_access_time_ = last_access_time;
  } else {
    clear_has_last_access_time();
    last_access_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required bytes last_write_time = 4;
inline bool AttributesArchive::has_last_write_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AttributesArchive::set_has_last_write_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AttributesArchive::clear_has_last_write_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AttributesArchive::clear_last_write_time() {
  if (last_write_time_ != &::google::protobuf::internal::GetEmptyString()) {
    last_write_time_->clear();
  }
  clear_has_last_write_time();
}
inline const ::std::string& AttributesArchive::last_write_time() const {
  return *last_write_time_;
}
inline void AttributesArchive::set_last_write_time(const ::std::string& value) {
  set_has_last_write_time();
  if (last_write_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_write_time_ = new ::std::string;
  }
  last_write_time_->assign(value);
}
inline void AttributesArchive::set_last_write_time(const char* value) {
  set_has_last_write_time();
  if (last_write_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_write_time_ = new ::std::string;
  }
  last_write_time_->assign(value);
}
inline void AttributesArchive::set_last_write_time(const void* value, size_t size) {
  set_has_last_write_time();
  if (last_write_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_write_time_ = new ::std::string;
  }
  last_write_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AttributesArchive::mutable_last_write_time() {
  set_has_last_write_time();
  if (last_write_time_ == &::google::protobuf::internal::GetEmptyString()) {
    last_write_time_ = new ::std::string;
  }
  return last_write_time_;
}
inline ::std::string* AttributesArchive::release_last_write_time() {
  clear_has_last_write_time();
  if (last_write_time_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = last_write_time_;
    last_write_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void AttributesArchive::set_allocated_last_write_time(::std::string* last_write_time) {
  if (last_write_time_ != &::google::protobuf::internal::GetEmptyString()) {
    delete last_write_time_;
  }
  if (last_write_time) {
    set_has_last_write_time();
    last_write_time_ = last_write_time;
  } else {
    clear_has_last_write_time();
    last_write_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint32 st_mode = 5;
inline bool AttributesArchive::has_st_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AttributesArchive::set_has_st_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AttributesArchive::clear_has_st_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AttributesArchive::clear_st_mode() {
  st_mode_ = 0u;
  clear_has_st_mode();
}
inline ::google::protobuf::uint32 AttributesArchive::st_mode() const {
  return st_mode_;
}
inline void AttributesArchive::set_st_mode(::google::protobuf::uint32 value) {
  set_has_st_mode();
  st_mode_ = value;
}

// optional uint64 win_attributes = 6;
inline bool AttributesArchive::has_win_attributes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AttributesArchive::set_has_win_attributes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AttributesArchive::clear_has_win_attributes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AttributesArchive::clear_win_attributes() {
  win_attributes_ = GOOGLE_ULONGLONG(0);
  clear_has_win_attributes();
}
inline ::google::protobuf::uint64 AttributesArchive::win_attributes() const {
  return win_attributes_;
}
inline void AttributesArchive::set_win_attributes(::google::protobuf::uint64 value) {
  set_has_win_attributes();
  win_attributes_ = value;
}

// optional bytes link_to = 7;
inline bool AttributesArchive::has_link_to() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AttributesArchive::set_has_link_to() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AttributesArchive::clear_has_link_to() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AttributesArchive::clear_link_to() {
  if (link_to_ != &::google::protobuf::internal::GetEmptyString()) {
    link_to_->clear();
  }
  clear_has_link_to();
}
inline const ::std::string& AttributesArchive::link_to() const {
  return *link_to_;
}
inline void AttributesArchive::set_link_to(const ::std::string& value) {
  set_has_link_to();
  if (link_to_ == &::google::protobuf::internal::GetEmptyString()) {
    link_to_ = new ::std::string;
  }
  link_to_->assign(value);
}
inline void AttributesArchive::set_link_to(const char* value) {
  set_has_link_to();
  if (link_to_ == &::google::protobuf::internal::GetEmptyString()) {
    link_to_ = new ::std::string;
  }
  link_to_->assign(value);
}
inline void AttributesArchive::set_link_to(const void* value, size_t size) {
  set_has_link_to();
  if (link_to_ == &::google::protobuf::internal::GetEmptyString()) {
    link_to_ = new ::std::string;
  }
  link_to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AttributesArchive::mutable_link_to() {
  set_has_link_to();
  if (link_to_ == &::google::protobuf::internal::GetEmptyString()) {
    link_to_ = new ::std::string;
  }
  return link_to_;
}
inline ::std::string* AttributesArchive::release_link_to() {
  clear_has_link_to();
  if (link_to_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = link_to_;
    link_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void AttributesArchive::set_allocated_link_to(::std::string* link_to) {
  if (link_to_ != &::google::protobuf::internal::GetEmptyString()) {
    delete link_to_;
  }
  if (link_to) {
    set_has_link_to();
    link_to_ = link_to;
  } else {
    clear_has_link_to();
    link_to_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 st_dev = 8;
inline bool AttributesArchive::has_st_dev() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AttributesArchive::set_has_st_dev() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AttributesArchive::clear_has_st_dev() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AttributesArchive::clear_st_dev() {
  st_dev_ = 0u;
  clear_has_st_dev();
}
inline ::google::protobuf::uint32 AttributesArchive::st_dev() const {
  return st_dev_;
}
inline void AttributesArchive::set_st_dev(::google::protobuf::uint32 value) {
  set_has_st_dev();
  st_dev_ = value;
}

// optional uint32 st_ino = 9;
inline bool AttributesArchive::has_st_ino() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AttributesArchive::set_has_st_ino() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AttributesArchive::clear_has_st_ino() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AttributesArchive::clear_st_ino() {
  st_ino_ = 0u;
  clear_has_st_ino();
}
inline ::google::protobuf::uint32 AttributesArchive::st_ino() const {
  return st_ino_;
}
inline void AttributesArchive::set_st_ino(::google::protobuf::uint32 value) {
  set_has_st_ino();
  st_ino_ = value;
}

// optional uint32 st_nlink = 10;
inline bool AttributesArchive::has_st_nlink() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AttributesArchive::set_has_st_nlink() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AttributesArchive::clear_has_st_nlink() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AttributesArchive::clear_st_nlink() {
  st_nlink_ = 0u;
  clear_has_st_nlink();
}
inline ::google::protobuf::uint32 AttributesArchive::st_nlink() const {
  return st_nlink_;
}
inline void AttributesArchive::set_st_nlink(::google::protobuf::uint32 value) {
  set_has_st_nlink();
  st_nlink_ = value;
}

// optional uint32 st_uid = 11;
inline bool AttributesArchive::has_st_uid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AttributesArchive::set_has_st_uid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AttributesArchive::clear_has_st_uid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AttributesArchive::clear_st_uid() {
  st_uid_ = 0u;
  clear_has_st_uid();
}
inline ::google::protobuf::uint32 AttributesArchive::st_uid() const {
  return st_uid_;
}
inline void AttributesArchive::set_st_uid(::google::protobuf::uint32 value) {
  set_has_st_uid();
  st_uid_ = value;
}

// optional uint32 st_gid = 12;
inline bool AttributesArchive::has_st_gid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AttributesArchive::set_has_st_gid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AttributesArchive::clear_has_st_gid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AttributesArchive::clear_st_gid() {
  st_gid_ = 0u;
  clear_has_st_gid();
}
inline ::google::protobuf::uint32 AttributesArchive::st_gid() const {
  return st_gid_;
}
inline void AttributesArchive::set_st_gid(::google::protobuf::uint32 value) {
  set_has_st_gid();
  st_gid_ = value;
}

// optional uint32 st_rdev = 13;
inline bool AttributesArchive::has_st_rdev() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AttributesArchive::set_has_st_rdev() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AttributesArchive::clear_has_st_rdev() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AttributesArchive::clear_st_rdev() {
  st_rdev_ = 0u;
  clear_has_st_rdev();
}
inline ::google::protobuf::uint32 AttributesArchive::st_rdev() const {
  return st_rdev_;
}
inline void AttributesArchive::set_st_rdev(::google::protobuf::uint32 value) {
  set_has_st_rdev();
  st_rdev_ = value;
}

// optional uint32 st_blksize = 14;
inline bool AttributesArchive::has_st_blksize() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AttributesArchive::set_has_st_blksize() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AttributesArchive::clear_has_st_blksize() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AttributesArchive::clear_st_blksize() {
  st_blksize_ = 0u;
  clear_has_st_blksize();
}
inline ::google::protobuf::uint32 AttributesArchive::st_blksize() const {
  return st_blksize_;
}
inline void AttributesArchive::set_st_blksize(::google::protobuf::uint32 value) {
  set_has_st_blksize();
  st_blksize_ = value;
}

// optional uint32 st_blocks = 15;
inline bool AttributesArchive::has_st_blocks() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AttributesArchive::set_has_st_blocks() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AttributesArchive::clear_has_st_blocks() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AttributesArchive::clear_st_blocks() {
  st_blocks_ = 0u;
  clear_has_st_blocks();
}
inline ::google::protobuf::uint32 AttributesArchive::st_blocks() const {
  return st_blocks_;
}
inline void AttributesArchive::set_st_blocks(::google::protobuf::uint32 value) {
  set_has_st_blocks();
  st_blocks_ = value;
}

// -------------------------------------------------------------------

// MetaData

// required bytes name = 1;
inline bool MetaData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MetaData::name() const {
  return *name_;
}
inline void MetaData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MetaData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MetaData::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MetaData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MetaData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required .maidsafe.drive.detail.protobuf.AttributesArchive attributes_archive = 2;
inline bool MetaData::has_attributes_archive() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaData::set_has_attributes_archive() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaData::clear_has_attributes_archive() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaData::clear_attributes_archive() {
  if (attributes_archive_ != NULL) attributes_archive_->::maidsafe::drive::detail::protobuf::AttributesArchive::Clear();
  clear_has_attributes_archive();
}
inline const ::maidsafe::drive::detail::protobuf::AttributesArchive& MetaData::attributes_archive() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attributes_archive_ != NULL ? *attributes_archive_ : *default_instance().attributes_archive_;
#else
  return attributes_archive_ != NULL ? *attributes_archive_ : *default_instance_->attributes_archive_;
#endif
}
inline ::maidsafe::drive::detail::protobuf::AttributesArchive* MetaData::mutable_attributes_archive() {
  set_has_attributes_archive();
  if (attributes_archive_ == NULL) attributes_archive_ = new ::maidsafe::drive::detail::protobuf::AttributesArchive;
  return attributes_archive_;
}
inline ::maidsafe::drive::detail::protobuf::AttributesArchive* MetaData::release_attributes_archive() {
  clear_has_attributes_archive();
  ::maidsafe::drive::detail::protobuf::AttributesArchive* temp = attributes_archive_;
  attributes_archive_ = NULL;
  return temp;
}
inline void MetaData::set_allocated_attributes_archive(::maidsafe::drive::detail::protobuf::AttributesArchive* attributes_archive) {
  delete attributes_archive_;
  attributes_archive_ = attributes_archive;
  if (attributes_archive) {
    set_has_attributes_archive();
  } else {
    clear_has_attributes_archive();
  }
}

// optional bytes serialised_data_map = 3;
inline bool MetaData::has_serialised_data_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaData::set_has_serialised_data_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaData::clear_has_serialised_data_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaData::clear_serialised_data_map() {
  if (serialised_data_map_ != &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_map_->clear();
  }
  clear_has_serialised_data_map();
}
inline const ::std::string& MetaData::serialised_data_map() const {
  return *serialised_data_map_;
}
inline void MetaData::set_serialised_data_map(const ::std::string& value) {
  set_has_serialised_data_map();
  if (serialised_data_map_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_map_ = new ::std::string;
  }
  serialised_data_map_->assign(value);
}
inline void MetaData::set_serialised_data_map(const char* value) {
  set_has_serialised_data_map();
  if (serialised_data_map_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_map_ = new ::std::string;
  }
  serialised_data_map_->assign(value);
}
inline void MetaData::set_serialised_data_map(const void* value, size_t size) {
  set_has_serialised_data_map();
  if (serialised_data_map_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_map_ = new ::std::string;
  }
  serialised_data_map_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_serialised_data_map() {
  set_has_serialised_data_map();
  if (serialised_data_map_ == &::google::protobuf::internal::GetEmptyString()) {
    serialised_data_map_ = new ::std::string;
  }
  return serialised_data_map_;
}
inline ::std::string* MetaData::release_serialised_data_map() {
  clear_has_serialised_data_map();
  if (serialised_data_map_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = serialised_data_map_;
    serialised_data_map_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MetaData::set_allocated_serialised_data_map(::std::string* serialised_data_map) {
  if (serialised_data_map_ != &::google::protobuf::internal::GetEmptyString()) {
    delete serialised_data_map_;
  }
  if (serialised_data_map) {
    set_has_serialised_data_map();
    serialised_data_map_ = serialised_data_map;
  } else {
    clear_has_serialised_data_map();
    serialised_data_map_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes directory_id = 4;
inline bool MetaData::has_directory_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MetaData::set_has_directory_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MetaData::clear_has_directory_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MetaData::clear_directory_id() {
  if (directory_id_ != &::google::protobuf::internal::GetEmptyString()) {
    directory_id_->clear();
  }
  clear_has_directory_id();
}
inline const ::std::string& MetaData::directory_id() const {
  return *directory_id_;
}
inline void MetaData::set_directory_id(const ::std::string& value) {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  directory_id_->assign(value);
}
inline void MetaData::set_directory_id(const char* value) {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  directory_id_->assign(value);
}
inline void MetaData::set_directory_id(const void* value, size_t size) {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  directory_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_directory_id() {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  return directory_id_;
}
inline ::std::string* MetaData::release_directory_id() {
  clear_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = directory_id_;
    directory_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MetaData::set_allocated_directory_id(::std::string* directory_id) {
  if (directory_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete directory_id_;
  }
  if (directory_id) {
    set_has_directory_id();
    directory_id_ = directory_id;
  } else {
    clear_has_directory_id();
    directory_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// Directory

// required bytes directory_id = 1;
inline bool Directory::has_directory_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Directory::set_has_directory_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Directory::clear_has_directory_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Directory::clear_directory_id() {
  if (directory_id_ != &::google::protobuf::internal::GetEmptyString()) {
    directory_id_->clear();
  }
  clear_has_directory_id();
}
inline const ::std::string& Directory::directory_id() const {
  return *directory_id_;
}
inline void Directory::set_directory_id(const ::std::string& value) {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  directory_id_->assign(value);
}
inline void Directory::set_directory_id(const char* value) {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  directory_id_->assign(value);
}
inline void Directory::set_directory_id(const void* value, size_t size) {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  directory_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Directory::mutable_directory_id() {
  set_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    directory_id_ = new ::std::string;
  }
  return directory_id_;
}
inline ::std::string* Directory::release_directory_id() {
  clear_has_directory_id();
  if (directory_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = directory_id_;
    directory_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Directory::set_allocated_directory_id(::std::string* directory_id) {
  if (directory_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete directory_id_;
  }
  if (directory_id) {
    set_has_directory_id();
    directory_id_ = directory_id;
  } else {
    clear_has_directory_id();
    directory_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required uint32 max_versions = 2;
inline bool Directory::has_max_versions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Directory::set_has_max_versions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Directory::clear_has_max_versions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Directory::clear_max_versions() {
  max_versions_ = 0u;
  clear_has_max_versions();
}
inline ::google::protobuf::uint32 Directory::max_versions() const {
  return max_versions_;
}
inline void Directory::set_max_versions(::google::protobuf::uint32 value) {
  set_has_max_versions();
  max_versions_ = value;
}

// repeated .maidsafe.drive.detail.protobuf.MetaData children = 3;
inline int Directory::children_size() const {
  return children_.size();
}
inline void Directory::clear_children() {
  children_.Clear();
}
inline const ::maidsafe::drive::detail::protobuf::MetaData& Directory::children(int index) const {
  return children_.Get(index);
}
inline ::maidsafe::drive::detail::protobuf::MetaData* Directory::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::maidsafe::drive::detail::protobuf::MetaData* Directory::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::drive::detail::protobuf::MetaData >&
Directory::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::drive::detail::protobuf::MetaData >*
Directory::mutable_children() {
  return &children_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace detail
}  // namespace drive
}  // namespace maidsafe

// @@protoc_insertion_point(global_scope)

#ifdef _MSC_VER
#  pragma warning(pop)
#endif

#endif  // PROTOBUF_maidsafe_2fdrive_2fproto_5fstructs_2eproto__INCLUDED
